###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:03
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_adc.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_adc.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_adc.lst
#    Object file  =  H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_adc.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:           
      9            *           - Initialization and Configuration
     10            *           - Power saving
     11            *           - Analog Watchdog configuration              
     12            *           - Temperature Sensor & Vrefint (Voltage Reference internal) management 
     13            *           - Regular Channels Configuration
     14            *           - Regular Channels DMA Configuration
     15            *           - Injected channels Configuration      
     16            *           - Interrupts and flags management       
     17            *         
     18            *  @verbatim
     19            *                               
     20            *          ===================================================================      
     21            *                                   How to use this driver
     22            *          ===================================================================      
     23            *          1. Enable The ADC controller clock using CLK_PeripheralClockConfig() 
     24            *            function : CLK_PeripheralClockConfig(CLK_Peripheral_ADC1, ENABLE).
     25            *
     26            *            2. Configure the ADC Prescaler, conversion resolution and data 
     27            *              alignment using the ADC_Init() function.
     28            * 
     29            *            3. Activate the ADC peripheral using ADC_Cmd() function.  
     30            *
     31            *          Regular channels group configuration
     32            *          ====================================    
     33            *            - To configure the ADC regular channels group features, use 
     34            *              ADC_Init() and ADC_RegularChannelConfig() functions.
     35            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     36            *              function.
     37            *            - To configure and activate the Discontinuous mode, use the 
     38            *              ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.        
     39            *            - To read the ADC converted values, use the ADC_GetConversionValue()
     40            *              function.
     41            *
     42            *          DMA for Regular channels group features configuration
     43            *          ====================================================== 
     44            *           - To enable the DMA mode for regular channels group, use the 
     45            *             ADC_DMACmd() function.
     46            *           - To enable the generation of DMA requests continuously at the end
     47            *             of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     48            *             function.    
     49                       
     50            *          Injected channels group configuration
     51            *          =====================================    
     52            *            - To configure the ADC Injected channels group features, use 
     53            *              ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     54            *              functions.
     55            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     56            *              function.
     57            *            - To activate the Injected Discontinuous mode, use the 
     58            *              ADC_InjectedDiscModeCmd() function.  
     59            *            - To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     60            *              function.        
     61            *            - To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     62            *              function.
     63            *              
     64            *  @endverbatim
     65            *         
     66            ******************************************************************************
     67            * @attention
     68            *
     69            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     70            *
     71            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     72            * You may not use this file except in compliance with the License.
     73            * You may obtain a copy of the License at:
     74            *
     75            *        http://www.st.com/software_license_agreement_liberty_v2
     76            *
     77            * Unless required by applicable law or agreed to in writing, software 
     78            * distributed under the License is distributed on an "AS IS" BASIS, 
     79            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     80            * See the License for the specific language governing permissions and
     81            * limitations under the License.
     82            *
     83            ******************************************************************************
     84            */ 
     85          
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm8l15x_adc.h"
     88          
     89          /** @addtogroup STM8L15x_StdPeriph_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup ADC 
     94            * @brief ADC driver modules
     95            * @{
     96            */ 
     97            
     98          /* Private typedef -----------------------------------------------------------*/
     99          /* Private define ------------------------------------------------------------*/
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          /* Private function prototypes -----------------------------------------------*/
    103          /* Private functions ---------------------------------------------------------*/
    104          
    105          /** @defgroup ADC_Private_Functions
    106            * @{
    107            */ 
    108              
    109              
    110          /** @defgroup ADC_Group1 Initialization and Configuration functions
    111           *  @brief   Initialization and Configuration functions 
    112           *
    113          @verbatim    
    114           ===============================================================================
    115                                Initialization and Configuration functions
    116           ===============================================================================  
    117            This section provides functions allowing to:
    118             - Enable or disable the ADC peripheral,
    119             - Initialize and configure the ADC Prescaler, ADC Conversion Resolution 
    120               (12bit..6bit), ADC Continuous Conversion Mode (Continuous or Single 
    121               conversion),
    122             - Configure External trigger Sensitivity and source,
    123             - Start ADC conversion, by software trigger.
    124          
    125          
    126          @endverbatim
    127            * @{
    128            */
    129          /**
    130            * @brief  Deinitializes the ADC peripheral registers to their default reset 
    131            *         values.
    132            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    133            * @retval None
    134            */
    135          void ADC_DeInit(ADC_T* ADCx)
    136          {
    137            /*  Set the Configuration registers to their reset values */
    138            ADCx->CR1 =  ADC_CR1_RESET_VALUE;
    139            ADCx->CR2 =  ADC_CR2_RESET_VALUE;
    140            ADCx->CR3 =  ADC_CR3_RESET_VALUE;
    141          
    142            /*  Set the status registers to their reset values */
    143            ADCx->SR =  (uint8_t)~ADC_SR_RESET_VALUE;
    144          
    145            /*  Set the High threshold registers to their reset values */
    146            ADCx->HTRH =  ADC_HTRH_RESET_VALUE;
    147            ADCx->HTRL =  ADC_HTRL_RESET_VALUE;
    148          
    149            /*  Set the low threshold registers to their reset values */
    150            ADCx->LTRH =  ADC_LTRH_RESET_VALUE;
    151            ADCx->LTRL =  ADC_LTRL_RESET_VALUE;
    152          
    153            /*  Set the channels sequence registers to their reset values */
    154            ADCx->SQR[0] =  ADC_SQR1_RESET_VALUE;
    155            ADCx->SQR[1] =  ADC_SQR2_RESET_VALUE;
    156            ADCx->SQR[2] =  ADC_SQR3_RESET_VALUE;
    157            ADCx->SQR[3] =  ADC_SQR4_RESET_VALUE;
    158          
    159            /*  Set the channels Trigger registers to their reset values */
    160            ADCx->TRIGR[0] =  ADC_TRIGR1_RESET_VALUE;
    161            ADCx->TRIGR[1] =  ADC_TRIGR2_RESET_VALUE;
    162            ADCx->TRIGR[2] =  ADC_TRIGR3_RESET_VALUE;
    163            ADCx->TRIGR[3] =  ADC_TRIGR4_RESET_VALUE;
    164          }
    165          
    166          /**
    167            * @brief  Initializes the specified ADC peripheral according to the specified 
    168            *         parameters.
    169            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    170            * @param  ADC_ConversionMode : specifies the ADC conversion mode,
    171            *          This parameter can be one of the following values:
    172            *            @arg ADC_ConversionMode_Single: Single Conversion Mode
    173            *            @arg ADC_ConversionMode_Continuous: Continuous Conversion Mode
    174            * @param  ADC_Resolution : specifies the ADC Data resolution,
    175            *          This parameter can be one of the following values:
    176            *            @arg ADC_Resolution_12Bit: 12 bit resolution
    177            *            @arg ADC_Resolution_10Bit: 10 bit resolution
    178            *            @arg ADC_Resolution_8Bit: 8 bit resolution
    179            *            @arg ADC_Resolution_6Bit: 6 bit resolution      
    180            * @param  ADC_Prescaler : specifies the ADC Prescaler,
    181            *          This parameter can be one of the following values:
    182            *            @arg ADC_Prescaler_1: ADC Clock frequency is divided by 1
    183            *            @arg ADC_Prescaler_2: ADC Clock frequency is divided by 2
    184            * @retval None
    185            */
    186          void ADC_Init(ADC_T* ADCx,
    187                        ADC_ConversionMode_T ADC_ConversionMode,
    188                        ADC_Resolution_T ADC_Resolution,
    189                        ADC_Prescaler_T ADC_Prescaler)
    190          {
    191            /* Check the parameters */
    192            assert_param(IS_ADC_CONVERSION_MODE(ADC_ConversionMode));
    193            assert_param(IS_ADC_RESOLUTION(ADC_Resolution));
    194            assert_param(IS_ADC_PRESCALER(ADC_Prescaler));
    195          
    196            /*clear CR1 register */
    197            ADCx->CR1 &= (uint8_t)~(ADC_CR1_CONT | ADC_CR1_RES);
    198          
    199            /* set the resolution and the conversion mode */
    200            ADCx->CR1 |= (uint8_t)((uint8_t)ADC_ConversionMode | (uint8_t)ADC_Resolution);
    201          
    202            /*clear CR2 register */
    203            ADCx->CR2 &= (uint8_t)~(ADC_CR2_PRESC);
    204          
    205            /* set the Prescaler */
    206            ADCx->CR2 |= (uint8_t) ADC_Prescaler;
    207          }
    208          
    209          /**
    210            * @brief  Enables or disables the selected ADC peripheral.
    211            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    212            * @param  NewState : new state of the specified ADC peripheral.
    213              *         This parameter can be: ENABLE or DISABLE.
    214            * @retval None
    215            */
    216          void ADC_Cmd(ADC_T* ADCx,
    217                       FunctionalState NewState)
    218          {
    219            /* Check the parameters */
    220            assert_param(IS_FUNCTIONAL_STATE(NewState));
    221          
    222            if (NewState != DISABLE)
    223            {
    224              /* Set the ADON bit to wake up the specified ADC from power down mode */
    225              ADCx->CR1 |= ADC_CR1_ADON;
    226            }
    227            else
    228            {
    229              /* Disable the selected ADC peripheral */
    230              ADCx->CR1 &= (uint8_t)~ADC_CR1_ADON;
    231            }
    232          }
    233          
    234          /**
    235            * @brief  Starts ADC conversion, by software trigger.
    236            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    237            * @retval None
    238            */
    239          void ADC_SoftwareStartConv(ADC_T* ADCx)
    240          {
    241            /*  Start the ADC software conversion */
    242            ADCx->CR1 |= ADC_CR1_START;
    243          }
    244          
    245          /**
    246            * @brief  Configures the ADC conversion through external trigger.
    247            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    248            * @param  ADC_ExtEventSelection : Specifies the external trigger.
    249            *          This parameter can be one of the following values:
    250            *            @arg ADC_ExtEventSelection_None: Conversion starts only by software start
    251            *            @arg ADC_ExtEventSelection_Trigger1: Trigger 1  Enables conversion
    252            *            @arg ADC_ExtEventSelection_Trigger2: Trigger 2  Enables conversion
    253            *            @arg ADC_ExtEventSelection_Trigger3: Trigger 3  Enables conversion      
    254            * @param  ADC_ExtTRGSensitivity : Specifies the external trigger sensitivity.
    255            *          This parameter can be one of the following values:
    256            *            @arg ADC_ExtTRGSensitivity_Rising: External Trigger Sensitivity is Rising Edge
    257            *            @arg ADC_ExtTRGSensitivity_Falling: External Trigger Sensitivity is Falling Edge
    258            *            @arg ADC_ExtTRGSensitivity_All: External Trigger Sensitivity is Falling and Rising Edge
    259            * @retval None
    260            */
    261          void ADC_ExternalTrigConfig(ADC_T* ADCx,
    262                                      ADC_ExtEventSelection_T ADC_ExtEventSelection,
    263                                      ADC_ExtTRGSensitivity_T ADC_ExtTRGSensitivity)
    264          {
    265            /* Check the parameters */
    266            assert_param(IS_ADC_EXT_EVENT_SELECTION(ADC_ExtEventSelection));
    267            assert_param(IS_ADC_EXT_TRG_SENSITIVITY(ADC_ExtTRGSensitivity));
    268          
    269            /*clear old configuration of CR2 register */
    270            ADCx->CR2 &= (uint8_t)~(ADC_CR2_TRIGEDGE | ADC_CR2_EXTSEL);
    271          
    272            /* set the External Trigger Edge Sensitivity  and the external event 
    273               selection */
    274            ADCx->CR2 |= (uint8_t)( (uint8_t)ADC_ExtTRGSensitivity | \
    275                                    (uint8_t)ADC_ExtEventSelection);
    276          }
    277          
    278           /**
    279            * @}
    280            */
    281          
    282          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    283           *  @brief   Analog Watchdog configuration functions 
    284           *
    285          @verbatim   
    286           ===============================================================================
    287                              Analog Watchdog configuration functions
    288           ===============================================================================  
    289          
    290            This section provides functions allowing to configure the Analog Watchdog
    291            (AWD) feature in the ADC.
    292            
    293            A typical configuration Analog Watchdog is done following these steps :
    294             1. the ADC guarded channel is selected using the 
    295                ADC_AnalogWatchdogChannelSelect() function.
    296             2. The Analog watchdog lower and higher threshold are configured using the  
    297                ADC_AnalogWatchdogThresholdsConfig() function.
    298             
    299             Note : Both AWD selection and thresholds can be configured with one unique 
    300                    function ADC_AnalogWatchdogConfig(), which is kept for firmware 
    301                    compatibility reason.
    302          
    303          @endverbatim
    304            * @{
    305            */
    306          /**
    307            * @brief  Configures the channel to be checked by the Analog watchdog.
    308            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    309            * @param  ADC_AnalogWatchdogSelection : Specifies the channel to be checked 
    310            *         by the Analog watchdog.
    311            *          This parameter can be one of the following values:
    312            *            @arg ADC_AnalogWatchdogSelection_Channel0: AWD affected to Channel 0
    313            *            @arg ADC_AnalogWatchdogSelection_Channel1: AWD affected to Channel 1
    314            *            @arg ADC_AnalogWatchdogSelection_Channel2: AWD affected to Channel 2
    315            *            @arg ADC_AnalogWatchdogSelection_Channel3: AWD affected to Channel 3
    316            *            @arg ADC_AnalogWatchdogSelection_Channel4: AWD affected to Channel 4
    317            *            @arg ADC_AnalogWatchdogSelection_Channel5: AWD affected to Channel 5
    318            *            @arg ADC_AnalogWatchdogSelection_Channel6: AWD affected to Channel 6
    319            *            @arg ADC_AnalogWatchdogSelection_Channel7: AWD affected to Channel 7
    320            *            @arg ADC_AnalogWatchdogSelection_Channel8: AWD affected to Channel 8
    321            *            @arg ADC_AnalogWatchdogSelection_Channel9: AWD affected to Channel 9
    322            *            @arg ADC_AnalogWatchdogSelection_Channel10: AWD affected to Channel 10
    323            *            @arg ADC_AnalogWatchdogSelection_Channel11: AWD affected to Channel 11
    324            *            @arg ADC_AnalogWatchdogSelection_Channel12: AWD affected to Channel 12
    325            *            @arg ADC_AnalogWatchdogSelection_Channel13: AWD affected to Channel 13
    326            *            @arg ADC_AnalogWatchdogSelection_Channel14: AWD affected to Channel 14
    327            *            @arg ADC_AnalogWatchdogSelection_Channel15: AWD affected to Channel 15
    328            *            @arg ADC_AnalogWatchdogSelection_Channel16: AWD affected to Channel 16
    329            *            @arg ADC_AnalogWatchdogSelection_Channel17: AWD affected to Channel 17
    330            *            @arg ADC_AnalogWatchdogSelection_Channel18: AWD affected to Channel 18
    331            *            @arg ADC_AnalogWatchdogSelection_Channel19: AWD affected to Channel 19
    332            *            @arg ADC_AnalogWatchdogSelection_Channel20: AWD affected to Channel 20
    333            *            @arg ADC_AnalogWatchdogSelection_Channel21: AWD affected to Channel 21
    334            *            @arg ADC_AnalogWatchdogSelection_Channel22: AWD affected to Channel 22
    335            *            @arg ADC_AnalogWatchdogSelection_Channel23: AWD affected to Channel 23
    336            *         @ref ADC_AnalogWatchdogSelection_T enumeration.
    337            * @retval None
    338            */
    339          void ADC_AnalogWatchdogChannelSelect(ADC_T* ADCx,
    340                                               ADC_AnalogWatchdogSelection_T ADC_AnalogWatchdogSelection)
    341          {
    342            /* Check the parameters */
    343            assert_param(IS_ADC_ANALOGWATCHDOG_SELECTION(ADC_AnalogWatchdogSelection));
    344          
    345            /* Reset the CHSEL bits */
    346            ADCx->CR3 &= ((uint8_t)~ADC_CR3_CHSEL);
    347          
    348            /* Select the channel to be checked by the Analog watchdog */
    349            ADCx->CR3 |= (uint8_t)ADC_AnalogWatchdogSelection;
    350          }
    351          
    352          /**
    353            * @brief  Configures the high and low thresholds of the Analog watchdog.
    354            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    355            * @param  HighThreshold: Analog watchdog High threshold value.
    356              *       This parameter must be a 12bit value.
    357            * @param  LowThreshold: Analog watchdog Low threshold value.
    358              *       This parameter must be a 12bit value.
    359            * @retval None
    360            */
    361          void ADC_AnalogWatchdogThresholdsConfig(ADC_T* ADCx, uint16_t HighThreshold, uint16_t LowThreshold)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    365            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    366          
    367            /* Set the ADC high threshold */
    368            ADCx->HTRH = (uint8_t)(HighThreshold >> 8);
    369            ADCx->HTRL = (uint8_t)(HighThreshold);
    370          
    371            /* Set the ADC low threshold */
    372            ADCx->LTRH = (uint8_t)(LowThreshold >> 8);
    373            ADCx->LTRL = (uint8_t)(LowThreshold);
    374          }
    375          
    376          /**
    377            * @brief  Configures the Analog watchdog.
    378            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    379            * @param  ADC_AnalogWatchdogSelection : Specifies the channel to be checked 
    380            *         by the Analog watchdog.
    381            *          This parameter can be one of the following values:
    382            *            @arg ADC_AnalogWatchdogSelection_Channel0: AWD affected to Channel 0
    383            *            @arg ADC_AnalogWatchdogSelection_Channel1: AWD affected to Channel 1
    384            *            @arg ADC_AnalogWatchdogSelection_Channel2: AWD affected to Channel 2
    385            *            @arg ADC_AnalogWatchdogSelection_Channel3: AWD affected to Channel 3
    386            *            @arg ADC_AnalogWatchdogSelection_Channel4: AWD affected to Channel 4
    387            *            @arg ADC_AnalogWatchdogSelection_Channel5: AWD affected to Channel 5
    388            *            @arg ADC_AnalogWatchdogSelection_Channel6: AWD affected to Channel 6
    389            *            @arg ADC_AnalogWatchdogSelection_Channel7: AWD affected to Channel 7
    390            *            @arg ADC_AnalogWatchdogSelection_Channel8: AWD affected to Channel 8
    391            *            @arg ADC_AnalogWatchdogSelection_Channel9: AWD affected to Channel 9
    392            *            @arg ADC_AnalogWatchdogSelection_Channel10: AWD affected to Channel 10
    393            *            @arg ADC_AnalogWatchdogSelection_Channel11: AWD affected to Channel 11
    394            *            @arg ADC_AnalogWatchdogSelection_Channel12: AWD affected to Channel 12
    395            *            @arg ADC_AnalogWatchdogSelection_Channel13: AWD affected to Channel 13
    396            *            @arg ADC_AnalogWatchdogSelection_Channel14: AWD affected to Channel 14
    397            *            @arg ADC_AnalogWatchdogSelection_Channel15: AWD affected to Channel 15
    398            *            @arg ADC_AnalogWatchdogSelection_Channel16: AWD affected to Channel 16
    399            *            @arg ADC_AnalogWatchdogSelection_Channel17: AWD affected to Channel 17
    400            *            @arg ADC_AnalogWatchdogSelection_Channel18: AWD affected to Channel 18
    401            *            @arg ADC_AnalogWatchdogSelection_Channel19: AWD affected to Channel 19
    402            *            @arg ADC_AnalogWatchdogSelection_Channel20: AWD affected to Channel 20
    403            *            @arg ADC_AnalogWatchdogSelection_Channel21: AWD affected to Channel 21
    404            *            @arg ADC_AnalogWatchdogSelection_Channel22: AWD affected to Channel 22
    405            *            @arg ADC_AnalogWatchdogSelection_Channel23: AWD affected to Channel 23  
    406            * @param  HighThreshold: Analog watchdog High threshold value.
    407              *       This parameter must be a 12bit value.
    408            * @param  LowThreshold: Analog watchdog Low threshold value.
    409              *       This parameter must be a 12bit value.
    410            * @retval None
    411            */
    412          void ADC_AnalogWatchdogConfig(ADC_T* ADCx,
    413                                        ADC_AnalogWatchdogSelection_T ADC_AnalogWatchdogSelection,
    414                                        uint16_t HighThreshold,
    415                                        uint16_t LowThreshold)
    416          {
    417            /* Check the parameters */
    418            assert_param(IS_ADC_ANALOGWATCHDOG_SELECTION(ADC_AnalogWatchdogSelection));
    419            assert_param(IS_ADC_THRESHOLD(HighThreshold));
    420            assert_param(IS_ADC_THRESHOLD(LowThreshold));
    421          
    422            /*Reset the CHSEL bits */
    423            ADCx->CR3 &= ((uint8_t)~ADC_CR3_CHSEL);
    424          
    425            /* Select the channel to be checked by the Analog watchdog.*/
    426            ADCx->CR3 |= (uint8_t)ADC_AnalogWatchdogSelection;
    427          
    428            /* Set the ADC high threshold */
    429            ADCx->HTRH = (uint8_t)(HighThreshold >> 8);
    430            ADCx->HTRL = (uint8_t)(HighThreshold);
    431          
    432            /* Set the ADC low threshold */
    433            ADCx->LTRH = (uint8_t)(LowThreshold >> 8);
    434            ADCx->LTRL = (uint8_t)LowThreshold;
    435          }
    436          
    437           /**
    438            * @}
    439            */
    440          
    441          /** @defgroup ADC_Group3 Temperature Sensor & Vrefint (Voltage Reference 
    442           *            internal) management functions
    443           *  @brief   Temperature Sensor & Vrefint (Voltage Reference internal) 
    444           *            management functions 
    445           *
    446          @verbatim   
    447           ===============================================================================
    448            Temperature Sensor & Vrefint (Voltage Reference internal) management functions
    449           ===============================================================================  
    450          
    451            This section provides functions allowing to enable/ disable the internal 
    452            connections between the ADC and the Temperature Sensor and the Vrefint source.
    453               
    454            A typical configuration to get the Temperature sensor or/and Vrefint channels 
    455            voltages is done following these steps :
    456             1. Enable the internal connection of Temperature sensor or/and Vrefint sources 
    457                with the ADC channels: 
    458                - for the Temperature sensor using ADC_TempSensorCmd() function.
    459                - for the Internal Voltage reference using ADC_VrefintCmd() function. 
    460             2. Enable the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint channels 
    461                using ADC_ChannelCmd()function. 
    462             3. Get the voltage values, using ADC_GetConversionValue().
    463           
    464          @endverbatim
    465            * @{
    466            */
    467            
    468          /**
    469            * @brief  Enables or disables the Temperature sensor internal reference.
    470            * @param  NewState : new state of the Temperature sensor internal reference.
    471              *         This parameter can be: ENABLE or DISABLE.
    472            * @retval None
    473            */
    474          void ADC_TempSensorCmd(FunctionalState NewState)
    475          {
    476            /* Check the parameters */
    477            assert_param(IS_FUNCTIONAL_STATE(NewState));
    478          
    479            if (NewState != DISABLE)
    480            {
    481              /*Enable the Temperature sensor internal reference.*/
    482              ADC1->TRIGR[0] |= (uint8_t)(ADC_TRIGR1_TSON);
    483            }
    484            else
    485            {
    486              /*Disable the Temperature sensor internal reference.*/
    487              ADC1->TRIGR[0] &= (uint8_t)(~ADC_TRIGR1_TSON);
    488            }
    489          }
    490          
    491          /**
    492            * @brief  Enables or disables the Internal Voltage reference.
    493            * @param  NewState : new state of the Internal Voltage reference.
    494              *         This parameter can be: ENABLE or DISABLE.
    495            * @retval None
    496            */
    497          void ADC_VrefintCmd(FunctionalState NewState)
    498          {
    499            /* Check the parameters */
    500            assert_param(IS_FUNCTIONAL_STATE(NewState));
    501          
    502            if (NewState != DISABLE)
    503            {
    504              /* Enable the Internal Voltage reference.*/
    505              ADC1->TRIGR[0] |= (uint8_t)(ADC_TRIGR1_VREFINTON);
    506            }
    507            else
    508            {
    509              /* Disable the Internal Voltage reference.*/
    510              ADC1->TRIGR[0] &= (uint8_t)(~ADC_TRIGR1_VREFINTON);
    511            }
    512          }
    513          
    514           /**
    515            * @}
    516            */
    517          /** @defgroup ADC_Group4 Channels Configuration functions
    518           *  @brief   Channels Configuration functions
    519           *
    520          @verbatim    
    521           ===============================================================================
    522                                Channels Configuration functions
    523           ===============================================================================  
    524            This section provides functions allowing to:
    525             - Enable or disable the ADC channel using ADC_ChannelCmd() function,
    526             - Configure the channels sampling times using ADC_SamplingTimeConfig() 
    527               function.
    528               Note: there are 2 sampling times configuration values : 
    529                      - 1st Group value : for channels 0..23  
    530                      - 2nd Group value : for channels 24..27 (depending on the MCU 
    531                        package density) and Temperature Sensor and Vrefint channels. 
    532             - Configure the channels Schmitt Trigger for each channel using 
    533               ADC_SchmittTriggerConfig() function.
    534             - Get the current ADC conversion value.
    535             
    536           @endverbatim
    537            * @{
    538            */
    539              
    540          /**
    541            * @brief  Enables or disables the selected ADC channel(s).
    542            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    543            * @param  ADC_Channels: specifies the ADC channels to be initialized
    544            *          This parameter can be one of the following values:
    545            *            @arg ADC_Channel_0: Channel 0
    546            *            @arg ADC_Channel_1: Channel 1
    547            *            @arg ADC_Channel_2: Channel 2
    548            *            @arg ADC_Channel_3: Channel 3
    549            *            @arg ADC_Channel_4: Channel 4
    550            *            @arg ADC_Channel_5: Channel 5
    551            *            @arg ADC_Channel_6: Channel 6
    552            *            @arg ADC_Channel_7: Channel 7
    553            *            @arg ADC_Channel_8: Channel 8
    554            *            @arg ADC_Channel_9: Channel 9
    555            *            @arg ADC_Channel_10: Channel 10
    556            *            @arg ADC_Channel_11: Channel 11
    557            *            @arg ADC_Channel_12: Channel 12
    558            *            @arg ADC_Channel_13: Channel 13
    559            *            @arg ADC_Channel_14: Channel 14
    560            *            @arg ADC_Channel_15: Channel 15
    561            *            @arg ADC_Channel_16: Channel 16
    562            *            @arg ADC_Channel_17: Channel 17
    563            *            @arg ADC_Channel_18: Channel 18
    564            *            @arg ADC_Channel_19: Channel 19
    565            *            @arg ADC_Channel_20: Channel 20
    566            *            @arg ADC_Channel_21: Channel 21
    567            *            @arg ADC_Channel_22: Channel 22
    568            *            @arg ADC_Channel_23: Channel 23
    569            *            @arg ADC_Channel_24: Channel 24
    570            *            @arg ADC_Channel_25: Channel 25
    571            *            @arg ADC_Channel_26: Channel 26
    572            *            @arg ADC_Channel_27: Channel 27
    573            *            @arg ADC_Channel_Vrefint: Vrefint Channel
    574            *            @arg ADC_Channel_TempSensor: Temperature sensor Channel
    575            *            @arg ADC_Channel_00To07: select from channel00 to channel07
    576            *            @arg ADC_Channel_08To15: select from channel08 to channel15
    577            *            @arg ADC_Channel_16To23: select from channel16 to channel23
    578            *            @arg ADC_Channel_24To27: select from channel24 to channel27
    579            * @param  NewState : new state of the specified ADC channel(s).
    580              *         This parameter can be: ENABLE or DISABLE.
    581            * @retval None
    582            */
    583          void ADC_ChannelCmd(ADC_T* ADCx, ADC_Channel_T ADC_Channels, FunctionalState NewState)
    584          {
    585            uint8_t regindex = 0;
    586            /* Check the parameters */
    587            assert_param(IS_FUNCTIONAL_STATE(NewState));
    588          
    589            regindex = (uint8_t)((uint16_t)ADC_Channels >> 8);
    590          
    591            if (NewState != DISABLE)
    592            {
    593              /* Enable the selected ADC channel(s). */
    594              ADCx->SQR[regindex] |= (uint8_t)(ADC_Channels);
    595            }
    596            else
    597            {
    598              /* Disable the selected ADC channel(s). */
    599              ADCx->SQR[regindex] &= (uint8_t)(~(uint8_t)(ADC_Channels));
    600            }
    601          }
    602          
    603          /**
    604            * @brief  Configures the sampling time for the selected ADC channel group.
    605            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    606            * @param  ADC_GroupChannels : ADC channel group to configure.
    607            *          This parameter can be one of the following values:
    608            *            @arg ADC_Group_SlowChannels: Slow Channels group
    609            *            @arg ADC_Group_FastChannels: Fast Channels group  
    610            * @note   The channels of 1st ADC Group can be channels 0..23  
    611            * @note   The channels of 2nd ADC Group can be channels 24..27 (depending on the MCU 
    612            *         package density) and Temperature Sensor and Vrefint channels.  
    613            * @param  ADC_SamplingTime : Specifies the sample time value
    614            *          This parameter can be one of the following values:
    615            *            @arg ADC_SamplingTime_4Cycles: Sampling Time Cycles is 4
    616            *            @arg ADC_SamplingTime_9Cycles: Sampling Time Cycles is 9
    617            *            @arg ADC_SamplingTime_16Cycles: Sampling Time Cycles is 16
    618            *            @arg ADC_SamplingTime_24Cycles: Sampling Time Cycles is 24
    619            *            @arg ADC_SamplingTime_48Cycles: Sampling Time Cycles is 48
    620            *            @arg ADC_SamplingTime_96Cycles: Sampling Time Cycles is 96
    621            *            @arg ADC_SamplingTime_192Cycles: Sampling Time Cycles is 192
    622            *            @arg ADC_SamplingTime_384Cycles: Sampling Time Cycles is 384
    623            * @retval None
    624            */
    625          void ADC_SamplingTimeConfig(ADC_T* ADCx,
    626                                      ADC_Group_T ADC_GroupChannels,
    627                                      ADC_SamplingTime_T ADC_SamplingTime)
    628          {
    629            /* Check the parameters */
    630            assert_param(IS_ADC_GROUP(ADC_GroupChannels));
    631            assert_param(IS_ADC_SAMPLING_TIME_CYCLES(ADC_SamplingTime));
    632          
    633            if ( ADC_GroupChannels != ADC_Group_SlowChannels)
    634            {
    635              /* Configures the sampling time for the Fast ADC channel group. */
    636              ADCx->CR3 &= (uint8_t)~ADC_CR3_SMPT2;
    637              ADCx->CR3 |= (uint8_t)(ADC_SamplingTime << 5);
    638            }
    639            else
    640            {
    641              /* Configures the sampling time for the Slow ADC channel group. */
    642              ADCx->CR2 &= (uint8_t)~ADC_CR2_SMPT1;
    643              ADCx->CR2 |= (uint8_t)ADC_SamplingTime;
    644            }
    645          }
    646          
    647          /**
    648            * @brief  Configures the status of the Schmitt Trigger for the selected ADC 
    649            *         channel(s).
    650            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    651            * @param  ADC_Channels: specifies the ADC channels to be initialized,
    652            *          This parameter can be one of the following values:
    653            *            @arg ADC_Channel_0: Channel 0
    654            *            @arg ADC_Channel_1: Channel 1
    655            *            @arg ADC_Channel_2: Channel 2
    656            *            @arg ADC_Channel_3: Channel 3
    657            *            @arg ADC_Channel_4: Channel 4
    658            *            @arg ADC_Channel_5: Channel 5
    659            *            @arg ADC_Channel_6: Channel 6
    660            *            @arg ADC_Channel_7: Channel 7
    661            *            @arg ADC_Channel_8: Channel 8
    662            *            @arg ADC_Channel_9: Channel 9
    663            *            @arg ADC_Channel_10: Channel 10
    664            *            @arg ADC_Channel_11: Channel 11
    665            *            @arg ADC_Channel_12: Channel 12
    666            *            @arg ADC_Channel_13: Channel 13
    667            *            @arg ADC_Channel_14: Channel 14
    668            *            @arg ADC_Channel_15: Channel 15
    669            *            @arg ADC_Channel_16: Channel 16
    670            *            @arg ADC_Channel_17: Channel 17
    671            *            @arg ADC_Channel_18: Channel 18
    672            *            @arg ADC_Channel_19: Channel 19
    673            *            @arg ADC_Channel_20: Channel 20
    674            *            @arg ADC_Channel_21: Channel 21
    675            *            @arg ADC_Channel_22: Channel 22
    676            *            @arg ADC_Channel_23: Channel 23
    677            *            @arg ADC_Channel_24: Channel 24
    678            *            @arg ADC_Channel_25: Channel 25
    679            *            @arg ADC_Channel_26: Channel 26
    680            *            @arg ADC_Channel_27: Channel 27
    681            *            @arg ADC_Channel_Vrefint: Vrefint Channel
    682            *            @arg ADC_Channel_TempSensor: Temperature sensor Channel
    683            *            @arg ADC_Channel_00To07: select from channel00 to channel07
    684            *            @arg ADC_Channel_08To15: select from channel08 to channel15
    685            *            @arg ADC_Channel_16To23: select from channel16 to channel23
    686            *            @arg ADC_Channel_24To27: select from channel24 to channel27
    687            * @param  NewState : new state of the Schmitt Trigger
    688              *         This parameter can be: ENABLE or DISABLE.
    689            * @retval None
    690            */
    691          void ADC_SchmittTriggerConfig(ADC_T* ADCx, ADC_Channel_T ADC_Channels,
    692                                        FunctionalState NewState)
    693          {
    694            uint8_t regindex = 0;
    695            /* Check the parameters */
    696            assert_param(IS_FUNCTIONAL_STATE(NewState));
    697          
    698            regindex = (uint8_t)((uint16_t)ADC_Channels >> 8);
    699          
    700            if (NewState != DISABLE)
    701            {
    702              /* Enable the Schmitt Trigger for the selected ADC channel(s).*/
    703              ADCx->TRIGR[regindex] &= (uint8_t)(~(uint8_t)ADC_Channels);
    704            }
    705            else
    706            {
    707              /* Disable the Schmitt Trigger for the selected ADC channel(s).*/
    708              ADCx->TRIGR[regindex] |= (uint8_t)(ADC_Channels);
    709            }
    710          }
    711          
    712          /**
    713            * @brief  Returns the last ADC converted data.
    714            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    715            * @retval The Data conversion value.
    716            */
    717          uint16_t ADC_GetConversionValue(ADC_T* ADCx)
    718          {
    719            uint16_t tmpreg = 0;
    720          
    721            /* Get last ADC converted data.*/
    722            tmpreg = (uint16_t)(ADCx->DRH);
    723            tmpreg = (uint16_t)((uint16_t)((uint16_t)tmpreg << 8) | ADCx->DRL);
    724          
    725            /* Return the selected ADC conversion value */
    726            return (uint16_t)(tmpreg) ;
    727          }
    728          
    729           /**
    730            * @}
    731            */
    732          
    733          /** @defgroup ADC_Group5 ADC Channels DMA Configuration function
    734           *  @brief   ADC Channels DMA Configuration function 
    735           *
    736          @verbatim   
    737           ===============================================================================
    738                             ADC Channels DMA Configuration function
    739           ===============================================================================  
    740          
    741            This section provides a function allowing to configure the DMA for ADC 
    742            channel.
    743            Since converted channel values are stored into a unique data register, 
    744            it is useful to use DMA for conversion of more than one channel. This 
    745            avoids the loss of the data already stored in the ADC Data register. 
    746            
    747            When the DMA mode is enabled (using the ADC_DMACmd() function), after each
    748            conversion of a channel, a DMA request is generated.
    749          
    750          @endverbatim
    751            * @{
    752            */
    753          /**
    754            * @brief  Enables or disables the specified ADC DMA request.
    755            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    756            * @param  NewState : new state of the specified ADC DMA transfer.
    757              *         This parameter can be: ENABLE or DISABLE.
    758            * @retval None
    759            */
    760          void ADC_DMACmd(ADC_T* ADCx, FunctionalState NewState)
    761          {
    762            /* Check the parameters */
    763            assert_param(IS_FUNCTIONAL_STATE(NewState));
    764          
    765            if (NewState != DISABLE)
    766            {
    767              /* Enable the specified ADC DMA request */
    768              ADCx->SQR[0] &= (uint8_t)~ADC_SQR1_DMAOFF;
    769            }
    770            else
    771            {
    772              /* Disable the specified ADC DMA request */
    773              ADCx->SQR[0] |= ADC_SQR1_DMAOFF;
    774            }
    775          }
    776          
    777          /**
    778            * @}
    779            */
    780          
    781          /** @defgroup ADC_Group6 Interrupts and flags management functions
    782           *  @brief   Interrupts and flags management functions
    783           *
    784          @verbatim   
    785           ===============================================================================
    786                             Interrupts and flags management functions
    787           ===============================================================================  
    788          
    789            This section provides functions allowing to configure the ADC Interrupts and 
    790            get the status and clear flags and Interrupts pending bits.
    791            
    792            The ADC provides 3 Interrupt sources and 3 Flags:
    793            
    794            Flags :
    795            ---------- 
    796               1. ADC_FLAG_OVR : Overrun detection when ADC channel converted data is lost
    797          
    798               2. ADC_FLAG_EOC : End of conversionï¿½- to indicate the end of a regular 
    799                            CHANNEL conversion or a GROUP conversions, depending of the 
    800                            ADC Continuous Conversion Mode (Continuous or Single 
    801                            conversion) and of the DMA usage.
    802                            Note : if DMA is used, EOC occurs at the end of the sequence 
    803                                   conversion, else it occurs after each conversion
    804               3. ADC_FLAG_AWD: to indicate if the converted voltage crosses the 
    805                          programmed Analog watchdog thresholds values.
    806          
    807               
    808            Interrupts :
    809            ------------
    810               1. ADC_IT_OVR : specifies the interrupt source for the Overrun detection event.
    811               2. ADC_IT_EOC : specifies the interrupt source for the End of conversion event.
    812               3. ADC_IT_AWD : specifies the interrupt source for the Analog watchdog event.
    813          
    814          @endverbatim
    815            * @{
    816            */ 
    817          
    818          /**
    819            * @brief  Enables or disables the specified ADC interrupts.
    820            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    821            * @param  ADC_IT : specifies the ADC interrupt sources to be enabled or 
    822            *         disabled. 
    823            *          This parameter can be one of the following values:
    824            *            @arg ADC_IT_EOC: End of Conversion Interrupt
    825            *            @arg ADC_IT_AWD: Analog Watchdog Interrupt
    826            *            @arg ADC_IT_OVER: Over Run Interrupt
    827            * @param  NewState : new state of the specified ADC interrupts.
    828              *         This parameter can be: ENABLE or DISABLE.
    829            * @retval None
    830            */
    831          void ADC_ITConfig(ADC_T* ADCx, ADC_IT_T ADC_IT, FunctionalState NewState)
    832          {
    833            /* Check the parameters */
    834            assert_param(IS_FUNCTIONAL_STATE(NewState));
    835            assert_param(IS_ADC_IT(ADC_IT));
    836          
    837            if (NewState != DISABLE)
    838            {
    839              /* Enable the selected ADC interrupts */
    840              ADCx->CR1 |= (uint8_t) ADC_IT;
    841            }
    842            else
    843            {
    844              /* Disable the selected ADC interrupts */
    845              ADCx->CR1 &= (uint8_t)(~ADC_IT);
    846            }
    847          }
    848          
    849          /**
    850            * @brief  Checks whether the specified ADC flag is set or not.
    851            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    852            * @param  ADC_FLAG: specifies the flag to check.
    853            *          This parameter can be one of the following values:
    854            *            @arg ADC_FLAG_EOC: End of Conversion flag
    855            *            @arg ADC_FLAG_AWD: Analog Watchdog flag
    856            *            @arg ADC_FLAG_OVER: Over Run flag    
    857            * @retval The new state of ADC_FLAG (SET or RESET).
    858            */
    859          FlagStatus ADC_GetFlagStatus(ADC_T* ADCx, ADC_FLAG_T ADC_FLAG)
    860          {
    861            FlagStatus flagstatus = RESET;
    862          
    863            /* Check the parameters */
    864            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
    865          
    866            /* Check the status of the specified ADC flag */
    867            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
    868            {
    869              /* ADC_FLAG is set */
    870              flagstatus = SET;
    871            }
    872            else
    873            {
    874              /* ADC_FLAG is reset */
    875              flagstatus = RESET;
    876            }
    877          
    878            /* Return the ADC_FLAG status */
    879            return  flagstatus;
    880          }
    881          
    882          /**
    883            * @brief  Clears the ADC's pending flags.
    884            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    885            * @param  ADC_FLAG: specifies the flag to clear.
    886            *          This parameter can be one of the following values:
    887            *            @arg ADC_FLAG_EOC: End of Conversion flag
    888            *            @arg ADC_FLAG_AWD: Analog Watchdog flag
    889            *            @arg ADC_FLAG_OVER: Over Run flag 
    890            * @retval None
    891            */
    892          void ADC_ClearFlag(ADC_T* ADCx,
    893                             ADC_FLAG_T ADC_FLAG)
    894          {
    895            /* Check the parameters */
    896            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
    897          
    898            /* Clear the selected ADC flags */
    899            ADCx->SR = (uint8_t)~ADC_FLAG;
    900          }
    901          
    902          /**
    903            * @brief  Checks whether the specified ADC interrupt has occurred or not.
    904            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    905            * @param  ADC_IT: specifies the ADC interrupt source to check.
    906            *          This parameter can be one of the following values:
    907            *            @arg ADC_IT_EOC: End of Conversion Interrupt
    908            *            @arg ADC_IT_AWD: Analog Watchdog Interrupt
    909            *            @arg ADC_IT_OVER: Over Run Interrupt
    910            * @retval Status of ADC_IT (SET or RESET).
    911            */
    912          ITStatus ADC_GetITStatus(ADC_T* ADCx,
    913                                   ADC_IT_T ADC_IT)
    914          {
    915            ITStatus itstatus = RESET;
    916            uint8_t itmask = 0, enablestatus = 0;
    917          
    918            /* Check the parameters */
    919            assert_param(IS_ADC_GET_IT(ADC_IT));
    920          
    921            /* Get the ADC IT index */
    922            itmask = (uint8_t)(ADC_IT >> 3);
    923            itmask =  (uint8_t)((uint8_t)((uint8_t)(itmask & (uint8_t)0x10) >> 2) | \
    924                                          (uint8_t)(itmask & (uint8_t)0x03));
    925          
    926            /* Get the ADC_IT enable bit status */
    927            enablestatus = (uint8_t)(ADCx->CR1 & (uint8_t)ADC_IT) ;
    928          
    929            /* Check the status of the specified ADC interrupt */
    930            if (((ADCx->SR & itmask) != (uint8_t)RESET) && enablestatus)
    931            {
    932              /* ADC_IT is set */
    933              itstatus = SET;
    934            }
    935            else
    936            {
    937              /* ADC_IT is reset */
    938              itstatus = RESET;
    939            }
    940          
    941            /* Return the ADC_IT status */
    942            return  itstatus;
    943          }
    944          
    945          /**
    946            * @brief  Clears the ADCï¿½s interrupt pending bits.
    947            * @param  ADCx where x can be 1 to select the specified ADC peripheral.
    948            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
    949            *          This parameter can be one of the following values:
    950            *            @arg ADC_IT_EOC: End of Conversion Interrupt
    951            *            @arg ADC_IT_AWD: Analog Watchdog Interrupt
    952            *            @arg ADC_IT_OVER: Over Run Interrupt
    953            * @retval None
    954            */
    955          void ADC_ClearITPendingBit(ADC_T* ADCx,
    956                                     ADC_IT_T ADC_IT)
    957          {
    958            uint8_t itmask = 0;
    959          
    960            /* Check the parameters */
    961            assert_param(IS_ADC_IT(ADC_IT));
    962          
    963            /* Get the ADC IT index */
    964            itmask = (uint8_t)(ADC_IT >> 3);
    965            itmask =  (uint8_t)((uint8_t)(((uint8_t)(itmask & (uint8_t)0x10)) >> 2) | \
    966                                           (uint8_t)(itmask & (uint8_t)0x03));
    967          
    968            /* Clear the selected ADC interrupt pending bits */
    969            ADCx->SR = (uint8_t)~itmask;
    970          }
    971          
    972          /**
    973            * @}
    974            */ 
    975          
    976          /**
    977            * @}
    978            */
    979          
    980          /**
    981            * @}
    982            */ 
    983          
    984          /**
    985            * @}
    986            */ 
    987          
    988          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      38  ?Subroutine0
      12  ?Subroutine1
      14  ADC_AnalogWatchdogChannelSelect
      15  ADC_AnalogWatchdogConfig
       4  ADC_AnalogWatchdogThresholdsConfig
      18  ADC_ChannelCmd
       6  ADC_ClearFlag
      23  ADC_ClearITPendingBit
      13  ADC_Cmd
      16  ADC_DMACmd
     126  ADC_DeInit
      14  ADC_ExternalTrigConfig
      29  ADC_GetConversionValue
      15  ADC_GetFlagStatus
      45  ADC_GetITStatus
      11  ADC_ITConfig
      22  ADC_Init
      28  ADC_SamplingTimeConfig
      18  ADC_SchmittTriggerConfig
       5  ADC_SoftwareStartConv
      13  ADC_TempSensorCmd
      13  ADC_VrefintCmd

 
 498 bytes in section .far_func.text
 
 498 bytes of CODE memory

Errors: none
Warnings: none
