###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:24
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim2.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim2.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_tim2.lst
#    Object file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_tim2.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim2.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim2.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM2 peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *              
     17            *  @verbatim
     18            *  
     19            *          ===================================================================
     20            *                                 How to use this driver
     21            *          ===================================================================
     22            *          This driver provides functions to configure and initialize the TIM2
     23            *          peripheral
     24            *          These functions are split in 7 groups: 
     25            *   
     26            *          1. TIM2 TimeBase management: this group includes all needed functions 
     27            *             to configure the TIM Timebase unit:
     28            *                   - Set/Get Prescaler
     29            *                   - Set/Get Autoreload  
     30            *                   - Counter modes configuration
     31            *                   - Select the One Pulse mode
     32            *                   - Update Request Configuration
     33            *                   - Update Disable Configuration
     34            *                   - Auto-Preload Configuration 
     35            *                   - Enable/Disable the counter
     36            *                 
     37            *          2. TIM2 Output Compare management: this group includes all needed 
     38            *             functions to configure the Capture/Compare unit used in Output 
     39            *             compare mode: 
     40            *                   - Configure each channel, independently, in Output Compare mode
     41            *                   - Select the output compare modes
     42            *                   - Select the Polarities of each channel
     43            *                   - Set/Get the Capture/Compare register values
     44            *                   - Select the Output Compare Fast mode 
     45            *                   - Select the Output Compare Forced mode  
     46            *                   - Output Compare-Preload Configuration 
     47            *                   - Enable/Disable the Capture/Compare Channels    
     48            *                   
     49            *          3. TIM2 Input Capture management: this group includes all needed 
     50            *             functions to configure the Capture/Compare unit used in 
     51            *             Input Capture mode:
     52            *                   - Configure each channel in input capture mode
     53            *                   - Configure Channel1/2 in PWM Input mode
     54            *                   - Set the Input Capture Prescaler
     55            *                   - Get the Capture/Compare values      
     56            *        
     57            *          4. TIM2 interrupts, DMA and flags management
     58            *                   - Enable/Disable interrupt sources
     59            *                   - Get flags status
     60            *                   - Clear flags/ Pending bits
     61            *                   - Enable/Disable DMA requests 
     62            *                   - Select CaptureCompare DMA request  
     63            *              
     64            *          5. TIM2 clocks management: this group includes all needed functions 
     65            *             to configure the clock controller unit:
     66            *                   - Select internal/External clock
     67            *                   - Select the external clock mode: ETR(Mode1/Mode2) or TIx
     68            *         
     69            *          6. TIM2 synchronization management: this group includes all needed 
     70            *             functions to configure the Synchronization unit:
     71            *                   - Select Input Trigger  
     72            *                   - Select Output Trigger  
     73            *                   - Select Master Slave Mode 
     74            *                   - ETR Configuration when used as external trigger   
     75            *     
     76            *          7. TIM2 specific interface management, this group includes all 
     77            *             needed functions to use the specific TIM2 interface:
     78            *                   - Encoder Interface Configuration
     79            *                   - Select Hall Sensor        
     80            *   
     81            *  @endverbatim
     82            *    
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     87            *
     88            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     89            * You may not use this file except in compliance with the License.
     90            * You may obtain a copy of the License at:
     91            *
     92            *        http://www.st.com/software_license_agreement_liberty_v2
     93            *
     94            * Unless required by applicable law or agreed to in writing, software 
     95            * distributed under the License is distributed on an "AS IS" BASIS, 
     96            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     97            * See the License for the specific language governing permissions and
     98            * limitations under the License.
     99            *
    100            ******************************************************************************
    101            */
    102          
    103          /* Includes ------------------------------------------------------------------*/
    104          #include "stm8l15x_TIM2.h"
    105          
    106          /** @addtogroup STM8L15x_StdPeriph_Driver
    107            * @{
    108            */
    109          
    110          /** @defgroup TIM2 
    111            * @brief TIM2 driver modules
    112            * @{
    113            */
    114            
    115          /* Private typedef -----------------------------------------------------------*/
    116          /* Private define ------------------------------------------------------------*/
    117          /* Private macro -------------------------------------------------------------*/
    118          /* Private variables ---------------------------------------------------------*/
    119          /* Private function prototypes -----------------------------------------------*/
    120          static void TI1_Config(TIM2_ICPolarity_T TIM2_ICPolarity,
    121                                 TIM2_ICSelection_T TIM2_ICSelection,
    122                                 uint8_t TIM2_ICFilter);
    123          static void TI2_Config(TIM2_ICPolarity_T TIM2_ICPolarity,
    124                                 TIM2_ICSelection_T TIM2_ICSelection,
    125                                 uint8_t TIM2_ICFilter);
    126          
    127          
    128          /** @defgroup TIM2_Private_Functions
    129            * @{
    130            */
    131          
    132          /** @defgroup TIM2_Group1 TimeBase management functions
    133           *  @brief   TimeBase management functions 
    134           *
    135          @verbatim   
    136           ===============================================================================
    137                                 TimeBase management functions
    138           ===============================================================================  
    139            
    140                 ===================================================================      
    141                        TIM2 Driver: how to use it in Timing(Time base) Mode
    142                 =================================================================== 
    143                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    144                 
    145                 1. Enable TIM2 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE) function.
    146                  
    147                 2. Call TIM2_TimeBaseInit() to configure the Time Base unit with the
    148                    corresponding configuration.
    149                    
    150                 3. Enable global interrupts if you need to generate the update interrupt.
    151                    
    152                 4. Enable the corresponding interrupt using the function TIM2_ITConfig(TIM2_IT_Update) 
    153                    
    154                 5. Call the TIM2_Cmd(ENABLE) function to enable the TIM2 counter.
    155                 
    156                 Note1: All other functions can be used separately to modify, if needed,
    157                    a specific feature of the Timer. 
    158          
    159          @endverbatim
    160            * @{
    161            */
    162          
    163          /**
    164            * @brief  Deinitialize the TIM2 peripheral registers to their default reset values.
    165            * @param  None
    166            * @retval None
    167            */
    168          void TIM2_DeInit(void)
    169          {
    170            TIM2->CR1 = TIM_CR1_RESET_VALUE;
    171            TIM2->CR2 = TIM_CR2_RESET_VALUE;
    172            TIM2->SMCR = TIM_SMCR_RESET_VALUE;
    173            TIM2->ETR = TIM_ETR_RESET_VALUE;
    174            TIM2->IER = TIM_IER_RESET_VALUE;
    175            TIM2->SR2 = TIM_SR2_RESET_VALUE;
    176          
    177            /* Disable channels */
    178            TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
    179            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
    180            TIM2->CCMR1 = 0x01;/*TIM2_ICxSource_TIxFPx */
    181            TIM2->CCMR2 = 0x01;/*TIM2_ICxSource_TIxFPx */
    182          
    183            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
    184            TIM2->CCER1 = TIM_CCER1_RESET_VALUE;
    185            TIM2->CCMR1 = TIM_CCMR1_RESET_VALUE;
    186            TIM2->CCMR2 = TIM_CCMR2_RESET_VALUE;
    187          
    188            TIM2->CNTRH = TIM_CNTRH_RESET_VALUE;
    189            TIM2->CNTRL = TIM_CNTRL_RESET_VALUE;
    190          
    191            TIM2->PSCR = TIM_PSCR_RESET_VALUE;
    192          
    193            TIM2->ARRH = TIM_ARRH_RESET_VALUE;
    194            TIM2->ARRL = TIM_ARRL_RESET_VALUE;
    195          
    196            TIM2->CCR1H = TIM_CCR1H_RESET_VALUE;
    197            TIM2->CCR1L = TIM_CCR1L_RESET_VALUE;
    198            TIM2->CCR2H = TIM_CCR2H_RESET_VALUE;
    199            TIM2->CCR2L = TIM_CCR2L_RESET_VALUE;
    200          
    201          
    202            TIM2->OISR = TIM_OISR_RESET_VALUE;
    203            TIM2->EGR = 0x01;/* TIM_EGR_UG */
    204            TIM2->BKR = TIM_BKR_RESET_VALUE;
    205            TIM2->SR1 = TIM_SR1_RESET_VALUE;
    206          }
    207          
    208          /**
    209            * @brief  Initializes the TIM2 Time Base Unit according to the specified  parameters.
    210            * @param  TIM2_Prescaler: Prescaler 
    211            *          This parameter can be one of the following values:
    212            *            @arg TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
    213            *            @arg TIM2_Prescaler_2: Time base Prescaler = 2
    214            *            @arg TIM2_Prescaler_4: Time base Prescaler = 4
    215            *            @arg TIM2_Prescaler_8: Time base Prescaler = 8
    216            *            @arg TIM2_Prescaler_16: Time base Prescaler = 16
    217            *            @arg TIM2_Prescaler_32: Time base Prescaler = 32
    218            *            @arg TIM2_Prescaler_64: Time base Prescaler = 64
    219            *            @arg TIM2_Prescaler_128: Time base Prescaler = 128                            
    220            * @param  TIM2_CounterMode: Counter mode
    221            *          This parameter can be one of the following values:
    222            *            @arg TIM2_CounterMode_Up: Counter Up Mode
    223            *            @arg TIM2_CounterMode_Down: Counter Down Mode
    224            *            @arg TIM2_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    225            *            @arg TIM2_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    226            *            @arg TIM2_CounterMode_CenterAligned3: Counter Central aligned Mode 3        
    227            * @param  TIM2_Period: This parameter must be a value between 0x0000 and 0xFFFF.
    228            * @retval None
    229            */
    230          
    231          void TIM2_TimeBaseInit(TIM2_Prescaler_T TIM2_Prescaler,
    232                                 TIM2_CounterMode_T TIM2_CounterMode,
    233                                 uint16_t TIM2_Period)
    234          {
    235          
    236            assert_param(IS_TIM2_PRESCALER(TIM2_Prescaler));
    237            assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
    238          
    239          
    240          
    241            /* Set the Autoreload value */
    242            TIM2->ARRH = (uint8_t)(TIM2_Period >> 8) ;
    243            TIM2->ARRL = (uint8_t)(TIM2_Period);
    244          
    245            /* Set the Prescaler value */
    246            TIM2->PSCR = (uint8_t)(TIM2_Prescaler);
    247          
    248            /* Select the Counter Mode */
    249            TIM2->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
    250            TIM2->CR1 |= (uint8_t)(TIM2_CounterMode);
    251          
    252            /* Generate an update event to reload the Prescaler value immediately */
    253            TIM2->EGR = TIM2_EventSource_Update;
    254          }
    255          
    256          /**
    257            * @brief  Configures the TIM2 Prescaler.
    258            * @param  Prescaler: Specifies the Prescaler Register value
    259            *          This parameter can be one of the following values:
    260            *            @arg TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
    261            *            @arg TIM2_Prescaler_2: Time base Prescaler = 2
    262            *            @arg TIM2_Prescaler_4: Time base Prescaler = 4
    263            *            @arg TIM2_Prescaler_8: Time base Prescaler = 8
    264            *            @arg TIM2_Prescaler_16: Time base Prescaler = 16
    265            *            @arg TIM2_Prescaler_32: Time base Prescaler = 32
    266            *            @arg TIM2_Prescaler_64: Time base Prescaler = 64
    267            *            @arg TIM2_Prescaler_128: Time base Prescaler = 128  
    268            * @param  TIM2_PSCReloadMode: Specifies the TIM2 Prescaler Reload mode.
    269            *          This parameter can be one of the following values:
    270            *            @arg TIM2_PSCReloadMode_Update: Prescaler value is reloaded at every update
    271            *            @arg TIM2_PSCReloadMode_Immediate: Prescaler value is reloaded at every update  
    272            * @retval None
    273            */
    274          void TIM2_PrescalerConfig(TIM2_Prescaler_T Prescaler,
    275                                    TIM2_PSCReloadMode_T TIM2_PSCReloadMode)
    276          {
    277            /* Check the parameters */
    278            assert_param(IS_TIM2_PRESCALER(Prescaler));
    279            assert_param(IS_TIM2_PRESCALER_RELOAD(TIM2_PSCReloadMode));
    280          
    281            /* Set the Prescaler value */
    282            TIM2->PSCR = (uint8_t)(Prescaler);
    283          
    284            /* Set or reset the UG Bit */
    285            if (TIM2_PSCReloadMode == TIM2_PSCReloadMode_Immediate)
    286            {
    287              TIM2->EGR |= TIM_EGR_UG ;
    288            }
    289            else
    290            {
    291              TIM2->EGR &= (uint8_t)(~TIM_EGR_UG) ;
    292            }
    293          }
    294          
    295          /**
    296            * @brief  Specifies the TIM2 Counter Mode to be used.
    297            * @param  TIM2_CounterMode: Specifies the Counter Mode to be used
    298            *          This parameter can be one of the following values:
    299            *            @arg TIM2_CounterMode_Up: Counter Up Mode
    300            *            @arg TIM2_CounterMode_Down: Counter Down Mode
    301            *            @arg TIM2_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    302            *            @arg TIM2_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    303            *            @arg TIM2_CounterMode_CenterAligned3: Counter Central aligned Mode 3      
    304            * @retval None
    305            */
    306          void TIM2_CounterModeConfig(TIM2_CounterMode_T TIM2_CounterMode)
    307          {
    308            uint8_t tmpcr1 = 0;
    309          
    310            /* Check the parameters */
    311            assert_param(IS_TIM2_COUNTER_MODE(TIM2_CounterMode));
    312          
    313            tmpcr1 = TIM2->CR1;
    314          
    315            /* Reset the CMS and DIR Bits */
    316            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
    317          
    318            /* Set the Counter Mode */
    319            tmpcr1 |= (uint8_t)TIM2_CounterMode;
    320          
    321            TIM2->CR1 = tmpcr1;
    322          }
    323          
    324          /**
    325            * @brief  Sets the TIM2 Counter Register value.
    326            * @param  Counter: Specifies the Counter register new value.
    327            *          This parameter is between 0x0000 and 0xFFFF.
    328            * @retval None
    329            */
    330          void TIM2_SetCounter(uint16_t Counter)
    331          {
    332          
    333            /* Set the Counter Register value */
    334            TIM2->CNTRH = (uint8_t)(Counter >> 8);
    335            TIM2->CNTRL = (uint8_t)(Counter);
    336          }
    337          
    338          /**
    339            * @brief  Sets the TIM2 Autoreload Register value.
    340            * @param  Autoreload: Specifies the Autoreload register new value.
    341            *          This parameter is between 0x0000 and 0xFFFF.
    342            * @retval None
    343            */
    344          void TIM2_SetAutoreload(uint16_t Autoreload)
    345          {
    346            /* Set the Autoreload Register value */
    347            TIM2->ARRH = (uint8_t)(Autoreload >> 8);
    348            TIM2->ARRL = (uint8_t)(Autoreload);
    349          }
    350          
    351          /**
    352            * @brief  Gets the TIM2 Counter value.
    353            * @param  None
    354            * @retval Counter Register value.
    355            */
    356          uint16_t TIM2_GetCounter(void)
    357          {
    358            uint16_t tmpcnt = 0;
    359            uint8_t tmpcntrl, tmpcntrh;
    360          
    361            tmpcntrh = TIM2->CNTRH;
    362            tmpcntrl = TIM2->CNTRL;
    363          
    364            tmpcnt = (uint16_t)(tmpcntrl);
    365            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
    366            /* Get the Counter Register value */
    367            return ((uint16_t)tmpcnt);
    368          }
    369          
    370          /**
    371            * @brief  Gets the TIM2 Prescaler value.
    372            * @param  None
    373            * @retval TIM2 Prescaler, it can be one of the following values:
    374            *            - TIM2_Prescaler_1: Time base Prescaler = 1 (No effect)
    375            *            - TIM2_Prescaler_2: Time base Prescaler = 2
    376            *            - TIM2_Prescaler_4: Time base Prescaler = 4
    377            *            - TIM2_Prescaler_8: Time base Prescaler = 8
    378            *            - TIM2_Prescaler_16: Time base Prescaler = 16
    379            *            - TIM2_Prescaler_32: Time base Prescaler = 32
    380            *            - TIM2_Prescaler_64: Time base Prescaler = 64
    381            *            - TIM2_Prescaler_128: Time base Prescaler = 128    
    382            */
    383          TIM2_Prescaler_T TIM2_GetPrescaler(void)
    384          {
    385            /* Get the Prescaler Register value */
    386            return ((TIM2_Prescaler_T)TIM2->PSCR);
    387          }
    388          
    389          /**
    390            * @brief  Enables or Disables the TIM2 Update event.
    391            * @param  NewState: The new state of the TIM2 peripheral Preload register.
    392            *          This parameter can be ENABLE or DISABLE
    393            * @retval None
    394            */
    395          
    396          void TIM2_UpdateDisableConfig(FunctionalState NewState)
    397          {
    398            /* Check the parameters */
    399            assert_param(IS_FUNCTIONAL_STATE(NewState));
    400          
    401            /* Set or Reset the UDIS Bit */
    402            if (NewState != DISABLE)
    403            {
    404              TIM2->CR1 |= TIM_CR1_UDIS;
    405            }
    406            else
    407            {
    408              TIM2->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
    409            }
    410          }
    411          
    412          /**
    413            * @brief  Selects the TIM2 Update Request Interrupt source.
    414            * @param  TIM2_UpdateSource: Specifies the Update source.
    415            *          This parameter can be one of the following values:
    416            *            @arg TIM2_UpdateSource_Global: Global Update request source
    417            *            @arg TIM2_UpdateSource_Regular: Regular Update request source 
    418            * @retval None
    419            */
    420          void TIM2_UpdateRequestConfig(TIM2_UpdateSource_T TIM2_UpdateSource)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_TIM2_UPDATE_SOURCE(TIM2_UpdateSource));
    424          
    425            /* Set or Reset the URS Bit */
    426            if (TIM2_UpdateSource == TIM2_UpdateSource_Regular)
    427            {
    428              TIM2->CR1 |= TIM_CR1_URS ;
    429            }
    430            else
    431            {
    432              TIM2->CR1 &= (uint8_t)(~TIM_CR1_URS);
    433            }
    434          }
    435          
    436          /**
    437            * @brief  Enables or disables TIM2 peripheral Preload register on ARR.
    438            * @param  NewState: The new state of the TIM2 peripheral Preload register.
    439            *          This parameter can be ENABLE or DISABLE
    440            * @retval None
    441            */
    442          void TIM2_ARRPreloadConfig(FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            /* Set or Reset the ARPE Bit */
    448            if (NewState != DISABLE)
    449            {
    450              TIM2->CR1 |= TIM_CR1_ARPE;
    451            }
    452            else
    453            {
    454              TIM2->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
    455            }
    456          }
    457          
    458          /**
    459            * @brief  Selects the TIM�s One Pulse Mode.
    460            * @param  TIM2_OPMode: Specifies the OPM Mode to be used.
    461            *          This parameter can be one of the following values:
    462            *            @arg TIM2_OPMode_Single: Single one Pulse mode (OPM Active)
    463            *            @arg TIM2_OPMode_Repetitive: Single one Pulse mode (OPM Active)  
    464            * @retval None
    465            */
    466          void TIM2_SelectOnePulseMode(TIM2_OPMode_T TIM2_OPMode)
    467          {
    468            /* Check the parameters */
    469            assert_param(IS_TIM2_OPM_MODE(TIM2_OPMode));
    470          
    471            /* Set or Reset the OPM Bit */
    472            if (TIM2_OPMode == TIM2_OPMode_Single)
    473            {
    474              TIM2->CR1 |= TIM_CR1_OPM ;
    475            }
    476            else
    477            {
    478              TIM2->CR1 &= (uint8_t)(~TIM_CR1_OPM);
    479            }
    480          }
    481          
    482          /**
    483            * @brief  Enables or disables the TIM2 peripheral.
    484            * @param  NewState: The new state of the TIM2 peripheral.
    485            *          This parameter can be ENABLE or DISABLE
    486            * @retval None
    487            */
    488          void TIM2_Cmd(FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_FUNCTIONAL_STATE(NewState));
    492          
    493            /* set or Reset the CEN Bit */
    494            if (NewState != DISABLE)
    495            {
    496              TIM2->CR1 |= TIM_CR1_CEN;
    497            }
    498            else
    499            {
    500              TIM2->CR1 &= (uint8_t)(~TIM_CR1_CEN);
    501            }
    502          }
    503          
    504          /**
    505            * @}
    506            */
    507          
    508          /** @defgroup TIM2_Group2 Output Compare management functions
    509           *  @brief    Output Compare management functions 
    510           *
    511          @verbatim   
    512           ===============================================================================
    513                                  Output Compare management functions
    514           ===============================================================================  
    515             
    516                 ===================================================================      
    517                        TIM2 Driver: how to use it in Output Compare Mode
    518                 =================================================================== 
    519                 To use the Timer in Output Compare mode, the following steps are mandatory:
    520                 
    521                 1. Enable TIM2 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE) function.
    522                 
    523                 2. Configure the TIM2 pins in output mode by configuring the corresponding GPIO pins
    524                    
    525                 3. Configure the Time base unit as described in the first part of this driver, if needed,
    526                    otherwise the Timer will run with the default configuration:
    527                    - Autoreload value = 0xFFFF
    528                    - Prescaler value = 0x0000
    529                    - Counter mode = Up counting
    530                
    531                 4. Call TIM2_OCxInit() to configure the channel x with the desired parameters
    532                    including:
    533                    - TIM2 Output Compare mode: TIM2_OCMode
    534                    - TIM2 Output State: TIM2_OutputState
    535                    - TIM2 Pulse value: TIM2_Pulse
    536                    - TIM2 Output Compare Polarity: TIM2_OCPolarity
    537                    - TIM2 Output Idle State: TIM2_OCIdleState
    538                 
    539                 5. Call the TIM2_Cmd(ENABLE) function to enable the TIM2 counter.
    540                 
    541                 Note1: All other functions can be used separately to modify, if needed,
    542                    a specific feature of the Timer. 
    543                 
    544                 Note2: If the corresponding interrupt or DMA request are needed, the user should:
    545                        1. Enable global interrupts (or the DMA) to use the TIM2 interrupts (or DMA requests). 
    546                        2. Enable the corresponding interrupt (or DMA request) using the function 
    547                        TIM2_ITConfig(TIM2_IT_CCx) (or TIM2_DMACmd(TIM2_DMASource_CCx))   
    548          
    549          @endverbatim
    550            * @{
    551            */
    552          
    553          /**
    554            * @brief  Initializes the TIM2 Channel1 according to the specified parameters.
    555            * @param  TIM2_OCMode: Output Compare Mode 
    556            *          This parameter can be one of the following values:
    557            *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
    558            *            @arg TIM2_OCMode_Active: Active Mode
    559            *            @arg TIM2_OCMode_Inactive: Inactive Mode
    560            *            @arg TIM2_OCMode_Toggle: Toggle Mode
    561            *            @arg TIM2_OCMode_PWM1: PWM Mode 1
    562            *            @arg TIM2_OCMode_PWM2: PWM Mode 2          
    563            * @param  TIM2_OutputState: Output state
    564            *          This parameter can be one of the following values:
    565            *            @arg TIM2_OutputState_Disable: Output compare State disabled (channel output disabled)
    566            *            @arg TIM2_OutputState_Enable: Output compare State enabled (channel output enabled)
    567            * @param  TIM2_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    568            * @param  TIM2_OCPolarity: Polarity
    569            *          This parameter can be one of the following values:
    570            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
    571            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
    572            * @param  TIM2_OCIdleState: Output Compare Idle State
    573            *          This parameter can be one of the following values:
    574            *            @arg TIM2_OCIdleState_Reset: Output Compare Idle state  = Reset
    575            *            @arg TIM2_OCIdleState_Set: Output Compare Idle state  = Set
    576            * @retval None
    577            */
    578          void TIM2_OC1Init(TIM2_OCMode_T TIM2_OCMode,
    579                            TIM2_OutputState_T TIM2_OutputState,
    580                            uint16_t TIM2_Pulse,
    581                            TIM2_OCPolarity_T TIM2_OCPolarity,
    582                            TIM2_OCIdleState_T TIM2_OCIdleState)
    583          {
    584            uint8_t tmpccmr1 = 0;
    585          
    586            /* Check the parameters */
    587            assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
    588            assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
    589            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
    590            assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
    591          
    592            tmpccmr1 = TIM2->CCMR1;
    593          
    594            /* Disable the Channel 1: Reset the CCE Bit */
    595            TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    596            /* Reset the Output Compare Bits */
    597            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    598          
    599            /* Set the Output Compare Mode */
    600            tmpccmr1 |= (uint8_t)TIM2_OCMode;
    601          
    602            TIM2->CCMR1 = tmpccmr1;
    603          
    604            /* Set the Output State */
    605            if (TIM2_OutputState == TIM2_OutputState_Enable)
    606            {
    607              TIM2->CCER1 |= TIM_CCER1_CC1E;
    608            }
    609            else
    610            {
    611              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    612            }
    613          
    614            /* Set the Output Polarity */
    615            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
    616            {
    617              TIM2->CCER1 |= TIM_CCER1_CC1P;
    618            }
    619            else
    620            {
    621              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
    622            }
    623          
    624            /* Set the Output Idle state */
    625            if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
    626            {
    627              TIM2->OISR |= TIM_OISR_OIS1;
    628            }
    629            else
    630            {
    631              TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS1);
    632            }
    633          
    634            /* Set the Pulse value */
    635            TIM2->CCR1H = (uint8_t)(TIM2_Pulse >> 8);
    636            TIM2->CCR1L = (uint8_t)(TIM2_Pulse);
    637          }
    638          
    639          /**
    640            * @brief  Initializes the TIM2 Channel2 according to the specified parameters.
    641            * @param  TIM2_OCMode: Output Compare Mode 
    642            *          This parameter can be one of the following values:
    643            *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
    644            *            @arg TIM2_OCMode_Active: Active Mode
    645            *            @arg TIM2_OCMode_Inactive: Inactive Mode
    646            *            @arg TIM2_OCMode_Toggle: Toggle Mode
    647            *            @arg TIM2_OCMode_PWM1: PWM Mode 1
    648            *            @arg TIM2_OCMode_PWM2: PWM Mode 2          
    649            * @param  TIM2_OutputState: Output state
    650            *          This parameter can be one of the following values:
    651            *            @arg TIM2_OutputState_Disable: Output compare State disabled (channel output disabled)
    652            *            @arg TIM2_OutputState_Enable: Output compare State enabled (channel output enabled)
    653            * @param  TIM2_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    654            * @param  TIM2_OCPolarity: Polarity
    655            *          This parameter can be one of the following values:
    656            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
    657            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
    658            * @param  TIM2_OCIdleState: Output Compare Idle State
    659            *          This parameter can be one of the following values:
    660            *            @arg TIM2_OCIdleState_Reset: Output Compare Idle state  = Reset
    661            *            @arg TIM2_OCIdleState_Set: Output Compare Idle state  = Set
    662            * @retval None
    663            */
    664          void TIM2_OC2Init(TIM2_OCMode_T TIM2_OCMode,
    665                            TIM2_OutputState_T TIM2_OutputState,
    666                            uint16_t TIM2_Pulse,
    667                            TIM2_OCPolarity_T TIM2_OCPolarity,
    668                            TIM2_OCIdleState_T TIM2_OCIdleState)
    669          {
    670            uint8_t tmpccmr2 = 0;
    671          
    672            /* Check the parameters */
    673            assert_param(IS_TIM2_OC_MODE(TIM2_OCMode));
    674            assert_param(IS_TIM2_OUTPUT_STATE(TIM2_OutputState));
    675            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
    676            assert_param(IS_TIM2_OCIDLE_STATE(TIM2_OCIdleState));
    677          
    678            tmpccmr2 = TIM2->CCMR2;
    679          
    680            /* Disable the Channel 2: Reset the CCE Bit */
    681            TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    682          
    683            /* Reset the Output Compare Bits */
    684            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    685          
    686            /* Set the Output Compare Mode */
    687            tmpccmr2 |= (uint8_t)TIM2_OCMode;
    688          
    689            TIM2->CCMR2 = tmpccmr2;
    690          
    691            /* Set the Output State */
    692            if (TIM2_OutputState == TIM2_OutputState_Enable)
    693            {
    694              TIM2->CCER1 |= TIM_CCER1_CC2E;
    695            }
    696            else
    697            {
    698              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    699            }
    700          
    701            /* Set the Output Polarity */
    702            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
    703            {
    704              TIM2->CCER1 |= TIM_CCER1_CC2P;
    705            }
    706            else
    707            {
    708              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
    709            }
    710          
    711          
    712            /* Set the Output Idle state */
    713            if (TIM2_OCIdleState == TIM2_OCIdleState_Set)
    714            {
    715              TIM2->OISR |= TIM_OISR_OIS2;
    716            }
    717            else
    718            {
    719              TIM2->OISR &= (uint8_t)(~TIM_OISR_OIS2);
    720            }
    721          
    722            /* Set the Pulse value */
    723            TIM2->CCR2H = (uint8_t)(TIM2_Pulse >> 8);
    724            TIM2->CCR2L = (uint8_t)(TIM2_Pulse);
    725          }
    726          
    727          /**
    728            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    729            *         and the AOE(automatic output enable).
    730            * @param  TIM2_OSSIState: Off-State Selection for Idle mode states.
    731            *          This parameter can be one of the following values:
    732            *            @arg TIM2_OSSIState_Enable: Off-State Selection for Idle mode enabled
    733            *            @arg TIM2_OSSIState_Disable: Off-State Selection for Idle mode disabled 
    734            * @param  TIM2_LockLevel: Lock level.
    735            *          This parameter can be one of the following values:
    736            *            @arg TIM2_LockLevel_Off: Lock option disabled
    737            *            @arg TIM2_LockLevel_1: Select Lock Level 1
    738            *            @arg TIM2_LockLevel_2: Select Lock Level 2
    739            *            @arg TIM2_LockLevel_3: Select Lock Level 3    
    740            * @param  TIM2_BreakState: Break Input enable/disable .
    741            *          This parameter can be one of the following values:
    742            *            @arg TIM2_BreakState_Disable: Break State disabled (break option disabled)
    743            *            @arg TIM2_BreakState_Enable: Break State enabled (break option enabled) 
    744            * @param  TIM2_BreakPolarity: Break Polarity.
    745            *          This parameter can be one of the following values:
    746            *            @arg TIM2_BreakPolarity_High: if Break, channel polarity = High
    747            *            @arg TIM2_BreakPolarity_Low: if Break, channel polarity = Low   
    748            * @param  TIM2_AutomaticOutput: TIM2 AOE Bit Set/Reset .
    749            *          This parameter can be one of the following values:
    750            *            @arg TIM2_AutomaticOutput_Enable: Automatic Output option enabled
    751            *            @arg TIM2_AutomaticOutput_Disable: Automatic Output option disabled
    752            * @retval None
    753            */
    754          void TIM2_BKRConfig(TIM2_OSSIState_T TIM2_OSSIState,
    755                              TIM2_LockLevel_T TIM2_LockLevel,
    756                              TIM2_BreakState_T TIM2_BreakState,
    757                              TIM2_BreakPolarity_T TIM2_BreakPolarity,
    758                              TIM2_AutomaticOutput_T TIM2_AutomaticOutput)
    759          
    760          {
    761            /* Check the parameters */
    762            assert_param(IS_TIM2_OSSI_STATE(TIM2_OSSIState));
    763            assert_param(IS_TIM2_LOCK_LEVEL(TIM2_LockLevel));
    764            assert_param(IS_TIM2_BREAK_STATE(TIM2_BreakState));
    765            assert_param(IS_TIM2_BREAK_POLARITY(TIM2_BreakPolarity));
    766            assert_param(IS_TIM2_AUTOMATIC_OUTPUT_STATE(TIM2_AutomaticOutput));
    767          
    768          
    769          
    770            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    771            the dead time value and the Automatic Output Enable Bit */
    772            TIM2->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM2_OSSIState | (uint8_t)TIM2_LockLevel) | \
    773                                            (uint8_t)((uint8_t)TIM2_BreakState | (uint8_t)TIM2_BreakPolarity)) | \
    774                                            TIM2_AutomaticOutput));
    775          }
    776          
    777          /**
    778            * @brief  Enables or disables the TIM2 peripheral Main Outputs.
    779            * @param  NewState: The new state of the TIM2 peripheral.
    780            *          This parameter can be ENABLE or DISABLE
    781            * @retval None
    782            */
    783          void TIM2_CtrlPWMOutputs(FunctionalState NewState)
    784          {
    785            /* Check the parameters */
    786            assert_param(IS_FUNCTIONAL_STATE(NewState));
    787          
    788            /* Set or Reset the MOE Bit */
    789          
    790            if (NewState != DISABLE)
    791            {
    792              TIM2->BKR |= TIM_BKR_MOE ;
    793            }
    794            else
    795            {
    796              TIM2->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
    797            }
    798          }
    799          
    800          /**
    801            * @brief  Selects the TIM2 Output Compare Mode. This function disables the
    802            *         selected channel before changing the Output Compare Mode. User has to
    803            *         enable this channel using TIM2_CCxCmd and TIM2_CCxNCmd functions.
    804            * @param  TIM2_Channel: Specifies the TIM2 Channel.
    805            *          This parameter can be one of the following values:
    806            *            @arg TIM2_Channel_1: Channel 1
    807            *            @arg TIM2_Channel_2: Channel 2  
    808            * @param  TIM2_OCMode: Specifies the TIM2 Output Compare Mode.
    809            *          This parameter can be one of the following values:
    810            *            @arg TIM2_OCMode_Timing: Timing (Frozen) Mode
    811            *            @arg TIM2_OCMode_Active: Active Mode
    812            *            @arg TIM2_OCMode_Inactive: Inactive Mode
    813            *            @arg TIM2_OCMode_Toggle: Toggle Mode
    814            *            @arg TIM2_OCMode_PWM1: PWM Mode 1
    815            *            @arg TIM2_OCMode_PWM2: PWM Mode 2    
    816            * @retval None
    817            */
    818          void TIM2_SelectOCxM(TIM2_Channel_T TIM2_Channel,
    819                               TIM2_OCMode_T TIM2_OCMode)
    820          {
    821            /* Check the parameters */
    822            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
    823            assert_param(IS_TIM2_OCM(TIM2_OCMode));
    824          
    825            if (TIM2_Channel == TIM2_Channel_1)
    826            {
    827              /* Disable the Channel 1: Reset the CCE Bit */
    828              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    829          
    830              /* Reset the Output Compare Bits */
    831              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
    832          
    833              /* Set the Output Compare Mode */
    834              TIM2->CCMR1 |= (uint8_t)TIM2_OCMode;
    835            }
    836            else /* if (TIM2_Channel == TIM2_Channel_2) */
    837            {
    838              /* Disable the Channel 2: Reset the CCE Bit */
    839              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    840          
    841              /* Reset the Output Compare Bits */
    842              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
    843          
    844              /* Set the Output Compare Mode */
    845              TIM2->CCMR2 |= (uint8_t)TIM2_OCMode;
    846            }
    847          }
    848          
    849          /**
    850            * @brief  Sets the TIM2 Capture Compare1 Register value.
    851            * @param  Compare: Specifies the Capture Compare1 register new value.
    852            *         This parameter is between 0x0000 and 0xFFFF.
    853            * @retval None
    854            */
    855          void TIM2_SetCompare1(uint16_t Compare)
    856          {
    857            /* Set the Capture Compare1 Register value */
    858            TIM2->CCR1H = (uint8_t)(Compare >> 8);
    859            TIM2->CCR1L = (uint8_t)(Compare);
    860          }
    861          
    862          /**
    863            * @brief  Sets the TIM2 Capture Compare2 Register value.
    864            * @param  Compare: Specifies the Capture Compare2 register new value.
    865            *         This parameter is between 0x0000 and 0xFFFF.
    866            * @retval None
    867            */
    868          void TIM2_SetCompare2(uint16_t Compare)
    869          {
    870            /* Set the Capture Compare2 Register value */
    871            TIM2->CCR2H = (uint8_t)(Compare >> 8);
    872            TIM2->CCR2L = (uint8_t)(Compare);
    873          }
    874          
    875          /**
    876            * @brief  Forces the TIM2 Channel1 output waveform to active or inactive level.
    877            * @param  TIM2_ForcedAction: Specifies the forced Action to be set to the output waveform.
    878            *          This parameter can be one of the following values:
    879            *            @arg TIM2_ForcedAction_Active: Output Reference is forced low 
    880            *            @arg TIM2_ForcedAction_Inactive: Output Reference is forced high 
    881            * @retval None
    882            */
    883          void TIM2_ForcedOC1Config(TIM2_ForcedAction_T TIM2_ForcedAction)
    884          {
    885            uint8_t tmpccmr1 = 0;
    886          
    887            /* Check the parameters */
    888            assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
    889          
    890            tmpccmr1 = TIM2->CCMR1;
    891          
    892            /* Reset the OCM Bits */
    893            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    894          
    895            /* Configure The Forced output Mode */
    896            tmpccmr1 |= (uint8_t)TIM2_ForcedAction;
    897          
    898            TIM2->CCMR1 = tmpccmr1;
    899          }
    900          
    901          /**
    902            * @brief  Forces the TIM2 Channel2 output waveform to active or inactive level.
    903            * @param  TIM2_ForcedAction: Specifies the forced Action to be set to the output waveform.
    904            *          This parameter can be one of the following values:
    905            *            @arg TIM2_ForcedAction_Active: Output Reference is forced low 
    906            *            @arg TIM2_ForcedAction_Inactive: Output Reference is forced high 
    907            * @retval None
    908            */
    909          void TIM2_ForcedOC2Config(TIM2_ForcedAction_T TIM2_ForcedAction)
    910          {
    911            uint8_t tmpccmr2 = 0;
    912          
    913            /* Check the parameters */
    914            assert_param(IS_TIM2_FORCED_ACTION(TIM2_ForcedAction));
    915          
    916            tmpccmr2 = TIM2->CCMR2;
    917          
    918            /* Reset the OCM Bits */
    919            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    920          
    921            /* Configure The Forced output Mode */
    922            tmpccmr2 |= (uint8_t)TIM2_ForcedAction;
    923          
    924            TIM2->CCMR2 = tmpccmr2;
    925          }
    926          
    927          /**
    928            * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR1.
    929            * @param  NewState: The new state of the Capture Compare Preload register.
    930            *          This parameter can be ENABLE or DISABLE
    931            * @retval None
    932            */
    933          void TIM2_OC1PreloadConfig(FunctionalState NewState)
    934          {
    935            /* Check the parameters */
    936            assert_param(IS_FUNCTIONAL_STATE(NewState));
    937          
    938            /* Set or Reset the OC1PE Bit */
    939            if (NewState != DISABLE)
    940            {
    941              TIM2->CCMR1 |= TIM_CCMR_OCxPE ;
    942            }
    943            else
    944            {
    945              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
    946            }
    947          }
    948          
    949          /**
    950            * @brief  Enables or disables the TIM2 peripheral Preload Register on CCR2.
    951            * @param  NewState: The new state of the Capture Compare Preload register.
    952            *          This parameter can be ENABLE or DISABLE
    953            * @retval None
    954            */
    955          void TIM2_OC2PreloadConfig(FunctionalState NewState)
    956          {
    957            /* Check the parameters */
    958            assert_param(IS_FUNCTIONAL_STATE(NewState));
    959          
    960            /* Set or Reset the OC2PE Bit */
    961            if (NewState != DISABLE)
    962            {
    963              TIM2->CCMR2 |= TIM_CCMR_OCxPE ;
    964            }
    965            else
    966            {
    967              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
    968            }
    969          }
    970          
    971          /**
    972            * @brief  Configures the TIM2 Capture Compare 1 Fast feature.
    973            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    974            *          This parameter can be ENABLE or DISABLE
    975            * @retval None
    976            */
    977          void TIM2_OC1FastConfig(FunctionalState NewState)
    978          {
    979            /* Check the parameters */
    980            assert_param(IS_FUNCTIONAL_STATE(NewState));
    981          
    982            /* Set or Reset the OC1FE Bit */
    983            if (NewState != DISABLE)
    984            {
    985              TIM2->CCMR1 |= TIM_CCMR_OCxFE ;
    986            }
    987            else
    988            {
    989              TIM2->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
    990            }
    991          }
    992          
    993          /**
    994            * @brief  Configures the TIM2 Capture Compare 2 Fast feature.
    995            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    996            *          This parameter can be ENABLE or DISABLE
    997            * @retval None
    998            */
    999          
   1000          void TIM2_OC2FastConfig(FunctionalState NewState)
   1001          {
   1002            /* Check the parameters */
   1003            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1004          
   1005            /* Set or Reset the OC2FE Bit */
   1006            if (NewState != DISABLE)
   1007            {
   1008              TIM2->CCMR2 |= TIM_CCMR_OCxFE ;
   1009            }
   1010            else
   1011            {
   1012              TIM2->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   1013            }
   1014          }
   1015          
   1016          /**
   1017            * @brief  Configures the TIM2 Channel 1 polarity.
   1018            * @param  TIM2_OCPolarity: Specifies the OC1 Polarity.
   1019            *          This parameter can be one of the following values:
   1020            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
   1021            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
   1022            * @retval None
   1023            */
   1024          void TIM2_OC1PolarityConfig(TIM2_OCPolarity_T TIM2_OCPolarity)
   1025          {
   1026            /* Check the parameters */
   1027            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
   1028          
   1029            /* Set or Reset the CC1P Bit */
   1030            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   1031            {
   1032              TIM2->CCER1 |= TIM_CCER1_CC1P ;
   1033            }
   1034            else
   1035            {
   1036              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   1037            }
   1038          }
   1039          
   1040          /**
   1041            * @brief  Configures the TIM2 Channel 2 polarity.
   1042            * @param  TIM2_OCPolarity: Specifies the OC2 Polarity.
   1043            *          This parameter can be one of the following values:
   1044            *            @arg TIM2_OCPolarity_High: Output compare polarity  = High
   1045            *            @arg TIM2_OCPolarity_Low: Output compare polarity  = Low 
   1046            * @retval None
   1047            */
   1048          void TIM2_OC2PolarityConfig(TIM2_OCPolarity_T TIM2_OCPolarity)
   1049          {
   1050            /* Check the parameters */
   1051            assert_param(IS_TIM2_OC_POLARITY(TIM2_OCPolarity));
   1052          
   1053            /* Set or Reset the CC2P Bit */
   1054            if (TIM2_OCPolarity == TIM2_OCPolarity_Low)
   1055            {
   1056              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   1057            }
   1058            else
   1059            {
   1060              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   1061            }
   1062          }
   1063          
   1064          /**
   1065            * @brief  Enables or disables the TIM2 Capture Compare Channel x.
   1066            * @param  TIM2_Channel: Specifies the TIM2 Channel.
   1067            *          This parameter can be one of the following values:
   1068            *            @arg TIM2_Channel_1: Channel 1
   1069            *            @arg TIM2_Channel_2: Channel 2  
   1070            * @param  NewState: Specifies the TIM2 Channel CCxE bit new state.
   1071            *          This parameter can be ENABLE or DISABLE
   1072            * @retval None
   1073            */
   1074          void TIM2_CCxCmd(TIM2_Channel_T TIM2_Channel,
   1075                           FunctionalState NewState)
   1076          {
   1077            /* Check the parameters */
   1078            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1079            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1080          
   1081            if (TIM2_Channel == TIM2_Channel_1)
   1082            {
   1083              /* Set or Reset the CC1E Bit */
   1084              if (NewState != DISABLE)
   1085              {
   1086                TIM2->CCER1 |= TIM_CCER1_CC1E ;
   1087              }
   1088              else
   1089              {
   1090                TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   1091              }
   1092          
   1093            }
   1094            else /* if (TIM2_Channel == TIM2_Channel_2) */
   1095            {
   1096              /* Set or Reset the CC2E Bit */
   1097              if (NewState != DISABLE)
   1098              {
   1099                TIM2->CCER1 |= TIM_CCER1_CC2E;
   1100              }
   1101              else
   1102              {
   1103                TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   1104              }
   1105            }
   1106          }
   1107          
   1108          /** @defgroup TIM2_Group3 Input Capture management functions
   1109           *  @brief    Input Capture management functions 
   1110           *
   1111          @verbatim   
   1112           ===============================================================================
   1113                                Input Capture management functions
   1114           ===============================================================================  
   1115             
   1116                 ===================================================================      
   1117                        TIM2 Driver: how to use it in Input Capture Mode
   1118                 =================================================================== 
   1119                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1120                 
   1121                 1. Enable TIM2 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM2, ENABLE) function.
   1122                 
   1123                 2. Configure the TIM2 pins in input mode by configuring the corresponding GPIO pins
   1124                 
   1125                 3. Configure the Time base unit as described in the first part of this driver, if needed,
   1126                    otherwise the Timer will run with the default configuration:
   1127                    - Autoreload value = 0xFFFF
   1128                    - Prescaler value = 0x0
   1129                    - Counter mode = Up counting
   1130                 
   1131                 4. Call TIM2_ICInit() to configure the desired channel to measure only 
   1132                    frequency or duty cycle of the input signal using the corresponding configuration: 
   1133                    - TIM2 Channel: TIM2_Channel
   1134                    - TIM2 Input Capture polarity: TIM2_ICPolarity
   1135                    - TIM2 Input Capture selection: TIM2_ICSelection
   1136                    - TIM2 Input Capture Prescaler: TIM2_ICPSC
   1137                    - TIM2 Input Capture filter value
   1138                    or,
   1139                    Call TIM2_PWMIConfig() to configure the desired channels with the 
   1140                    corresponding configuration and to measure the frequency and the duty
   1141                    cycle of the input signal.
   1142                    
   1143                 5. Enable global interrupts or the DMA to read the measured frequency. 
   1144                    
   1145                 6. Enable the corresponding interrupt (or DMA request) to read the captured value,
   1146                    using the function TIM2_ITConfig(TIM2_IT_CCx) (or TIM2_DMACmd(TIM2_DMASource_CCx))
   1147                 
   1148                 7. Call the TIM2_Cmd(ENABLE) function to enable the TIM2 counter.
   1149                 
   1150                 8. Use TIM2_GetCapturex() to read the captured value corresponding to
   1151                    channel x.
   1152                 
   1153                 Note1: All other functions can be used separately to modify, if needed,
   1154                    a specific feature of the Timer. 
   1155          
   1156          @endverbatim
   1157            * @{
   1158            */
   1159          
   1160          /**
   1161            * @brief  Initializes the TIM2 peripheral according to the specified parameters.
   1162            * @param  TIM2_Channel: TIM2 Channel
   1163            *          This parameter can be one of the following values:
   1164            *            @arg TIM2_Channel_1: Channel 1
   1165            *            @arg TIM2_Channel_2: Channel 2     
   1166            * @param  TIM2_ICPolarity: Input Capture Polarity
   1167            *          This parameter can be one of the following values:
   1168            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1169            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1170            * @param  TIM2_ICSelection: Input Capture Selection
   1171            *          This parameter can be one of the following values:
   1172            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   1173            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1174            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1175            * @param  TIM2_ICPrescaler: Input Capture Prescaler
   1176            *          This parameter can be one of the following values:
   1177            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1178            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1179            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1180            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1181            * @param  TIM2_ICFilter: This parameter must be a value between 0x00 and 0x0F.
   1182            * @retval None
   1183            */
   1184          void TIM2_ICInit(TIM2_Channel_T TIM2_Channel,
   1185                           TIM2_ICPolarity_T TIM2_ICPolarity,
   1186                           TIM2_ICSelection_T TIM2_ICSelection,
   1187                           TIM2_ICPSC_T TIM2_ICPrescaler,
   1188                           uint8_t TIM2_ICFilter)
   1189          {
   1190            /* Check the parameters */
   1191            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1192          
   1193            if (TIM2_Channel == TIM2_Channel_1)
   1194            {
   1195              /* TI1 Configuration */
   1196              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection, TIM2_ICFilter);
   1197          
   1198              /* Set the Input Capture Prescaler value */
   1199              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   1200            }
   1201            else /* if (TIM2_Channel == TIM2_Channel_2) */
   1202            {
   1203              /* TI2 Configuration */
   1204              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection, TIM2_ICFilter);
   1205          
   1206              /* Set the Input Capture Prescaler value */
   1207              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   1208            }
   1209          }
   1210          
   1211          /**
   1212            * @brief  Configures the TIM2 peripheral in PWM Input Mode according to the
   1213            *         specified parameters.
   1214            * @param  TIM2_Channel: TIM2 Channel
   1215            *          This parameter can be one of the following values:
   1216            *            @arg TIM2_Channel_1: Channel 1
   1217            *            @arg TIM2_Channel_2: Channel 2     
   1218            * @param  TIM2_ICPolarity: Input Capture Polarity
   1219            *          This parameter can be one of the following values:
   1220            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1221            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1222            * @param  TIM2_ICSelection: Input Capture Selection
   1223            *          This parameter can be one of the following values:
   1224            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   1225            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1226            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1227            * @param  TIM2_ICPrescaler: Input Capture Prescaler
   1228            *          This parameter can be one of the following values:
   1229            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1230            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1231            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1232            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1233            * @retval None
   1234            */
   1235          void TIM2_PWMIConfig(TIM2_Channel_T TIM2_Channel,
   1236                               TIM2_ICPolarity_T TIM2_ICPolarity,
   1237                               TIM2_ICSelection_T TIM2_ICSelection,
   1238                               TIM2_ICPSC_T TIM2_ICPrescaler,
   1239                               uint8_t TIM2_ICFilter)
   1240          {
   1241            uint8_t icpolarity = TIM2_ICPolarity_Rising;
   1242            uint8_t icselection = TIM2_ICSelection_DirectTI;
   1243          
   1244            /* Check the parameters */
   1245            assert_param(IS_TIM2_CHANNEL(TIM2_Channel));
   1246          
   1247            /* Select the Opposite Input Polarity */
   1248            if (TIM2_ICPolarity == TIM2_ICPolarity_Rising)
   1249            {
   1250              icpolarity = TIM2_ICPolarity_Falling;
   1251            }
   1252            else
   1253            {
   1254              icpolarity = TIM2_ICPolarity_Rising;
   1255            }
   1256          
   1257            /* Select the Opposite Input */
   1258            if (TIM2_ICSelection == TIM2_ICSelection_DirectTI)
   1259            {
   1260              icselection = TIM2_ICSelection_IndirectTI;
   1261            }
   1262            else
   1263            {
   1264              icselection = TIM2_ICSelection_DirectTI;
   1265            }
   1266          
   1267            if (TIM2_Channel == TIM2_Channel_1)
   1268            {
   1269              /* TI1 Configuration */
   1270              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection,
   1271                         TIM2_ICFilter);
   1272          
   1273              /* Set the Input Capture Prescaler value */
   1274              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   1275          
   1276              /* TI2 Configuration */
   1277              TI2_Config((TIM2_ICPolarity_T)icpolarity, (TIM2_ICSelection_T)icselection, TIM2_ICFilter);
   1278          
   1279              /* Set the Input Capture Prescaler value */
   1280              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   1281            }
   1282            else
   1283            {
   1284              /* TI2 Configuration */
   1285              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection,
   1286                         TIM2_ICFilter);
   1287          
   1288              /* Set the Input Capture Prescaler value */
   1289              TIM2_SetIC2Prescaler(TIM2_ICPrescaler);
   1290          
   1291              /* TI1 Configuration */
   1292              TI1_Config((TIM2_ICPolarity_T)icpolarity, (TIM2_ICSelection_T)icselection, TIM2_ICFilter);
   1293          
   1294              /* Set the Input Capture Prescaler value */
   1295              TIM2_SetIC1Prescaler(TIM2_ICPrescaler);
   1296            }
   1297          }
   1298          
   1299          /**
   1300            * @brief  Gets the TIM2 Input Capture 1 value.
   1301            * @param  None
   1302            * @retval Capture Compare 1 Register value.
   1303            */
   1304          uint16_t TIM2_GetCapture1(void)
   1305          {
   1306            uint16_t tmpccr1 = 0;
   1307            uint8_t tmpccr1l, tmpccr1h;
   1308          
   1309            tmpccr1h = TIM2->CCR1H;
   1310            tmpccr1l = TIM2->CCR1L;
   1311          
   1312            tmpccr1 = (uint16_t)(tmpccr1l);
   1313            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   1314            /* Get the Capture 1 Register value */
   1315            return ((uint16_t)tmpccr1);
   1316          }
   1317          
   1318          /**
   1319            * @brief  Gets the TIM2 Input Capture 2 value.
   1320            * @param  None
   1321            * @retval Capture Compare 2 Register value.
   1322            */
   1323          uint16_t TIM2_GetCapture2(void)
   1324          {
   1325            uint16_t tmpccr2 = 0;
   1326            uint8_t tmpccr2l, tmpccr2h;
   1327          
   1328            tmpccr2h = TIM2->CCR2H;
   1329            tmpccr2l = TIM2->CCR2L;
   1330          
   1331            tmpccr2 = (uint16_t)(tmpccr2l);
   1332            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   1333            /* Get the Capture 2 Register value */
   1334            return ((uint16_t)tmpccr2);
   1335          }
   1336          
   1337          /**
   1338            * @brief  Sets the TIM2 Input Capture 1 prescaler.
   1339            * @param  TIM2_IC1Prescaler: Specifies the Input Capture prescaler new value
   1340            *          This parameter can be one of the following values:
   1341            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1342            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1343            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1344            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1345            * @retval None
   1346            */
   1347          void TIM2_SetIC1Prescaler(TIM2_ICPSC_T TIM2_IC1Prescaler)
   1348          {
   1349            uint8_t tmpccmr1 = 0;
   1350          
   1351            /* Check the parameters */
   1352            assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC1Prescaler));
   1353          
   1354            tmpccmr1 = TIM2->CCMR1;
   1355          
   1356            /* Reset the IC1PSC Bits */
   1357            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1358          
   1359            /* Set the IC1PSC value */
   1360            tmpccmr1 |= (uint8_t)TIM2_IC1Prescaler;
   1361          
   1362            TIM2->CCMR1 = tmpccmr1;
   1363          }
   1364          
   1365          /**
   1366            * @brief  Sets the TIM2 Input Capture 2 prescaler.
   1367            * @param  TIM2_IC2Prescaler: Specifies the Input Capture prescaler new value
   1368            *          This parameter can be one of the following values:
   1369            *            @arg TIM2_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1370            *            @arg TIM2_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1371            *            @arg TIM2_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1372            *            @arg TIM2_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1373            * @retval None
   1374            */
   1375          void TIM2_SetIC2Prescaler(TIM2_ICPSC_T TIM2_IC2Prescaler)
   1376          {
   1377            uint8_t tmpccmr2 = 0;
   1378          
   1379            /* Check the parameters */
   1380            assert_param(IS_TIM2_IC_PRESCALER(TIM2_IC2Prescaler));
   1381          
   1382            tmpccmr2 = TIM2->CCMR2;
   1383          
   1384            /* Reset the IC2PSC Bits */
   1385            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1386          
   1387            /* Set the IC2PSC value */
   1388            tmpccmr2 |= (uint8_t)TIM2_IC2Prescaler;
   1389          
   1390            TIM2->CCMR2 = tmpccmr2;
   1391          }
   1392          
   1393          /**
   1394            * @}
   1395            */
   1396          
   1397          /** @defgroup TIM2_Group4 Interrupts DMA and flags management functions
   1398           *  @brief    Interrupts, DMA and flags management functions 
   1399           *
   1400          @verbatim   
   1401           ===============================================================================
   1402                           Interrupts, DMA and flags management functions
   1403           ===============================================================================  
   1404          
   1405          @endverbatim
   1406            * @{
   1407            */
   1408          
   1409          /**
   1410            * @brief  Enables or disables the specified TIM2 interrupts.
   1411            * @param  TIM2_IT: Specifies the TIM2 interrupts sources to be enabled or disabled.
   1412            *          This parameter can be any combination of the following values:
   1413            *            @arg TIM2_IT_Update: Update
   1414            *            @arg TIM2_IT_CC1: Capture Compare Channel1
   1415            *            @arg TIM2_IT_CC2: Capture Compare Channel2 
   1416            *            @arg TIM2_IT_Trigger: Trigger 
   1417            *            @arg TIM2_IT_Break: Break  
   1418            * @param  NewState: The new state of the TIM2 peripheral.
   1419            *          This parameter can be ENABLE or DISABLE
   1420            * @retval None
   1421            */
   1422          void TIM2_ITConfig(TIM2_IT_T TIM2_IT, FunctionalState NewState)
   1423          {
   1424            /* Check the parameters */
   1425            assert_param(IS_TIM2_IT(TIM2_IT));
   1426            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1427          
   1428            if (NewState != DISABLE)
   1429            {
   1430              /* Enable the Interrupt sources */
   1431              TIM2->IER |= (uint8_t)TIM2_IT;
   1432            }
   1433            else
   1434            {
   1435              /* Disable the Interrupt sources */
   1436              TIM2->IER &= (uint8_t)(~(uint8_t)TIM2_IT);
   1437            }
   1438          }
   1439          
   1440          /**
   1441            * @brief  Configures the TIM2 event to be generated by software.
   1442            * @param  TIM2_EventSource: Specifies the event source.
   1443            *          This parameter can be any combination of the following values:
   1444            *            @arg TIM2_EventSource_Update: Update
   1445            *            @arg TIM2_EventSource_CC1: Capture Compare Channel1
   1446            *            @arg TIM2_EventSource_CC2: Capture Compare Channel2 
   1447            *            @arg TIM2_EventSource_Trigger: Trigger 
   1448            *            @arg TIM2_EventSource_Break: Break  
   1449            * @retval None
   1450            */
   1451          void TIM2_GenerateEvent(TIM2_EventSource_T TIM2_EventSource)
   1452          {
   1453            /* Check the parameters */
   1454            assert_param(IS_TIM2_EVENT_SOURCE((uint8_t)TIM2_EventSource));
   1455          
   1456            /* Set the event sources */
   1457            TIM2->EGR |= (uint8_t)TIM2_EventSource;
   1458          }
   1459          
   1460          /**
   1461            * @brief  Checks whether the specified TIM2 flag is set or not.
   1462            * @param  TIM2_FLAG: Specifies the flag to check.
   1463            *          This parameter can be any combination of the following values:
   1464            *            @arg TIM2_FLAG_Update: Update
   1465            *            @arg TIM2_FLAG_CC1: Capture Compare Channel1
   1466            *            @arg TIM2_FLAG_CC2: Capture Compare Channel2 
   1467            *            @arg TIM2_FLAG_Trigger: Trigger 
   1468            *            @arg TIM2_FLAG_Break: Break  
   1469            *            @arg TIM2_FLAG_CC1OF: Capture compare 1 over capture
   1470            *            @arg TIM2_FLAG_CC2OF: Capture compare 2 over capture   
   1471            * @retval FlagStatus: The new state of TIM2_FLAG (SET or RESET)
   1472            */
   1473          FlagStatus TIM2_GetFlagStatus(TIM2_FLAG_T TIM2_FLAG)
   1474          {
   1475            FlagStatus bitstatus = RESET;
   1476            uint8_t tim2_flag_l = 0, tim2_flag_h = 0;
   1477          
   1478            /* Check the parameters */
   1479            assert_param(IS_TIM2_GET_FLAG(TIM2_FLAG));
   1480          
   1481            tim2_flag_l = (uint8_t)(TIM2->SR1 & (uint8_t)(TIM2_FLAG));
   1482            tim2_flag_h = (uint8_t)(TIM2->SR2 & (uint8_t)((uint16_t)TIM2_FLAG >> 8));
   1483          
   1484            if ((uint8_t)(tim2_flag_l | tim2_flag_h) != 0)
   1485            {
   1486              bitstatus = SET;
   1487            }
   1488            else
   1489            {
   1490              bitstatus = RESET;
   1491            }
   1492            return ((FlagStatus)bitstatus);
   1493          }
   1494          
   1495          /**
   1496            * @brief  Clears the TIM�s pending flags.
   1497            * @param  TIM2_FLAG: Specifies the flag to clear.
   1498            *          This parameter can be any combination of the following values:
   1499            *            @arg TIM2_FLAG_Update: Update
   1500            *            @arg TIM2_FLAG_CC1: Capture Compare Channel1
   1501            *            @arg TIM2_FLAG_CC2: Capture Compare Channel2 
   1502            *            @arg TIM2_FLAG_Trigger: Trigger 
   1503            *            @arg TIM2_FLAG_Break: Break  
   1504            * @retval None
   1505            */
   1506          void TIM2_ClearFlag(TIM2_FLAG_T TIM2_FLAG)
   1507          {
   1508            /* Check the parameters */
   1509            assert_param(IS_TIM2_CLEAR_FLAG((uint16_t)TIM2_FLAG));
   1510            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing �1� has no effect*/
   1511            TIM2->SR1 = (uint8_t)(~(uint8_t)(TIM2_FLAG));
   1512            TIM2->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM2_FLAG >> 8));
   1513          }
   1514          
   1515          /**
   1516            * @brief  Checks whether the TIM2 interrupt has occurred or not.
   1517            * @param  TIM2_IT: Specifies the TIM2 interrupt source to check.
   1518            *          This parameter can be any combination of the following values:
   1519            *            @arg TIM2_IT_Update: Update
   1520            *            @arg TIM2_IT_CC1: Capture Compare Channel1
   1521            *            @arg TIM2_IT_CC2: Capture Compare Channel2 
   1522            *            @arg TIM2_IT_Trigger: Trigger 
   1523            *            @arg TIM2_IT_Break: Break  
   1524            * @retval ITStatus: The new state of the TIM2_IT (SET or RESET)
   1525            */
   1526          ITStatus TIM2_GetITStatus(TIM2_IT_T TIM2_IT)
   1527          {
   1528            ITStatus bitstatus = RESET;
   1529          
   1530            uint8_t TIM2_itStatus = 0x0, TIM2_itEnable = 0x0;
   1531          
   1532            /* Check the parameters */
   1533            assert_param(IS_TIM2_GET_IT(TIM2_IT));
   1534          
   1535            TIM2_itStatus = (uint8_t)(TIM2->SR1 & (uint8_t)TIM2_IT);
   1536          
   1537            TIM2_itEnable = (uint8_t)(TIM2->IER & (uint8_t)TIM2_IT);
   1538          
   1539            if ((TIM2_itStatus != (uint8_t)RESET ) && (TIM2_itEnable != (uint8_t)RESET))
   1540            {
   1541              bitstatus = (ITStatus)SET;
   1542            }
   1543            else
   1544            {
   1545              bitstatus = (ITStatus)RESET;
   1546            }
   1547            return ((ITStatus)bitstatus);
   1548          }
   1549          
   1550          /**
   1551            * @brief  Clears the TIM's interrupt pending bits.
   1552            * @param  TIM2_IT: Specifies the pending bit to clear.
   1553            *          This parameter can be any combination of the following values:
   1554            *            @arg TIM2_IT_Update: Update
   1555            *            @arg TIM2_IT_CC1: Capture Compare Channel1
   1556            *            @arg TIM2_IT_CC2: Capture Compare Channel2 
   1557            *            @arg TIM2_IT_Trigger: Trigger 
   1558            *            @arg TIM2_IT_Break: Break  
   1559            * @retval None
   1560            */
   1561          void TIM2_ClearITPendingBit(TIM2_IT_T TIM2_IT)
   1562          {
   1563            /* Check the parameters */
   1564            assert_param(IS_TIM2_IT(TIM2_IT));
   1565          
   1566            /* Clear the IT pending Bit */
   1567            TIM2->SR1 = (uint8_t)(~(uint8_t)TIM2_IT);
   1568          }
   1569          
   1570          /**
   1571            * @brief  Enables or disables the TIM2 DMA Requests.
   1572            * @param  TIM2_DMASource: specifies the DMA Request sources.
   1573            *          This parameter can be any combination of the following values:
   1574            *            @arg TIM2_DMASource_Update: TIM2 DMA Update Request
   1575            *            @arg TIM2_DMASource_CC1: TIM2 DMA CC1 Request
   1576            *            @arg TIM2_DMASource_CC2: TIM2 DMA CC2 Request 
   1577            * @param  NewState: new state of the DMA Request sources.
   1578            *          This parameter can be: ENABLE or DISABLE.
   1579            * @retval None
   1580            */
   1581          void TIM2_DMACmd( TIM2_DMASource_T TIM2_DMASource, FunctionalState NewState)
   1582          {
   1583            /* Check the parameters */
   1584            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1585            assert_param(IS_TIM2_DMA_SOURCE(TIM2_DMASource));
   1586          
   1587            if (NewState != DISABLE)
   1588            {
   1589              /* Enable the DMA sources */
   1590              TIM2->DER |= TIM2_DMASource;
   1591            }
   1592            else
   1593            {
   1594              /* Disable the DMA sources */
   1595              TIM2->DER &= (uint8_t)(~TIM2_DMASource);
   1596            }
   1597          }
   1598          
   1599          /**
   1600            * @brief  Selects the TIM2 peripheral Capture Compare DMA source.
   1601            * @param   NewState: new state of the Capture Compare DMA source.
   1602            *           This parameter can be: ENABLE or DISABLE.
   1603            * @retval None
   1604            */
   1605          void TIM2_SelectCCDMA(FunctionalState NewState)
   1606          {
   1607            /* Check the parameters */
   1608            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1609          
   1610            if (NewState != DISABLE)
   1611            {
   1612              /* Set the CCDS Bit */
   1613              TIM2->CR2 |= TIM_CR2_CCDS;
   1614            }
   1615            else
   1616            {
   1617              /* Reset the CCDS Bit */
   1618              TIM2->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   1619            }
   1620          }
   1621          
   1622          /**
   1623            * @}
   1624            */
   1625          
   1626          /** @defgroup TIM2_Group5 Clocks management functions
   1627           *  @brief    Clocks management functions
   1628           *
   1629          @verbatim   
   1630           ===============================================================================
   1631                                   Clocks management functions
   1632           ===============================================================================  
   1633          
   1634          @endverbatim
   1635            * @{
   1636            */
   1637          
   1638          /**
   1639            * @brief  Enables the TIM2 internal Clock.
   1640            * @par Parameters:
   1641            * None
   1642            * @retval None
   1643            */
   1644          void TIM2_InternalClockConfig(void)
   1645          {
   1646            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1647            TIM2->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
   1648          }
   1649          
   1650          /**
   1651            * @brief  Configures the TIM2 Trigger as External Clock.
   1652            * @param  TIM2_TIxExternalCLKSource: Specifies Trigger source.
   1653            *          This parameter can be one of the following values:
   1654            *            @arg TIM2_TIxExternalCLK1Source_TI1ED: External Clock mode 1 source = TI1ED
   1655            *            @arg TIM2_TIxExternalCLK1Source_TI1: External Clock mode 1 source = TI1 
   1656            *            @arg TIM2_TIxExternalCLK1Source_TI2: External Clock mode 1 source = TI2  
   1657            * @param  TIM2_ICPolarity: Specifies the TIx Polarity.
   1658            *          This parameter can be one of the following values:
   1659            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1660            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1661            * @param  ICFilter: Specifies the filter value.
   1662            *          This parameter must be a value between 0x00 and 0x0F
   1663            * @retval None
   1664            */
   1665          void TIM2_TIxExternalClockConfig(TIM2_TIxExternalCLK1Source_T TIM2_TIxExternalCLKSource,
   1666                                           TIM2_ICPolarity_T TIM2_ICPolarity,
   1667                                           uint8_t ICFilter)
   1668          {
   1669            /* Check the parameters */
   1670            assert_param(IS_TIM2_TIXCLK_SOURCE(TIM2_TIxExternalCLKSource));
   1671            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   1672            assert_param(IS_TIM2_IC_FILTER(ICFilter));
   1673          
   1674            /* Configure the TIM2 Input Clock Source */
   1675            if (TIM2_TIxExternalCLKSource == TIM2_TIxExternalCLK1Source_TI2)
   1676            {
   1677              TI2_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, ICFilter);
   1678            }
   1679            else
   1680            {
   1681              TI1_Config(TIM2_ICPolarity, TIM2_ICSelection_DirectTI, ICFilter);
   1682            }
   1683          
   1684            /* Select the Trigger source */
   1685            TIM2_SelectInputTrigger((TIM2_TRGSelection_T)TIM2_TIxExternalCLKSource);
   1686          
   1687            /* Select the External clock mode1 */
   1688            TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
   1689          }
   1690          
   1691          /**
   1692            * @brief  Configures the TIM2 External clock Mode1.
   1693            * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1694            *          This parameter can be one of the following values:
   1695            *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
   1696            *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1697            *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1698            *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)   
   1699            * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1700            *          This parameter can be one of the following values:
   1701            *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1702            *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1703            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1704            *          This parameter must be a value between 0x00 and 0x0F
   1705            * @retval None
   1706            */
   1707          void TIM2_ETRClockMode1Config(TIM2_ExtTRGPSC_T TIM2_ExtTRGPrescaler,
   1708                                        TIM2_ExtTRGPolarity_T TIM2_ExtTRGPolarity,
   1709                                        uint8_t ExtTRGFilter)
   1710          {
   1711            /* Configure the ETR Clock source */
   1712            TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, ExtTRGFilter);
   1713          
   1714            /* Select the External clock mode1 */
   1715            TIM2->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
   1716            TIM2->SMCR |= (uint8_t)(TIM2_SlaveMode_External1);
   1717          
   1718            /* Select the Trigger selection: ETRF */
   1719            TIM2->SMCR &= (uint8_t)(~TIM_SMCR_TS);
   1720            TIM2->SMCR |= (uint8_t)((TIM2_TRGSelection_T)TIM2_TRGSelection_ETRF);
   1721          }
   1722          
   1723          /**
   1724            * @brief  Configures the TIM2 External clock Mode2.
   1725            * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1726            *          This parameter can be one of the following values:
   1727            *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
   1728            *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1729            *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1730            *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8) 
   1731            * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1732            *          This parameter can be one of the following values:
   1733            *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1734            *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1735            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1736            *          This parameter must be a value between 0x00 and 0x0F
   1737            * @retval None
   1738            */
   1739          void TIM2_ETRClockMode2Config(TIM2_ExtTRGPSC_T TIM2_ExtTRGPrescaler,
   1740                                        TIM2_ExtTRGPolarity_T TIM2_ExtTRGPolarity,
   1741                                        uint8_t ExtTRGFilter)
   1742          {
   1743            /* Configure the ETR Clock source */
   1744            TIM2_ETRConfig(TIM2_ExtTRGPrescaler, TIM2_ExtTRGPolarity, ExtTRGFilter);
   1745          
   1746            /* Enable the External clock mode2 */
   1747            TIM2->ETR |= TIM_ETR_ECE ;
   1748          }
   1749          
   1750          /**
   1751            * @}
   1752            */
   1753          
   1754          /** @defgroup TIM2_Group6 Synchronization management functions
   1755           *  @brief    Synchronization management functions 
   1756           *
   1757          @verbatim   
   1758           ===============================================================================
   1759                                 Synchronization management functions
   1760           ===============================================================================  
   1761                             
   1762                 ===================================================================      
   1763                        TIM2 Driver: how to use it in synchronization Mode
   1764                 =================================================================== 
   1765                 Case of two/several Timers
   1766                 **************************
   1767                 1. If TIM2 is used as master to other timers use the following functions:
   1768                    - TIM2_SelectOutputTrigger()
   1769                    - TIM2_SelectMasterSlaveMode()
   1770                 2. If TIM2 is used as slave to other timers use the following functions:
   1771                    - TIM2_SelectInputTrigger()
   1772                    - TIM2_SelectSlaveMode()
   1773                    
   1774                 Case of Timers and external trigger (TRIG pin)
   1775                 ********************************************       
   1776                 1. Configure the External trigger using TIM2_ETRConfig()
   1777                 2. Configure the Slave Timer using the following functions:
   1778                    - TIM2_SelectInputTrigger()
   1779                    - TIM2_SelectSlaveMode()
   1780          
   1781          @endverbatim
   1782            * @{
   1783            */
   1784          
   1785          /**
   1786            * @brief  Selects the TIM2 Input Trigger source.
   1787            * @param  TIM2_InputTriggerSource: Specifies Input Trigger source.
   1788            *          This parameter can be one of the following values:
   1789            *            @arg TIM2_TRGSelection_TIM4: TRIG Input source =  TIM TRIG Output
   1790            *            @arg TIM2_TRGSelection_TIM1: TRIG Input source =  TIM TRIG Output
   1791            *            @arg TIM2_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
   1792            *            @arg TIM2_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
   1793            *            @arg TIM2_TRGSelection_TI1F_ED: TRIG Input source = TI1F_ED (TI1 Edge Detector)
   1794            *            @arg TIM2_TRGSelection_TI1FP1: TRIG Input source = TI1FP1 (Filtered Timer Input 1)
   1795            *            @arg TIM2_TRGSelection_TI2FP2: TRIG Input source = TI2FP2 (Filtered Timer Input 2)
   1796            *            @arg TIM2_TRGSelection_ETRF: TRIG Input source =  ETRF (External Trigger Input )      
   1797            * @retval None
   1798            */
   1799          void TIM2_SelectInputTrigger(TIM2_TRGSelection_T TIM2_InputTriggerSource)
   1800          {
   1801            uint8_t tmpsmcr = 0;
   1802          
   1803            /* Check the parameters */
   1804            assert_param(IS_TIM2_TRIGGER_SELECTION(TIM2_InputTriggerSource));
   1805          
   1806            tmpsmcr = TIM2->SMCR;
   1807          
   1808            /* Select the Trigger Source */
   1809            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
   1810            tmpsmcr |= (uint8_t)TIM2_InputTriggerSource;
   1811          
   1812            TIM2->SMCR = (uint8_t)tmpsmcr;
   1813          }
   1814          
   1815          /**
   1816            * @brief  Selects the TIM2 Trigger Output Mode.
   1817            * @param  TIM2_TRGOSource: Specifies the Trigger Output source.
   1818            *          This parameter can be one of the following values:
   1819            *            @arg TIM2_TRGOSource_Reset: Trigger Output source = Reset 
   1820            *            @arg TIM2_TRGOSource_Enable: Trigger Output source = TIM2 is enabled 
   1821            *            @arg TIM2_TRGOSource_Update: Trigger Output source = Update event
   1822            *            @arg TIM2_TRGOSource_OC1: Trigger Output source = output compare channel1
   1823            *            @arg TIM2_TRGOSource_OC1REF: Trigger Output source = output compare channel 1 reference
   1824            *            @arg TIM2_TRGOSource_OC2REF: Trigger Output source = output compare channel 2 reference   
   1825            * @retval None
   1826            */
   1827          void TIM2_SelectOutputTrigger(TIM2_TRGOSource_T TIM2_TRGOSource)
   1828          {
   1829            uint8_t tmpcr2 = 0;
   1830          
   1831            /* Check the parameters */
   1832            assert_param(IS_TIM2_TRGO_SOURCE(TIM2_TRGOSource));
   1833          
   1834            tmpcr2 = TIM2->CR2;
   1835          
   1836            /* Reset the MMS Bits */
   1837            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
   1838          
   1839            /* Select the TRGO source */
   1840            tmpcr2 |=  (uint8_t)TIM2_TRGOSource;
   1841          
   1842            TIM2->CR2 = tmpcr2;
   1843          }
   1844          
   1845          /**
   1846            * @brief  Selects the TIM2 Slave Mode.
   1847            * @param  TIM2_SlaveMode: Specifies the TIM2 Slave Mode.
   1848            *          This parameter can be one of the following values:
   1849            *            @arg TIM2_SlaveMode_Reset: Slave Mode Selection  = Reset
   1850            *            @arg TIM2_SlaveMode_Gated: Slave Mode Selection  = Gated
   1851            *            @arg TIM2_SlaveMode_Trigger: Slave Mode Selection  = Trigger
   1852            *            @arg TIM2_SlaveMode_External1: Slave Mode Selection  = External 1  
   1853            * @retval None
   1854            */
   1855          void TIM2_SelectSlaveMode(TIM2_SlaveMode_T TIM2_SlaveMode)
   1856          {
   1857            uint8_t tmpsmcr = 0;
   1858          
   1859            /* Check the parameters */
   1860            assert_param(IS_TIM2_SLAVE_MODE(TIM2_SlaveMode));
   1861          
   1862            tmpsmcr = TIM2->SMCR;
   1863          
   1864            /* Reset the SMS Bits */
   1865            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
   1866          
   1867            /* Select the Slave Mode */
   1868            tmpsmcr |= (uint8_t)TIM2_SlaveMode;
   1869          
   1870            TIM2->SMCR = tmpsmcr;
   1871          }
   1872          
   1873          /**
   1874            * @brief  Sets or Resets the TIM2 Master/Slave Mode.
   1875            * @param  NewState: The new state of the synchronization between TIM2 and its slaves (through TRGO).
   1876            *          This parameter can be ENABLE or DISABLE
   1877            * @retval None
   1878            */
   1879          void TIM2_SelectMasterSlaveMode(FunctionalState NewState)
   1880          {
   1881            /* Check the parameters */
   1882            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1883          
   1884            /* Set or Reset the MSM Bit */
   1885            if (NewState != DISABLE)
   1886            {
   1887              TIM2->SMCR |= TIM_SMCR_MSM;
   1888            }
   1889            else
   1890            {
   1891              TIM2->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
   1892            }
   1893          }
   1894          
   1895          /**
   1896            * @brief  Configures the TIM2 External Trigger.
   1897            * @param  TIM2_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1898            *          This parameter can be one of the following values:
   1899            *            @arg TIM2_ExtTRGPSC_OFF: No External Trigger prescaler
   1900            *            @arg TIM2_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1901            *            @arg TIM2_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4)
   1902            *            @arg TIM2_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)    
   1903            * @param  TIM2_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1904            *          This parameter can be one of the following values:
   1905            *            @arg TIM2_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1906            *            @arg TIM2_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1907            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1908            *          This parameter must be a value between 0x00 and 0x0F
   1909            * @retval None
   1910            */
   1911          void TIM2_ETRConfig(TIM2_ExtTRGPSC_T TIM2_ExtTRGPrescaler,
   1912                              TIM2_ExtTRGPolarity_T TIM2_ExtTRGPolarity,
   1913                              uint8_t ExtTRGFilter)
   1914          {
   1915            /* Check the parameters */
   1916            assert_param(IS_TIM2_EXT_PRESCALER(TIM2_ExtTRGPrescaler));
   1917            assert_param(IS_TIM2_EXT_POLARITY(TIM2_ExtTRGPolarity));
   1918            assert_param(IS_TIM2_EXT_FILTER(ExtTRGFilter));
   1919          
   1920            /* Set the Prescaler, the Filter value and the Polarity */
   1921            TIM2->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM2_ExtTRGPrescaler | (uint8_t)TIM2_ExtTRGPolarity)
   1922                                   | (uint8_t)ExtTRGFilter);
   1923          }
   1924          
   1925          /**
   1926            * @}
   1927            */
   1928          
   1929          /** @defgroup TIM2_Group7 Specific interface management functions
   1930           *  @brief    Specific interface management functions 
   1931           *
   1932          @verbatim   
   1933           ===============================================================================
   1934                              Specific interface management functions
   1935           ===============================================================================  
   1936          
   1937          @endverbatim
   1938            * @{
   1939            */
   1940          
   1941          /**
   1942            * @brief  Configures the TIM2 Encoder Interface.
   1943            * @param  TIM2_EncoderMode: Specifies the TIM2 Encoder Mode.
   1944            *          This parameter can be one of the following values:
   1945            *            @arg TIM2_EncoderMode_TI1: Encoder mode 1
   1946            *            @arg TIM2_EncoderMode_TI2: Encoder mode 2
   1947            *            @arg TIM2_EncoderMode_TI12: Encoder mode 3   
   1948            * @param  TIM2_IC1Polarity: Specifies the IC1 Polarity.
   1949            *          This parameter can be one of the following values:
   1950            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1951            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1952            * @param  TIM2_IC2Polarity: Specifies the IC2 Polarity.
   1953            *          This parameter can be one of the following values:
   1954            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   1955            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   1956            * @retval None
   1957            */
   1958          void TIM2_EncoderInterfaceConfig(TIM2_EncoderMode_T TIM2_EncoderMode,
   1959                                           TIM2_ICPolarity_T TIM2_IC1Polarity,
   1960                                           TIM2_ICPolarity_T TIM2_IC2Polarity)
   1961          {
   1962            uint8_t tmpsmcr = 0;
   1963            uint8_t tmpccmr1 = 0;
   1964            uint8_t tmpccmr2 = 0;
   1965          
   1966            /* Check the parameters */
   1967            assert_param(IS_TIM2_ENCODER_MODE(TIM2_EncoderMode));
   1968            assert_param(IS_TIM2_IC_POLARITY(TIM2_IC1Polarity));
   1969            assert_param(IS_TIM2_IC_POLARITY(TIM2_IC2Polarity));
   1970          
   1971            tmpsmcr = TIM2->SMCR;
   1972            tmpccmr1 = TIM2->CCMR1;
   1973            tmpccmr2 = TIM2->CCMR2;
   1974          
   1975            /* Set the encoder Mode */
   1976            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
   1977            tmpsmcr |= (uint8_t)TIM2_EncoderMode;
   1978          
   1979            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1980            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
   1981            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
   1982            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
   1983            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
   1984          
   1985            /* Set the TI1 and the TI2 Polarities */
   1986            if (TIM2_IC1Polarity == TIM2_ICPolarity_Falling)
   1987            {
   1988              TIM2->CCER1 |= TIM_CCER1_CC1P ;
   1989            }
   1990            else
   1991            {
   1992              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   1993            }
   1994          
   1995            if (TIM2_IC2Polarity == TIM2_ICPolarity_Falling)
   1996            {
   1997              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   1998            }
   1999            else
   2000            {
   2001              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   2002            }
   2003          
   2004            TIM2->SMCR = tmpsmcr;
   2005            TIM2->CCMR1 = tmpccmr1;
   2006            TIM2->CCMR2 = tmpccmr2;
   2007          }
   2008          
   2009          /**
   2010            * @brief  Enables or Disables the TIM�s Hall sensor interface.
   2011            * @param  NewState: The new state of the TIM2 Hall sensor interface.
   2012            *          This parameter can be ENABLE or DISABLE
   2013            * @retval None
   2014            */
   2015          void TIM2_SelectHallSensor(FunctionalState NewState)
   2016          {
   2017            /* Check the parameters */
   2018            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2019          
   2020            /* Set or Reset the TI1S Bit */
   2021            if (NewState != DISABLE)
   2022            {
   2023              TIM2->CR2 |= TIM_CR2_TI1S;
   2024            }
   2025            else
   2026            {
   2027              TIM2->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
   2028            }
   2029          }
   2030          
   2031          /**
   2032            * @}
   2033            */
   2034          
   2035          /**
   2036            * @brief  Configure the TI1 as Input.
   2037            * @param  TIM2_ICPolarity: Input Capture Polarity
   2038            *          This parameter can be one of the following values:
   2039            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   2040            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   2041            * @param  TIM2_ICSelection: Specifies the input to be used.
   2042            *          This parameter can be one of the following values:
   2043            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   2044            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2045            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2046            * @param  TIM2_ICFilter: Specifies the Input Capture Filter.
   2047            *          This parameter must be a value between 0x00 and 0x0F.
   2048            * @retval None
   2049            */
   2050          static void TI1_Config(TIM2_ICPolarity_T TIM2_ICPolarity, \
   2051                                 TIM2_ICSelection_T TIM2_ICSelection, \
   2052                                 uint8_t TIM2_ICFilter)
   2053          {
   2054            uint8_t tmpccmr1 = 0;
   2055            uint8_t tmpicpolarity = TIM2_ICPolarity;
   2056            tmpccmr1 = TIM2->CCMR1;
   2057          
   2058            /* Check the parameters */
   2059            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   2060            assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
   2061            assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
   2062          
   2063            /* Disable the Channel 1: Reset the CCE Bit */
   2064            TIM2->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   2065          
   2066            /* Select the Input and set the filter */
   2067            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   2068            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
   2069          
   2070            TIM2->CCMR1 = tmpccmr1;
   2071          
   2072            /* Select the Polarity */
   2073            if (tmpicpolarity == (uint8_t)(TIM2_ICPolarity_Falling))
   2074            {
   2075              TIM2->CCER1 |= TIM_CCER1_CC1P;
   2076            }
   2077            else
   2078            {
   2079              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   2080            }
   2081          
   2082            /* Set the CCE Bit */
   2083            TIM2->CCER1 |=  TIM_CCER1_CC1E;
   2084          }
   2085          
   2086          /**
   2087            * @brief  Configure the TI2 as Input.
   2088            * @param  TIM2_ICPolarity: Input Capture Polarity
   2089            *          This parameter can be one of the following values:
   2090            *            @arg TIM2_ICPolarity_Rising: Input Capture on Rising Edge
   2091            *            @arg TIM2_ICPolarity_Falling: Input Capture on Falling Edge  
   2092            * @param  TIM2_ICSelection: Specifies the input to be used.
   2093            *          This parameter can be one of the following values:
   2094            *            @arg TIM2_ICSelection_DirectTI: Input Capture mapped on the direct input
   2095            *            @arg TIM2_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2096            *            @arg TIM2_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2097            * @param  TIM2_ICFilter: Specifies the Input Capture Filter.
   2098            *          This parameter must be a value between 0x00 and 0x0F.
   2099            * @retval None
   2100            */
   2101          static void TI2_Config(TIM2_ICPolarity_T TIM2_ICPolarity,
   2102                                 TIM2_ICSelection_T TIM2_ICSelection,
   2103                                 uint8_t TIM2_ICFilter)
   2104          {
   2105            uint8_t tmpccmr2 = 0;
   2106            uint8_t tmpicpolarity = TIM2_ICPolarity;
   2107          
   2108            /* Check the parameters */
   2109            assert_param(IS_TIM2_IC_POLARITY(TIM2_ICPolarity));
   2110            assert_param(IS_TIM2_IC_SELECTION(TIM2_ICSelection));
   2111            assert_param(IS_TIM2_IC_FILTER(TIM2_ICFilter));
   2112          
   2113            tmpccmr2 = TIM2->CCMR2;
   2114          
   2115            /* Disable the Channel 2: Reset the CCE Bit */
   2116            TIM2->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   2117          
   2118            /* Select the Input and set the filter */
   2119            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   2120            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM2_ICSelection)) | ((uint8_t)(TIM2_ICFilter << 4)));
   2121          
   2122            TIM2->CCMR2 = tmpccmr2;
   2123          
   2124            /* Select the Polarity */
   2125            if (tmpicpolarity == TIM2_ICPolarity_Falling)
   2126            {
   2127              TIM2->CCER1 |= TIM_CCER1_CC2P ;
   2128            }
   2129            else
   2130            {
   2131              TIM2->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   2132            }
   2133          
   2134            /* Set the CCE Bit */
   2135            TIM2->CCER1 |=  TIM_CCER1_CC2E;
   2136          }
   2137          
   2138          /**
   2139            * @}
   2140            */ 
   2141          
   2142          /**
   2143            * @}
   2144            */ 
   2145            
   2146          /**
   2147            * @}
   2148            */
   2149          
   2150          /**
   2151            * @}
   2152            */
   2153          
   2154          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine15_0
       8  ??Subroutine16_0
      22  ?Subroutine0
      15  ?Subroutine1
      14  ?Subroutine10
      12  ?Subroutine11
      12  ?Subroutine12
       8  ?Subroutine13
       8  ?Subroutine14
      14  ?Subroutine2
       9  ?Subroutine3
      15  ?Subroutine4
       2  ?Subroutine5
       9  ?Subroutine6
      15  ?Subroutine7
       2  ?Subroutine8
      12  ?Subroutine9
      34  TI1_Config
      34  TI2_Config
      13  TIM2_ARRPreloadConfig
      16  TIM2_BKRConfig
      31  TIM2_CCxCmd
      13  TIM2_ClearFlag
       5  TIM2_ClearITPendingBit
      13  TIM2_Cmd
      13  TIM2_CounterModeConfig
      13  TIM2_CtrlPWMOutputs
      17  TIM2_DMACmd
     101  TIM2_DeInit
      30  TIM2_ETRClockMode1Config
       9  TIM2_ETRClockMode2Config
       5  TIM2_ETRConfig
      89  TIM2_EncoderInterfaceConfig
      13  TIM2_ForcedOC1Config
      13  TIM2_ForcedOC2Config
       7  TIM2_GenerateEvent
      13  TIM2_GetCapture1
      13  TIM2_GetCapture2
      13  TIM2_GetCounter
      38  TIM2_GetFlagStatus
      33  TIM2_GetITStatus
       4  TIM2_GetPrescaler
      83  TIM2_ICInit
      17  TIM2_ITConfig
       9  TIM2_InternalClockConfig
      13  TIM2_OC1FastConfig
      63  TIM2_OC1Init
      14  TIM2_OC1PolarityConfig
      13  TIM2_OC1PreloadConfig
      13  TIM2_OC2FastConfig
      63  TIM2_OC2Init
      14  TIM2_OC2PolarityConfig
      13  TIM2_OC2PreloadConfig
      88  TIM2_PWMIConfig
      19  TIM2_PrescalerConfig
      13  TIM2_SelectCCDMA
      13  TIM2_SelectHallSensor
      13  TIM2_SelectInputTrigger
      13  TIM2_SelectMasterSlaveMode
      45  TIM2_SelectOCxM
      14  TIM2_SelectOnePulseMode
      13  TIM2_SelectOutputTrigger
      13  TIM2_SelectSlaveMode
       5  TIM2_SetAutoreload
       7  TIM2_SetCompare1
       7  TIM2_SetCompare2
      14  TIM2_SetCounter
      13  TIM2_SetIC1Prescaler
      13  TIM2_SetIC2Prescaler
      81  TIM2_TIxExternalClockConfig
      32  TIM2_TimeBaseInit
      13  TIM2_UpdateDisableConfig
      14  TIM2_UpdateRequestConfig

 
 1 526 bytes in section .far_func.text
 
 1 526 bytes of CODE memory

Errors: none
Warnings: none
