###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:25
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim3.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim3.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_tim3.lst
#    Object file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_tim3.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim3.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim3.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM3 peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *              
     17            *  @verbatim
     18            *  
     19            *          ===================================================================
     20            *                                 How to use this driver
     21            *          ===================================================================
     22            *          This driver provides functions to configure and initialize the TIM3
     23            *          peripheral
     24            *          These functions are split in 7 groups: 
     25            *   
     26            *          1. TIM3 TimeBase management: this group includes all needed functions 
     27            *             to configure the TIM Timebase unit:
     28            *                   - Set/Get Prescaler
     29            *                   - Set/Get Autoreload  
     30            *                   - Counter modes configuration
     31            *                   - Select the One Pulse mode
     32            *                   - Update Request Configuration
     33            *                   - Update Disable Configuration
     34            *                   - Auto-Preload Configuration 
     35            *                   - Enable/Disable the counter
     36            *                 
     37            *          2. TIM3 Output Compare management: this group includes all needed 
     38            *             functions to configure the Capture/Compare unit used in Output 
     39            *             compare mode: 
     40            *                   - Configure each channel, independently, in Output Compare mode
     41            *                   - Select the output compare modes
     42            *                   - Select the Polarities of each channel
     43            *                   - Set/Get the Capture/Compare register values
     44            *                   - Select the Output Compare Fast mode 
     45            *                   - Select the Output Compare Forced mode  
     46            *                   - Output Compare-Preload Configuration 
     47            *                   - Enable/Disable the Capture/Compare Channels    
     48            *                   
     49            *          3. TIM3 Input Capture management: this group includes all needed 
     50            *             functions to configure the Capture/Compare unit used in 
     51            *             Input Capture mode:
     52            *                   - Configure each channel in input capture mode
     53            *                   - Configure Channel1/2 in PWM Input mode
     54            *                   - Set the Input Capture Prescaler
     55            *                   - Get the Capture/Compare values      
     56            *        
     57            *          4. TIM3 interrupts, DMA and flags management
     58            *                   - Enable/Disable interrupt sources
     59            *                   - Get flags status
     60            *                   - Clear flags/ Pending bits
     61            *                   - Enable/Disable DMA requests 
     62            *                   - Select CaptureCompare DMA request  
     63            *              
     64            *          5. TIM3 clocks management: this group includes all needed functions 
     65            *             to configure the clock controller unit:
     66            *                   - Select internal/External clock
     67            *                   - Select the external clock mode: ETR(Mode1/Mode2) or TIx
     68            *         
     69            *          6. TIM3 synchronization management: this group includes all needed 
     70            *             functions to configure the Synchronization unit:
     71            *                   - Select Input Trigger  
     72            *                   - Select Output Trigger  
     73            *                   - Select Master Slave Mode 
     74            *                   - ETR Configuration when used as external trigger   
     75            *     
     76            *          7. TIM3 specific interface management, this group includes all 
     77            *             needed functions to use the specific TIM3 interface:
     78            *                   - Encoder Interface Configuration
     79            *                   - Select Hall Sensor        
     80            *   
     81            *  @endverbatim
     82            *    
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     87            *
     88            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     89            * You may not use this file except in compliance with the License.
     90            * You may obtain a copy of the License at:
     91            *
     92            *        http://www.st.com/software_license_agreement_liberty_v2
     93            *
     94            * Unless required by applicable law or agreed to in writing, software 
     95            * distributed under the License is distributed on an "AS IS" BASIS, 
     96            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     97            * See the License for the specific language governing permissions and
     98            * limitations under the License.
     99            *
    100            ******************************************************************************
    101            */
    102          
    103          /* Includes ------------------------------------------------------------------*/
    104          #include "stm8l15x_TIM3.h"
    105          
    106          /** @addtogroup STM8L15x_StdPeriph_Driver
    107            * @{
    108            */
    109          
    110          /** @defgroup TIM3 
    111            * @brief TIM3 driver modules
    112            * @{
    113            */
    114            
    115          /* Private typedef -----------------------------------------------------------*/
    116          /* Private define ------------------------------------------------------------*/
    117          /* Private macro -------------------------------------------------------------*/
    118          /* Private variables ---------------------------------------------------------*/
    119          /* Private function prototypes -----------------------------------------------*/
    120          static void TI1_Config(TIM3_ICPolarity_T TIM3_ICPolarity,
    121                                 TIM3_ICSelection_T TIM3_ICSelection,
    122                                 uint8_t TIM3_ICFilter);
    123          static void TI2_Config(TIM3_ICPolarity_T TIM3_ICPolarity,
    124                                 TIM3_ICSelection_T TIM3_ICSelection,
    125                                 uint8_t TIM3_ICFilter);
    126          
    127          
    128          /** @defgroup TIM3_Private_Functions
    129            * @{
    130            */
    131          
    132          /** @defgroup TIM3_Group1 TimeBase management functions
    133           *  @brief   TimeBase management functions 
    134           *
    135          @verbatim   
    136           ===============================================================================
    137                                 TimeBase management functions
    138           ===============================================================================  
    139            
    140                 ===================================================================      
    141                        TIM3 Driver: how to use it in Timing(Time base) Mode
    142                 =================================================================== 
    143                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    144                 
    145                 1. Enable TIM3 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE) function.
    146                  
    147                 2. Call TIM3_TimeBaseInit() to configure the Time Base unit with the
    148                    corresponding configuration.
    149                    
    150                 3. Enable global interrupts if you need to generate the update interrupt.
    151                    
    152                 4. Enable the corresponding interrupt using the function TIM3_ITConfig(TIM3_IT_Update) 
    153                    
    154                 5. Call the TIM3_Cmd(ENABLE) function to enable the TIM3 counter.
    155                 
    156                 Note1: All other functions can be used separately to modify, if needed,
    157                    a specific feature of the Timer. 
    158          
    159          @endverbatim
    160            * @{
    161            */
    162          
    163          /**
    164            * @brief  Deinitialize the TIM3 peripheral registers to their default reset values.
    165            * @param  None
    166            * @retval None
    167            */
    168          void TIM3_DeInit(void)
    169          {
    170            TIM3->CR1 = TIM_CR1_RESET_VALUE;
    171            TIM3->CR2 = TIM_CR2_RESET_VALUE;
    172            TIM3->SMCR = TIM_SMCR_RESET_VALUE;
    173            TIM3->ETR = TIM_ETR_RESET_VALUE;
    174            TIM3->IER = TIM_IER_RESET_VALUE;
    175            TIM3->SR2 = TIM_SR2_RESET_VALUE;
    176          
    177            /* Disable channels */
    178            TIM3->CCER1 = TIM_CCER1_RESET_VALUE;
    179            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
    180            TIM3->CCMR1 = 0x01;/*TIM3_ICxSource_TIxFPx */
    181            TIM3->CCMR2 = 0x01;/*TIM3_ICxSource_TIxFPx */
    182          
    183            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
    184            TIM3->CCER1 = TIM_CCER1_RESET_VALUE;
    185            TIM3->CCMR1 = TIM_CCMR1_RESET_VALUE;
    186            TIM3->CCMR2 = TIM_CCMR2_RESET_VALUE;
    187          
    188            TIM3->CNTRH = TIM_CNTRH_RESET_VALUE;
    189            TIM3->CNTRL = TIM_CNTRL_RESET_VALUE;
    190          
    191            TIM3->PSCR = TIM_PSCR_RESET_VALUE;
    192          
    193            TIM3->ARRH = TIM_ARRH_RESET_VALUE;
    194            TIM3->ARRL = TIM_ARRL_RESET_VALUE;
    195          
    196            TIM3->CCR1H = TIM_CCR1H_RESET_VALUE;
    197            TIM3->CCR1L = TIM_CCR1L_RESET_VALUE;
    198            TIM3->CCR2H = TIM_CCR2H_RESET_VALUE;
    199            TIM3->CCR2L = TIM_CCR2L_RESET_VALUE;
    200          
    201          
    202            TIM3->OISR = TIM_OISR_RESET_VALUE;
    203            TIM3->EGR = 0x01;/* TIM_EGR_UG */
    204            TIM3->BKR = TIM_BKR_RESET_VALUE;
    205            TIM3->SR1 = TIM_SR1_RESET_VALUE;
    206          }
    207          
    208          /**
    209            * @brief  Initializes the TIM3 Time Base Unit according to the specified  parameters.
    210            * @param  TIM3_Prescaler: Prescaler 
    211            *          This parameter can be one of the following values:
    212            *            @arg TIM3_Prescaler_1: Time base Prescaler = 1 (No effect)
    213            *            @arg TIM3_Prescaler_2: Time base Prescaler = 2
    214            *            @arg TIM3_Prescaler_4: Time base Prescaler = 4
    215            *            @arg TIM3_Prescaler_8: Time base Prescaler = 8
    216            *            @arg TIM3_Prescaler_16: Time base Prescaler = 16
    217            *            @arg TIM3_Prescaler_32: Time base Prescaler = 32
    218            *            @arg TIM3_Prescaler_64: Time base Prescaler = 64
    219            *            @arg TIM3_Prescaler_128: Time base Prescaler = 128                            
    220            * @param  TIM3_CounterMode: Counter mode
    221            *          This parameter can be one of the following values:
    222            *            @arg TIM3_CounterMode_Up: Counter Up Mode
    223            *            @arg TIM3_CounterMode_Down: Counter Down Mode
    224            *            @arg TIM3_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    225            *            @arg TIM3_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    226            *            @arg TIM3_CounterMode_CenterAligned3: Counter Central aligned Mode 3        
    227            * @param  TIM3_Period: This parameter must be a value between 0x0000 and 0xFFFF.
    228            * @retval None
    229            */
    230          
    231          void TIM3_TimeBaseInit(TIM3_Prescaler_T TIM3_Prescaler,
    232                                 TIM3_CounterMode_T TIM3_CounterMode,
    233                                 uint16_t TIM3_Period)
    234          {
    235          
    236            assert_param(IS_TIM3_PRESCALER(TIM3_Prescaler));
    237            assert_param(IS_TIM3_COUNTER_MODE(TIM3_CounterMode));
    238          
    239          
    240          
    241            /* Set the Autoreload value */
    242            TIM3->ARRH = (uint8_t)(TIM3_Period >> 8) ;
    243            TIM3->ARRL = (uint8_t)(TIM3_Period);
    244          
    245            /* Set the Prescaler value */
    246            TIM3->PSCR = (uint8_t)(TIM3_Prescaler);
    247          
    248            /* Select the Counter Mode */
    249            TIM3->CR1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS)) & ((uint8_t)(~TIM_CR1_DIR));
    250            TIM3->CR1 |= (uint8_t)(TIM3_CounterMode);
    251          
    252            /* Generate an update event to reload the Prescaler value immediately */
    253            TIM3->EGR = TIM3_EventSource_Update;
    254          }
    255          
    256          /**
    257            * @brief  Configures the TIM3 Prescaler.
    258            * @param  Prescaler: Specifies the Prescaler Register value
    259            *          This parameter can be one of the following values:
    260            *            @arg TIM3_Prescaler_1: Time base Prescaler = 1 (No effect)
    261            *            @arg TIM3_Prescaler_2: Time base Prescaler = 2
    262            *            @arg TIM3_Prescaler_4: Time base Prescaler = 4
    263            *            @arg TIM3_Prescaler_8: Time base Prescaler = 8
    264            *            @arg TIM3_Prescaler_16: Time base Prescaler = 16
    265            *            @arg TIM3_Prescaler_32: Time base Prescaler = 32
    266            *            @arg TIM3_Prescaler_64: Time base Prescaler = 64
    267            *            @arg TIM3_Prescaler_128: Time base Prescaler = 128  
    268            * @param  TIM3_PSCReloadMode: Specifies the TIM3 Prescaler Reload mode.
    269            *          This parameter can be one of the following values:
    270            *            @arg TIM3_PSCReloadMode_Update: Prescaler value is reloaded at every update
    271            *            @arg TIM3_PSCReloadMode_Immediate: Prescaler value is reloaded at every update  
    272            * @retval None
    273            */
    274          void TIM3_PrescalerConfig(TIM3_Prescaler_T Prescaler,
    275                                    TIM3_PSCReloadMode_T TIM3_PSCReloadMode)
    276          {
    277            /* Check the parameters */
    278            assert_param(IS_TIM3_PRESCALER(Prescaler));
    279            assert_param(IS_TIM3_PRESCALER_RELOAD(TIM3_PSCReloadMode));
    280          
    281            /* Set the Prescaler value */
    282            TIM3->PSCR = (uint8_t)(Prescaler);
    283          
    284            /* Set or reset the UG Bit */
    285            if (TIM3_PSCReloadMode == TIM3_PSCReloadMode_Immediate)
    286            {
    287              TIM3->EGR |= TIM_EGR_UG ;
    288            }
    289            else
    290            {
    291              TIM3->EGR &= (uint8_t)(~TIM_EGR_UG) ;
    292            }
    293          }
    294          
    295          /**
    296            * @brief  Specifies the TIM3 Counter Mode to be used.
    297            * @param  TIM3_CounterMode: Specifies the Counter Mode to be used
    298            *          This parameter can be one of the following values:
    299            *            @arg TIM3_CounterMode_Up: Counter Up Mode
    300            *            @arg TIM3_CounterMode_Down: Counter Down Mode
    301            *            @arg TIM3_CounterMode_CenterAligned1: Counter Central aligned Mode 1
    302            *            @arg TIM3_CounterMode_CenterAligned2: Counter Central aligned Mode 2
    303            *            @arg TIM3_CounterMode_CenterAligned3: Counter Central aligned Mode 3      
    304            * @retval None
    305            */
    306          void TIM3_CounterModeConfig(TIM3_CounterMode_T TIM3_CounterMode)
    307          {
    308            uint8_t tmpcr1 = 0;
    309          
    310            /* Check the parameters */
    311            assert_param(IS_TIM3_COUNTER_MODE(TIM3_CounterMode));
    312          
    313            tmpcr1 = TIM3->CR1;
    314          
    315            /* Reset the CMS and DIR Bits */
    316            tmpcr1 &= (uint8_t)((uint8_t)(~TIM_CR1_CMS) & (uint8_t)(~TIM_CR1_DIR));
    317          
    318            /* Set the Counter Mode */
    319            tmpcr1 |= (uint8_t)TIM3_CounterMode;
    320          
    321            TIM3->CR1 = tmpcr1;
    322          }
    323          
    324          /**
    325            * @brief  Sets the TIM3 Counter Register value.
    326            * @param  Counter: Specifies the Counter register new value.
    327            *          This parameter is between 0x0000 and 0xFFFF.
    328            * @retval None
    329            */
    330          void TIM3_SetCounter(uint16_t Counter)
    331          {
    332          
    333            /* Set the Counter Register value */
    334            TIM3->CNTRH = (uint8_t)(Counter >> 8);
    335            TIM3->CNTRL = (uint8_t)(Counter);
    336          }
    337          
    338          /**
    339            * @brief  Sets the TIM3 Autoreload Register value.
    340            * @param  Autoreload: Specifies the Autoreload register new value.
    341            *          This parameter is between 0x0000 and 0xFFFF.
    342            * @retval None
    343            */
    344          void TIM3_SetAutoreload(uint16_t Autoreload)
    345          {
    346            /* Set the Autoreload Register value */
    347            TIM3->ARRH = (uint8_t)(Autoreload >> 8);
    348            TIM3->ARRL = (uint8_t)(Autoreload);
    349          }
    350          
    351          /**
    352            * @brief  Gets the TIM3 Counter value.
    353            * @param  None
    354            * @retval Counter Register value.
    355            */
    356          uint16_t TIM3_GetCounter(void)
    357          {
    358            uint16_t tmpcnt = 0;
    359            uint8_t tmpcntrl, tmpcntrh;
    360          
    361            tmpcntrh = TIM3->CNTRH;
    362            tmpcntrl = TIM3->CNTRL;
    363          
    364            tmpcnt = (uint16_t)(tmpcntrl);
    365            tmpcnt |= (uint16_t)((uint16_t)tmpcntrh << 8);
    366            /* Get the Counter Register value */
    367            return ((uint16_t)tmpcnt);
    368          }
    369          
    370          /**
    371            * @brief  Gets the TIM3 Prescaler value.
    372            * @param  None
    373            * @retval TIM3 Prescaler, it can be one of the following values:
    374            *            - TIM3_Prescaler_1: Time base Prescaler = 1 (No effect)
    375            *            - TIM3_Prescaler_2: Time base Prescaler = 2
    376            *            - TIM3_Prescaler_4: Time base Prescaler = 4
    377            *            - TIM3_Prescaler_8: Time base Prescaler = 8
    378            *            - TIM3_Prescaler_16: Time base Prescaler = 16
    379            *            - TIM3_Prescaler_32: Time base Prescaler = 32
    380            *            - TIM3_Prescaler_64: Time base Prescaler = 64
    381            *            - TIM3_Prescaler_128: Time base Prescaler = 128    
    382            */
    383          TIM3_Prescaler_T TIM3_GetPrescaler(void)
    384          {
    385            /* Get the Prescaler Register value */
    386            return ((TIM3_Prescaler_T)TIM3->PSCR);
    387          }
    388          
    389          /**
    390            * @brief  Enables or Disables the TIM3 Update event.
    391            * @param  NewState: The new state of the TIM3 peripheral Preload register.
    392            *          This parameter can be ENABLE or DISABLE
    393            * @retval None
    394            */
    395          
    396          void TIM3_UpdateDisableConfig(FunctionalState NewState)
    397          {
    398            /* Check the parameters */
    399            assert_param(IS_FUNCTIONAL_STATE(NewState));
    400          
    401            /* Set or Reset the UDIS Bit */
    402            if (NewState != DISABLE)
    403            {
    404              TIM3->CR1 |= TIM_CR1_UDIS;
    405            }
    406            else
    407            {
    408              TIM3->CR1 &= (uint8_t)(~TIM_CR1_UDIS);
    409            }
    410          }
    411          
    412          /**
    413            * @brief  Selects the TIM3 Update Request Interrupt source.
    414            * @param  TIM3_UpdateSource: Specifies the Update source.
    415            *          This parameter can be one of the following values:
    416            *            @arg TIM3_UpdateSource_Global: Global Update request source
    417            *            @arg TIM3_UpdateSource_Regular: Regular Update request source 
    418            * @retval None
    419            */
    420          void TIM3_UpdateRequestConfig(TIM3_UpdateSource_T TIM3_UpdateSource)
    421          {
    422            /* Check the parameters */
    423            assert_param(IS_TIM3_UPDATE_SOURCE(TIM3_UpdateSource));
    424          
    425            /* Set or Reset the URS Bit */
    426            if (TIM3_UpdateSource == TIM3_UpdateSource_Regular)
    427            {
    428              TIM3->CR1 |= TIM_CR1_URS ;
    429            }
    430            else
    431            {
    432              TIM3->CR1 &= (uint8_t)(~TIM_CR1_URS);
    433            }
    434          }
    435          
    436          /**
    437            * @brief  Enables or disables TIM3 peripheral Preload register on ARR.
    438            * @param  NewState: The new state of the TIM3 peripheral Preload register.
    439            *          This parameter can be ENABLE or DISABLE
    440            * @retval None
    441            */
    442          void TIM3_ARRPreloadConfig(FunctionalState NewState)
    443          {
    444            /* Check the parameters */
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            /* Set or Reset the ARPE Bit */
    448            if (NewState != DISABLE)
    449            {
    450              TIM3->CR1 |= TIM_CR1_ARPE;
    451            }
    452            else
    453            {
    454              TIM3->CR1 &= (uint8_t)(~TIM_CR1_ARPE);
    455            }
    456          }
    457          
    458          /**
    459            * @brief  Selects the TIM�s One Pulse Mode.
    460            * @param  TIM3_OPMode: Specifies the OPM Mode to be used.
    461            *          This parameter can be one of the following values:
    462            *            @arg TIM3_OPMode_Single: Single one Pulse mode (OPM Active)
    463            *            @arg TIM3_OPMode_Repetitive: Single one Pulse mode (OPM Active)  
    464            * @retval None
    465            */
    466          void TIM3_SelectOnePulseMode(TIM3_OPMode_T TIM3_OPMode)
    467          {
    468            /* Check the parameters */
    469            assert_param(IS_TIM3_OPM_MODE(TIM3_OPMode));
    470          
    471            /* Set or Reset the OPM Bit */
    472            if (TIM3_OPMode == TIM3_OPMode_Single)
    473            {
    474              TIM3->CR1 |= TIM_CR1_OPM ;
    475            }
    476            else
    477            {
    478              TIM3->CR1 &= (uint8_t)(~TIM_CR1_OPM);
    479            }
    480          }
    481          
    482          /**
    483            * @brief  Enables or disables the TIM3 peripheral.
    484            * @param  NewState: The new state of the TIM3 peripheral.
    485            *          This parameter can be ENABLE or DISABLE
    486            * @retval None
    487            */
    488          void TIM3_Cmd(FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_FUNCTIONAL_STATE(NewState));
    492          
    493            /* set or Reset the CEN Bit */
    494            if (NewState != DISABLE)
    495            {
    496              TIM3->CR1 |= TIM_CR1_CEN;
    497            }
    498            else
    499            {
    500              TIM3->CR1 &= (uint8_t)(~TIM_CR1_CEN);
    501            }
    502          }
    503          
    504          /**
    505            * @}
    506            */
    507          
    508          /** @defgroup TIM3_Group2 Output Compare management functions
    509           *  @brief    Output Compare management functions 
    510           *
    511          @verbatim   
    512           ===============================================================================
    513                                  Output Compare management functions
    514           ===============================================================================  
    515             
    516                 ===================================================================      
    517                        TIM3 Driver: how to use it in Output Compare Mode
    518                 =================================================================== 
    519                 To use the Timer in Output Compare mode, the following steps are mandatory:
    520                 
    521                 1. Enable TIM3 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE) function.
    522                 
    523                 2. Configure the TIM3 pins in output mode by configuring the corresponding GPIO pins
    524                    
    525                 3. Configure the Time base unit as described in the first part of this driver, if needed,
    526                    otherwise the Timer will run with the default configuration:
    527                    - Autoreload value = 0xFFFF
    528                    - Prescaler value = 0x0000
    529                    - Counter mode = Up counting
    530                
    531                 4. Call TIM3_OCxInit() to configure the channel x with the desired parameters
    532                    including:
    533                    - TIM3 Output Compare mode: TIM3_OCMode
    534                    - TIM3 Output State: TIM3_OutputState
    535                    - TIM3 Pulse value: TIM3_Pulse
    536                    - TIM3 Output Compare Polarity: TIM3_OCPolarity
    537                    - TIM3 Output Idle State: TIM3_OCIdleState
    538                 
    539                 5. Call the TIM3_Cmd(ENABLE) function to enable the TIM3 counter.
    540                 
    541                 Note1: All other functions can be used separately to modify, if needed,
    542                    a specific feature of the Timer. 
    543                 
    544                 Note2: If the corresponding interrupt or DMA request are needed, the user should:
    545                        1. Enable global interrupts (or the DMA) to use the TIM3 interrupts (or DMA requests). 
    546                        2. Enable the corresponding interrupt (or DMA request) using the function 
    547                        TIM3_ITConfig(TIM3_IT_CCx) (or TIM3_DMACmd(TIM3_DMASource_CCx))   
    548          
    549          @endverbatim
    550            * @{
    551            */
    552          
    553          /**
    554            * @brief  Initializes the TIM3 Channel1 according to the specified parameters.
    555            * @param  TIM3_OCMode: Output Compare Mode 
    556            *          This parameter can be one of the following values:
    557            *            @arg TIM3_OCMode_Timing: Timing (Frozen) Mode
    558            *            @arg TIM3_OCMode_Active: Active Mode
    559            *            @arg TIM3_OCMode_Inactive: Inactive Mode
    560            *            @arg TIM3_OCMode_Toggle: Toggle Mode
    561            *            @arg TIM3_OCMode_PWM1: PWM Mode 1
    562            *            @arg TIM3_OCMode_PWM2: PWM Mode 2          
    563            * @param  TIM3_OutputState: Output state
    564            *          This parameter can be one of the following values:
    565            *            @arg TIM3_OutputState_Disable: Output compare State disabled (channel output disabled)
    566            *            @arg TIM3_OutputState_Enable: Output compare State enabled (channel output enabled)
    567            * @param  TIM3_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    568            * @param  TIM3_OCPolarity: Polarity
    569            *          This parameter can be one of the following values:
    570            *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
    571            *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
    572            * @param  TIM3_OCIdleState: Output Compare Idle State
    573            *          This parameter can be one of the following values:
    574            *            @arg TIM3_OCIdleState_Reset: Output Compare Idle state  = Reset
    575            *            @arg TIM3_OCIdleState_Set: Output Compare Idle state  = Set
    576            * @retval None
    577            */
    578          void TIM3_OC1Init(TIM3_OCMode_T TIM3_OCMode,
    579                            TIM3_OutputState_T TIM3_OutputState,
    580                            uint16_t TIM3_Pulse,
    581                            TIM3_OCPolarity_T TIM3_OCPolarity,
    582                            TIM3_OCIdleState_T TIM3_OCIdleState)
    583          {
    584            uint8_t tmpccmr1 = 0;
    585          
    586            /* Check the parameters */
    587            assert_param(IS_TIM3_OC_MODE(TIM3_OCMode));
    588            assert_param(IS_TIM3_OUTPUT_STATE(TIM3_OutputState));
    589            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
    590            assert_param(IS_TIM3_OCIDLE_STATE(TIM3_OCIdleState));
    591          
    592            tmpccmr1 = TIM3->CCMR1;
    593          
    594            /* Disable the Channel 1: Reset the CCE Bit */
    595            TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    596            /* Reset the Output Compare Bits */
    597            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    598          
    599            /* Set the Output Compare Mode */
    600            tmpccmr1 |= (uint8_t)TIM3_OCMode;
    601          
    602            TIM3->CCMR1 = tmpccmr1;
    603          
    604            /* Set the Output State */
    605            if (TIM3_OutputState == TIM3_OutputState_Enable)
    606            {
    607              TIM3->CCER1 |= TIM_CCER1_CC1E;
    608            }
    609            else
    610            {
    611              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    612            }
    613          
    614            /* Set the Output Polarity */
    615            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
    616            {
    617              TIM3->CCER1 |= TIM_CCER1_CC1P;
    618            }
    619            else
    620            {
    621              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
    622            }
    623          
    624            /* Set the Output Idle state */
    625            if (TIM3_OCIdleState == TIM3_OCIdleState_Set)
    626            {
    627              TIM3->OISR |= TIM_OISR_OIS1;
    628            }
    629            else
    630            {
    631              TIM3->OISR &= (uint8_t)(~TIM_OISR_OIS1);
    632            }
    633          
    634            /* Set the Pulse value */
    635            TIM3->CCR1H = (uint8_t)(TIM3_Pulse >> 8);
    636            TIM3->CCR1L = (uint8_t)(TIM3_Pulse);
    637          }
    638          
    639          /**
    640            * @brief  Initializes the TIM3 Channel2 according to the specified parameters.
    641            * @param  TIM3_OCMode: Output Compare Mode 
    642            *          This parameter can be one of the following values:
    643            *            @arg TIM3_OCMode_Timing: Timing (Frozen) Mode
    644            *            @arg TIM3_OCMode_Active: Active Mode
    645            *            @arg TIM3_OCMode_Inactive: Inactive Mode
    646            *            @arg TIM3_OCMode_Toggle: Toggle Mode
    647            *            @arg TIM3_OCMode_PWM1: PWM Mode 1
    648            *            @arg TIM3_OCMode_PWM2: PWM Mode 2          
    649            * @param  TIM3_OutputState: Output state
    650            *          This parameter can be one of the following values:
    651            *            @arg TIM3_OutputState_Disable: Output compare State disabled (channel output disabled)
    652            *            @arg TIM3_OutputState_Enable: Output compare State enabled (channel output enabled)
    653            * @param  TIM3_Pulse: This parameter must be a value between 0x0000 and 0xFFFF.
    654            * @param  TIM3_OCPolarity: Polarity
    655            *          This parameter can be one of the following values:
    656            *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
    657            *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
    658            * @param  TIM3_OCIdleState: Output Compare Idle State
    659            *          This parameter can be one of the following values:
    660            *            @arg TIM3_OCIdleState_Reset: Output Compare Idle state  = Reset
    661            *            @arg TIM3_OCIdleState_Set: Output Compare Idle state  = Set
    662            * @retval None
    663            */
    664          void TIM3_OC2Init(TIM3_OCMode_T TIM3_OCMode,
    665                            TIM3_OutputState_T TIM3_OutputState,
    666                            uint16_t TIM3_Pulse,
    667                            TIM3_OCPolarity_T TIM3_OCPolarity,
    668                            TIM3_OCIdleState_T TIM3_OCIdleState)
    669          {
    670            uint8_t tmpccmr2 = 0;
    671          
    672            /* Check the parameters */
    673            assert_param(IS_TIM3_OC_MODE(TIM3_OCMode));
    674            assert_param(IS_TIM3_OUTPUT_STATE(TIM3_OutputState));
    675            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
    676            assert_param(IS_TIM3_OCIDLE_STATE(TIM3_OCIdleState));
    677          
    678            tmpccmr2 = TIM3->CCMR2;
    679          
    680            /* Disable the Channel 2: Reset the CCE Bit */
    681            TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    682          
    683            /* Reset the Output Compare Bits */
    684            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    685          
    686            /* Set the Output Compare Mode */
    687            tmpccmr2 |= (uint8_t)TIM3_OCMode;
    688          
    689            TIM3->CCMR2 = tmpccmr2;
    690          
    691            /* Set the Output State */
    692            if (TIM3_OutputState == TIM3_OutputState_Enable)
    693            {
    694              TIM3->CCER1 |= TIM_CCER1_CC2E;
    695            }
    696            else
    697            {
    698              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    699            }
    700          
    701            /* Set the Output Polarity */
    702            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
    703            {
    704              TIM3->CCER1 |= TIM_CCER1_CC2P;
    705            }
    706            else
    707            {
    708              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P);
    709            }
    710          
    711          
    712            /* Set the Output Idle state */
    713            if (TIM3_OCIdleState == TIM3_OCIdleState_Set)
    714            {
    715              TIM3->OISR |= TIM_OISR_OIS2;
    716            }
    717            else
    718            {
    719              TIM3->OISR &= (uint8_t)(~TIM_OISR_OIS2);
    720            }
    721          
    722            /* Set the Pulse value */
    723            TIM3->CCR2H = (uint8_t)(TIM3_Pulse >> 8);
    724            TIM3->CCR2L = (uint8_t)(TIM3_Pulse);
    725          }
    726          
    727          /**
    728            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    729            *         and the AOE(automatic output enable).
    730            * @param  TIM3_OSSIState: Off-State Selection for Idle mode states.
    731            *          This parameter can be one of the following values:
    732            *            @arg TIM3_OSSIState_Enable: Off-State Selection for Idle mode enabled
    733            *            @arg TIM3_OSSIState_Disable: Off-State Selection for Idle mode disabled 
    734            * @param  TIM3_LockLevel: Lock level.
    735            *          This parameter can be one of the following values:
    736            *            @arg TIM3_LockLevel_Off: Lock option disabled
    737            *            @arg TIM3_LockLevel_1: Select Lock Level 1
    738            *            @arg TIM3_LockLevel_2: Select Lock Level 2
    739            *            @arg TIM3_LockLevel_3: Select Lock Level 3    
    740            * @param  TIM3_BreakState: Break Input enable/disable .
    741            *          This parameter can be one of the following values:
    742            *            @arg TIM3_BreakState_Disable: Break State disabled (break option disabled)
    743            *            @arg TIM3_BreakState_Enable: Break State enabled (break option enabled) 
    744            * @param  TIM3_BreakPolarity: Break Polarity.
    745            *          This parameter can be one of the following values:
    746            *            @arg TIM3_BreakPolarity_High: if Break, channel polarity = High
    747            *            @arg TIM3_BreakPolarity_Low: if Break, channel polarity = Low   
    748            * @param  TIM3_AutomaticOutput: TIM3 AOE Bit Set/Reset .
    749            *          This parameter can be one of the following values:
    750            *            @arg TIM3_AutomaticOutput_Enable: Automatic Output option enabled
    751            *            @arg TIM3_AutomaticOutput_Disable: Automatic Output option disabled
    752            * @retval None
    753            */
    754          void TIM3_BKRConfig(TIM3_OSSIState_T TIM3_OSSIState,
    755                              TIM3_LockLevel_T TIM3_LockLevel,
    756                              TIM3_BreakState_T TIM3_BreakState,
    757                              TIM3_BreakPolarity_T TIM3_BreakPolarity,
    758                              TIM3_AutomaticOutput_T TIM3_AutomaticOutput)
    759          
    760          {
    761            /* Check the parameters */
    762            assert_param(IS_TIM3_OSSI_STATE(TIM3_OSSIState));
    763            assert_param(IS_TIM3_LOCK_LEVEL(TIM3_LockLevel));
    764            assert_param(IS_TIM3_BREAK_STATE(TIM3_BreakState));
    765            assert_param(IS_TIM3_BREAK_POLARITY(TIM3_BreakPolarity));
    766            assert_param(IS_TIM3_AUTOMATIC_OUTPUT_STATE(TIM3_AutomaticOutput));
    767          
    768          
    769          
    770            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    771            the dead time value and the Automatic Output Enable Bit */
    772            TIM3->BKR = (uint8_t)((uint8_t)((uint8_t)((uint8_t)((uint8_t)TIM3_OSSIState | (uint8_t)TIM3_LockLevel) | \
    773                                            (uint8_t)((uint8_t)TIM3_BreakState | (uint8_t)TIM3_BreakPolarity)) | \
    774                                            TIM3_AutomaticOutput));
    775          }
    776          
    777          /**
    778            * @brief  Enables or disables the TIM3 peripheral Main Outputs.
    779            * @param  NewState: The new state of the TIM3 peripheral.
    780            *          This parameter can be ENABLE or DISABLE
    781            * @retval None
    782            */
    783          void TIM3_CtrlPWMOutputs(FunctionalState NewState)
    784          {
    785            /* Check the parameters */
    786            assert_param(IS_FUNCTIONAL_STATE(NewState));
    787          
    788            /* Set or Reset the MOE Bit */
    789          
    790            if (NewState != DISABLE)
    791            {
    792              TIM3->BKR |= TIM_BKR_MOE ;
    793            }
    794            else
    795            {
    796              TIM3->BKR &= (uint8_t)(~TIM_BKR_MOE) ;
    797            }
    798          }
    799          
    800          /**
    801            * @brief  Selects the TIM3 Output Compare Mode. This function disables the
    802            *         selected channel before changing the Output Compare Mode. User has to
    803            *         enable this channel using TIM3_CCxCmd and TIM3_CCxNCmd functions.
    804            * @param  TIM3_Channel: Specifies the TIM3 Channel.
    805            *          This parameter can be one of the following values:
    806            *            @arg TIM3_Channel_1: Channel 1
    807            *            @arg TIM3_Channel_2: Channel 2  
    808            * @param  TIM3_OCMode: Specifies the TIM3 Output Compare Mode.
    809            *          This parameter can be one of the following values:
    810            *            @arg TIM3_OCMode_Timing: Timing (Frozen) Mode
    811            *            @arg TIM3_OCMode_Active: Active Mode
    812            *            @arg TIM3_OCMode_Inactive: Inactive Mode
    813            *            @arg TIM3_OCMode_Toggle: Toggle Mode
    814            *            @arg TIM3_OCMode_PWM1: PWM Mode 1
    815            *            @arg TIM3_OCMode_PWM2: PWM Mode 2    
    816            * @retval None
    817            */
    818          void TIM3_SelectOCxM(TIM3_Channel_T TIM3_Channel,
    819                               TIM3_OCMode_T TIM3_OCMode)
    820          {
    821            /* Check the parameters */
    822            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
    823            assert_param(IS_TIM3_OCM(TIM3_OCMode));
    824          
    825            if (TIM3_Channel == TIM3_Channel_1)
    826            {
    827              /* Disable the Channel 1: Reset the CCE Bit */
    828              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E);
    829          
    830              /* Reset the Output Compare Bits */
    831              TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCM);
    832          
    833              /* Set the Output Compare Mode */
    834              TIM3->CCMR1 |= (uint8_t)TIM3_OCMode;
    835            }
    836            else /* if (TIM3_Channel == TIM3_Channel_2) */
    837            {
    838              /* Disable the Channel 2: Reset the CCE Bit */
    839              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E);
    840          
    841              /* Reset the Output Compare Bits */
    842              TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCM);
    843          
    844              /* Set the Output Compare Mode */
    845              TIM3->CCMR2 |= (uint8_t)TIM3_OCMode;
    846            }
    847          }
    848          
    849          /**
    850            * @brief  Sets the TIM3 Capture Compare1 Register value.
    851            * @param  Compare: Specifies the Capture Compare1 register new value.
    852            *         This parameter is between 0x0000 and 0xFFFF.
    853            * @retval None
    854            */
    855          void TIM3_SetCompare1(uint16_t Compare)
    856          {
    857            /* Set the Capture Compare1 Register value */
    858            TIM3->CCR1H = (uint8_t)(Compare >> 8);
    859            TIM3->CCR1L = (uint8_t)(Compare);
    860          }
    861          
    862          /**
    863            * @brief  Sets the TIM3 Capture Compare2 Register value.
    864            * @param  Compare: Specifies the Capture Compare2 register new value.
    865            *         This parameter is between 0x0000 and 0xFFFF.
    866            * @retval None
    867            */
    868          void TIM3_SetCompare2(uint16_t Compare)
    869          {
    870            /* Set the Capture Compare2 Register value */
    871            TIM3->CCR2H = (uint8_t)(Compare >> 8);
    872            TIM3->CCR2L = (uint8_t)(Compare);
    873          }
    874          
    875          /**
    876            * @brief  Forces the TIM3 Channel1 output waveform to active or inactive level.
    877            * @param  TIM3_ForcedAction: Specifies the forced Action to be set to the output waveform.
    878            *          This parameter can be one of the following values:
    879            *            @arg TIM3_ForcedAction_Active: Output Reference is forced low 
    880            *            @arg TIM3_ForcedAction_Inactive: Output Reference is forced high 
    881            * @retval None
    882            */
    883          void TIM3_ForcedOC1Config(TIM3_ForcedAction_T TIM3_ForcedAction)
    884          {
    885            uint8_t tmpccmr1 = 0;
    886          
    887            /* Check the parameters */
    888            assert_param(IS_TIM3_FORCED_ACTION(TIM3_ForcedAction));
    889          
    890            tmpccmr1 = TIM3->CCMR1;
    891          
    892            /* Reset the OCM Bits */
    893            tmpccmr1 &= (uint8_t)(~TIM_CCMR_OCM);
    894          
    895            /* Configure The Forced output Mode */
    896            tmpccmr1 |= (uint8_t)TIM3_ForcedAction;
    897          
    898            TIM3->CCMR1 = tmpccmr1;
    899          }
    900          
    901          /**
    902            * @brief  Forces the TIM3 Channel2 output waveform to active or inactive level.
    903            * @param  TIM3_ForcedAction: Specifies the forced Action to be set to the output waveform.
    904            *          This parameter can be one of the following values:
    905            *            @arg TIM3_ForcedAction_Active: Output Reference is forced low 
    906            *            @arg TIM3_ForcedAction_Inactive: Output Reference is forced high 
    907            * @retval None
    908            */
    909          void TIM3_ForcedOC2Config(TIM3_ForcedAction_T TIM3_ForcedAction)
    910          {
    911            uint8_t tmpccmr2 = 0;
    912          
    913            /* Check the parameters */
    914            assert_param(IS_TIM3_FORCED_ACTION(TIM3_ForcedAction));
    915          
    916            tmpccmr2 = TIM3->CCMR2;
    917          
    918            /* Reset the OCM Bits */
    919            tmpccmr2 &= (uint8_t)(~TIM_CCMR_OCM);
    920          
    921            /* Configure The Forced output Mode */
    922            tmpccmr2 |= (uint8_t)TIM3_ForcedAction;
    923          
    924            TIM3->CCMR2 = tmpccmr2;
    925          }
    926          
    927          /**
    928            * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR1.
    929            * @param  NewState: The new state of the Capture Compare Preload register.
    930            *          This parameter can be ENABLE or DISABLE
    931            * @retval None
    932            */
    933          void TIM3_OC1PreloadConfig(FunctionalState NewState)
    934          {
    935            /* Check the parameters */
    936            assert_param(IS_FUNCTIONAL_STATE(NewState));
    937          
    938            /* Set or Reset the OC1PE Bit */
    939            if (NewState != DISABLE)
    940            {
    941              TIM3->CCMR1 |= TIM_CCMR_OCxPE ;
    942            }
    943            else
    944            {
    945              TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
    946            }
    947          }
    948          
    949          /**
    950            * @brief  Enables or disables the TIM3 peripheral Preload Register on CCR2.
    951            * @param  NewState: The new state of the Capture Compare Preload register.
    952            *          This parameter can be ENABLE or DISABLE
    953            * @retval None
    954            */
    955          void TIM3_OC2PreloadConfig(FunctionalState NewState)
    956          {
    957            /* Check the parameters */
    958            assert_param(IS_FUNCTIONAL_STATE(NewState));
    959          
    960            /* Set or Reset the OC2PE Bit */
    961            if (NewState != DISABLE)
    962            {
    963              TIM3->CCMR2 |= TIM_CCMR_OCxPE ;
    964            }
    965            else
    966            {
    967              TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxPE) ;
    968            }
    969          }
    970          
    971          /**
    972            * @brief  Configures the TIM3 Capture Compare 1 Fast feature.
    973            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    974            *          This parameter can be ENABLE or DISABLE
    975            * @retval None
    976            */
    977          void TIM3_OC1FastConfig(FunctionalState NewState)
    978          {
    979            /* Check the parameters */
    980            assert_param(IS_FUNCTIONAL_STATE(NewState));
    981          
    982            /* Set or Reset the OC1FE Bit */
    983            if (NewState != DISABLE)
    984            {
    985              TIM3->CCMR1 |= TIM_CCMR_OCxFE ;
    986            }
    987            else
    988            {
    989              TIM3->CCMR1 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
    990            }
    991          }
    992          
    993          /**
    994            * @brief  Configures the TIM3 Capture Compare 2 Fast feature.
    995            * @param  NewState: The new state of the Output Compare Fast Enable bit.
    996            *          This parameter can be ENABLE or DISABLE
    997            * @retval None
    998            */
    999          
   1000          void TIM3_OC2FastConfig(FunctionalState NewState)
   1001          {
   1002            /* Check the parameters */
   1003            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1004          
   1005            /* Set or Reset the OC2FE Bit */
   1006            if (NewState != DISABLE)
   1007            {
   1008              TIM3->CCMR2 |= TIM_CCMR_OCxFE ;
   1009            }
   1010            else
   1011            {
   1012              TIM3->CCMR2 &= (uint8_t)(~TIM_CCMR_OCxFE) ;
   1013            }
   1014          }
   1015          
   1016          /**
   1017            * @brief  Configures the TIM3 Channel 1 polarity.
   1018            * @param  TIM3_OCPolarity: Specifies the OC1 Polarity.
   1019            *          This parameter can be one of the following values:
   1020            *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
   1021            *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
   1022            * @retval None
   1023            */
   1024          void TIM3_OC1PolarityConfig(TIM3_OCPolarity_T TIM3_OCPolarity)
   1025          {
   1026            /* Check the parameters */
   1027            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
   1028          
   1029            /* Set or Reset the CC1P Bit */
   1030            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
   1031            {
   1032              TIM3->CCER1 |= TIM_CCER1_CC1P ;
   1033            }
   1034            else
   1035            {
   1036              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   1037            }
   1038          }
   1039          
   1040          /**
   1041            * @brief  Configures the TIM3 Channel 2 polarity.
   1042            * @param  TIM3_OCPolarity: Specifies the OC2 Polarity.
   1043            *          This parameter can be one of the following values:
   1044            *            @arg TIM3_OCPolarity_High: Output compare polarity  = High
   1045            *            @arg TIM3_OCPolarity_Low: Output compare polarity  = Low 
   1046            * @retval None
   1047            */
   1048          void TIM3_OC2PolarityConfig(TIM3_OCPolarity_T TIM3_OCPolarity)
   1049          {
   1050            /* Check the parameters */
   1051            assert_param(IS_TIM3_OC_POLARITY(TIM3_OCPolarity));
   1052          
   1053            /* Set or Reset the CC2P Bit */
   1054            if (TIM3_OCPolarity == TIM3_OCPolarity_Low)
   1055            {
   1056              TIM3->CCER1 |= TIM_CCER1_CC2P ;
   1057            }
   1058            else
   1059            {
   1060              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   1061            }
   1062          }
   1063          
   1064          /**
   1065            * @brief  Enables or disables the TIM3 Capture Compare Channel x.
   1066            * @param  TIM3_Channel: Specifies the TIM3 Channel.
   1067            *          This parameter can be one of the following values:
   1068            *            @arg TIM3_Channel_1: Channel 1
   1069            *            @arg TIM3_Channel_2: Channel 2  
   1070            * @param  NewState: Specifies the TIM3 Channel CCxE bit new state.
   1071            *          This parameter can be ENABLE or DISABLE
   1072            * @retval None
   1073            */
   1074          void TIM3_CCxCmd(TIM3_Channel_T TIM3_Channel,
   1075                           FunctionalState NewState)
   1076          {
   1077            /* Check the parameters */
   1078            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
   1079            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1080          
   1081            if (TIM3_Channel == TIM3_Channel_1)
   1082            {
   1083              /* Set or Reset the CC1E Bit */
   1084              if (NewState != DISABLE)
   1085              {
   1086                TIM3->CCER1 |= TIM_CCER1_CC1E ;
   1087              }
   1088              else
   1089              {
   1090                TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1E) ;
   1091              }
   1092          
   1093            }
   1094            else /* if (TIM3_Channel == TIM3_Channel_2) */
   1095            {
   1096              /* Set or Reset the CC2E Bit */
   1097              if (NewState != DISABLE)
   1098              {
   1099                TIM3->CCER1 |= TIM_CCER1_CC2E;
   1100              }
   1101              else
   1102              {
   1103                TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2E) ;
   1104              }
   1105            }
   1106          }
   1107          
   1108          /** @defgroup TIM3_Group3 Input Capture management functions
   1109           *  @brief    Input Capture management functions 
   1110           *
   1111          @verbatim   
   1112           ===============================================================================
   1113                                Input Capture management functions
   1114           ===============================================================================  
   1115             
   1116                 ===================================================================      
   1117                        TIM3 Driver: how to use it in Input Capture Mode
   1118                 =================================================================== 
   1119                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1120                 
   1121                 1. Enable TIM3 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM3, ENABLE) function.
   1122                 
   1123                 2. Configure the TIM3 pins in input mode by configuring the corresponding GPIO pins
   1124                 
   1125                 3. Configure the Time base unit as described in the first part of this driver, if needed,
   1126                    otherwise the Timer will run with the default configuration:
   1127                    - Autoreload value = 0xFFFF
   1128                    - Prescaler value = 0x0
   1129                    - Counter mode = Up counting
   1130                 
   1131                 4. Call TIM3_ICInit() to configure the desired channel to measure only 
   1132                    frequency or duty cycle of the input signal using the corresponding configuration: 
   1133                    - TIM3 Channel: TIM3_Channel
   1134                    - TIM3 Input Capture polarity: TIM3_ICPolarity
   1135                    - TIM3 Input Capture selection: TIM3_ICSelection
   1136                    - TIM3 Input Capture Prescaler: TIM3_ICPSC
   1137                    - TIM3 Input Capture filter value
   1138                    or,
   1139                    Call TIM3_PWMIConfig() to configure the desired channels with the 
   1140                    corresponding configuration and to measure the frequency and the duty
   1141                    cycle of the input signal.
   1142                    
   1143                 5. Enable global interrupts or the DMA to read the measured frequency. 
   1144                    
   1145                 6. Enable the corresponding interrupt (or DMA request) to read the captured value,
   1146                    using the function TIM3_ITConfig(TIM3_IT_CCx) (or TIM3_DMACmd(TIM3_DMASource_CCx))
   1147                 
   1148                 7. Call the TIM3_Cmd(ENABLE) function to enable the TIM3 counter.
   1149                 
   1150                 8. Use TIM3_GetCapturex() to read the captured value corresponding to
   1151                    channel x.
   1152                 
   1153                 Note1: All other functions can be used separately to modify, if needed,
   1154                    a specific feature of the Timer. 
   1155          
   1156          @endverbatim
   1157            * @{
   1158            */
   1159          
   1160          /**
   1161            * @brief  Initializes the TIM3 peripheral according to the specified parameters.
   1162            * @param  TIM3_Channel: TIM3 Channel
   1163            *          This parameter can be one of the following values:
   1164            *            @arg TIM3_Channel_1: Channel 1
   1165            *            @arg TIM3_Channel_2: Channel 2     
   1166            * @param  TIM3_ICPolarity: Input Capture Polarity
   1167            *          This parameter can be one of the following values:
   1168            *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
   1169            *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
   1170            * @param  TIM3_ICSelection: Input Capture Selection
   1171            *          This parameter can be one of the following values:
   1172            *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
   1173            *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1174            *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1175            * @param  TIM3_ICPrescaler: Input Capture Prescaler
   1176            *          This parameter can be one of the following values:
   1177            *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1178            *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1179            *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1180            *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1181            * @param  TIM3_ICFilter: This parameter must be a value between 0x00 and 0x0F.
   1182            * @retval None
   1183            */
   1184          void TIM3_ICInit(TIM3_Channel_T TIM3_Channel,
   1185                           TIM3_ICPolarity_T TIM3_ICPolarity,
   1186                           TIM3_ICSelection_T TIM3_ICSelection,
   1187                           TIM3_ICPSC_T TIM3_ICPrescaler,
   1188                           uint8_t TIM3_ICFilter)
   1189          {
   1190            /* Check the parameters */
   1191            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
   1192          
   1193            if (TIM3_Channel == TIM3_Channel_1)
   1194            {
   1195              /* TI1 Configuration */
   1196              TI1_Config(TIM3_ICPolarity, TIM3_ICSelection, TIM3_ICFilter);
   1197          
   1198              /* Set the Input Capture Prescaler value */
   1199              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
   1200            }
   1201            else /* if (TIM3_Channel == TIM3_Channel_2) */
   1202            {
   1203              /* TI2 Configuration */
   1204              TI2_Config(TIM3_ICPolarity, TIM3_ICSelection, TIM3_ICFilter);
   1205          
   1206              /* Set the Input Capture Prescaler value */
   1207              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
   1208            }
   1209          }
   1210          
   1211          /**
   1212            * @brief  Configures the TIM3 peripheral in PWM Input Mode according to the
   1213            *         specified parameters.
   1214            * @param  TIM3_Channel: TIM3 Channel
   1215            *          This parameter can be one of the following values:
   1216            *            @arg TIM3_Channel_1: Channel 1
   1217            *            @arg TIM3_Channel_2: Channel 2     
   1218            * @param  TIM3_ICPolarity: Input Capture Polarity
   1219            *          This parameter can be one of the following values:
   1220            *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
   1221            *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
   1222            * @param  TIM3_ICSelection: Input Capture Selection
   1223            *          This parameter can be one of the following values:
   1224            *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
   1225            *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   1226            *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   1227            * @param  TIM3_ICPrescaler: Input Capture Prescaler
   1228            *          This parameter can be one of the following values:
   1229            *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1230            *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1231            *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1232            *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1233            * @retval None
   1234            */
   1235          void TIM3_PWMIConfig(TIM3_Channel_T TIM3_Channel,
   1236                               TIM3_ICPolarity_T TIM3_ICPolarity,
   1237                               TIM3_ICSelection_T TIM3_ICSelection,
   1238                               TIM3_ICPSC_T TIM3_ICPrescaler,
   1239                               uint8_t TIM3_ICFilter)
   1240          {
   1241            uint8_t icpolarity = TIM3_ICPolarity_Rising;
   1242            uint8_t icselection = TIM3_ICSelection_DirectTI;
   1243          
   1244            /* Check the parameters */
   1245            assert_param(IS_TIM3_CHANNEL(TIM3_Channel));
   1246          
   1247            /* Select the Opposite Input Polarity */
   1248            if (TIM3_ICPolarity == TIM3_ICPolarity_Rising)
   1249            {
   1250              icpolarity = TIM3_ICPolarity_Falling;
   1251            }
   1252            else
   1253            {
   1254              icpolarity = TIM3_ICPolarity_Rising;
   1255            }
   1256          
   1257            /* Select the Opposite Input */
   1258            if (TIM3_ICSelection == TIM3_ICSelection_DirectTI)
   1259            {
   1260              icselection = TIM3_ICSelection_IndirectTI;
   1261            }
   1262            else
   1263            {
   1264              icselection = TIM3_ICSelection_DirectTI;
   1265            }
   1266          
   1267            if (TIM3_Channel == TIM3_Channel_1)
   1268            {
   1269              /* TI1 Configuration */
   1270              TI1_Config(TIM3_ICPolarity, TIM3_ICSelection,
   1271                         TIM3_ICFilter);
   1272          
   1273              /* Set the Input Capture Prescaler value */
   1274              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
   1275          
   1276              /* TI2 Configuration */
   1277              TI2_Config((TIM3_ICPolarity_T)icpolarity, (TIM3_ICSelection_T)icselection, TIM3_ICFilter);
   1278          
   1279              /* Set the Input Capture Prescaler value */
   1280              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
   1281            }
   1282            else
   1283            {
   1284              /* TI2 Configuration */
   1285              TI2_Config(TIM3_ICPolarity, TIM3_ICSelection,
   1286                         TIM3_ICFilter);
   1287          
   1288              /* Set the Input Capture Prescaler value */
   1289              TIM3_SetIC2Prescaler(TIM3_ICPrescaler);
   1290          
   1291              /* TI1 Configuration */
   1292              TI1_Config((TIM3_ICPolarity_T)icpolarity, (TIM3_ICSelection_T)icselection, TIM3_ICFilter);
   1293          
   1294              /* Set the Input Capture Prescaler value */
   1295              TIM3_SetIC1Prescaler(TIM3_ICPrescaler);
   1296            }
   1297          }
   1298          
   1299          /**
   1300            * @brief  Gets the TIM3 Input Capture 1 value.
   1301            * @param  None
   1302            * @retval Capture Compare 1 Register value.
   1303            */
   1304          uint16_t TIM3_GetCapture1(void)
   1305          {
   1306            uint16_t tmpccr1 = 0;
   1307            uint8_t tmpccr1l, tmpccr1h;
   1308          
   1309            tmpccr1h = TIM3->CCR1H;
   1310            tmpccr1l = TIM3->CCR1L;
   1311          
   1312            tmpccr1 = (uint16_t)(tmpccr1l);
   1313            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   1314            /* Get the Capture 1 Register value */
   1315            return ((uint16_t)tmpccr1);
   1316          }
   1317          
   1318          /**
   1319            * @brief  Gets the TIM3 Input Capture 2 value.
   1320            * @param  None
   1321            * @retval Capture Compare 2 Register value.
   1322            */
   1323          uint16_t TIM3_GetCapture2(void)
   1324          {
   1325            uint16_t tmpccr2 = 0;
   1326            uint8_t tmpccr2l, tmpccr2h;
   1327          
   1328            tmpccr2h = TIM3->CCR2H;
   1329            tmpccr2l = TIM3->CCR2L;
   1330          
   1331            tmpccr2 = (uint16_t)(tmpccr2l);
   1332            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   1333            /* Get the Capture 2 Register value */
   1334            return ((uint16_t)tmpccr2);
   1335          }
   1336          
   1337          /**
   1338            * @brief  Sets the TIM3 Input Capture 1 prescaler.
   1339            * @param  TIM3_IC1Prescaler: Specifies the Input Capture prescaler new value
   1340            *          This parameter can be one of the following values:
   1341            *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1342            *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1343            *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1344            *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1345            * @retval None
   1346            */
   1347          void TIM3_SetIC1Prescaler(TIM3_ICPSC_T TIM3_IC1Prescaler)
   1348          {
   1349            uint8_t tmpccmr1 = 0;
   1350          
   1351            /* Check the parameters */
   1352            assert_param(IS_TIM3_IC_PRESCALER(TIM3_IC1Prescaler));
   1353          
   1354            tmpccmr1 = TIM3->CCMR1;
   1355          
   1356            /* Reset the IC1PSC Bits */
   1357            tmpccmr1 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1358          
   1359            /* Set the IC1PSC value */
   1360            tmpccmr1 |= (uint8_t)TIM3_IC1Prescaler;
   1361          
   1362            TIM3->CCMR1 = tmpccmr1;
   1363          }
   1364          
   1365          /**
   1366            * @brief  Sets the TIM3 Input Capture 2 prescaler.
   1367            * @param  TIM3_IC2Prescaler: Specifies the Input Capture prescaler new value
   1368            *          This parameter can be one of the following values:
   1369            *            @arg TIM3_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1370            *            @arg TIM3_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1371            *            @arg TIM3_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1372            *            @arg TIM3_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events) 
   1373            * @retval None
   1374            */
   1375          void TIM3_SetIC2Prescaler(TIM3_ICPSC_T TIM3_IC2Prescaler)
   1376          {
   1377            uint8_t tmpccmr2 = 0;
   1378          
   1379            /* Check the parameters */
   1380            assert_param(IS_TIM3_IC_PRESCALER(TIM3_IC2Prescaler));
   1381          
   1382            tmpccmr2 = TIM3->CCMR2;
   1383          
   1384            /* Reset the IC2PSC Bits */
   1385            tmpccmr2 &= (uint8_t)(~TIM_CCMR_ICxPSC);
   1386          
   1387            /* Set the IC2PSC value */
   1388            tmpccmr2 |= (uint8_t)TIM3_IC2Prescaler;
   1389          
   1390            TIM3->CCMR2 = tmpccmr2;
   1391          }
   1392          
   1393          /**
   1394            * @}
   1395            */
   1396          
   1397          /** @defgroup TIM3_Group4 Interrupts DMA and flags management functions
   1398           *  @brief    Interrupts, DMA and flags management functions 
   1399           *
   1400          @verbatim   
   1401           ===============================================================================
   1402                           Interrupts, DMA and flags management functions
   1403           ===============================================================================  
   1404          
   1405          @endverbatim
   1406            * @{
   1407            */
   1408          
   1409          /**
   1410            * @brief  Enables or disables the specified TIM3 interrupts.
   1411            * @param  TIM3_IT: Specifies the TIM3 interrupts sources to be enabled or disabled.
   1412            *          This parameter can be any combination of the following values:
   1413            *            @arg TIM3_IT_Update: Update
   1414            *            @arg TIM3_IT_CC1: Capture Compare Channel1
   1415            *            @arg TIM3_IT_CC2: Capture Compare Channel2 
   1416            *            @arg TIM3_IT_Trigger: Trigger 
   1417            *            @arg TIM3_IT_Break: Break  
   1418            * @param  NewState: The new state of the TIM3 peripheral.
   1419            *          This parameter can be ENABLE or DISABLE
   1420            * @retval None
   1421            */
   1422          void TIM3_ITConfig(TIM3_IT_T TIM3_IT, FunctionalState NewState)
   1423          {
   1424            /* Check the parameters */
   1425            assert_param(IS_TIM3_IT(TIM3_IT));
   1426            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1427          
   1428            if (NewState != DISABLE)
   1429            {
   1430              /* Enable the Interrupt sources */
   1431              TIM3->IER |= (uint8_t)TIM3_IT;
   1432            }
   1433            else
   1434            {
   1435              /* Disable the Interrupt sources */
   1436              TIM3->IER &= (uint8_t)(~(uint8_t)TIM3_IT);
   1437            }
   1438          }
   1439          
   1440          /**
   1441            * @brief  Configures the TIM3 event to be generated by software.
   1442            * @param  TIM3_EventSource: Specifies the event source.
   1443            *          This parameter can be any combination of the following values:
   1444            *            @arg TIM3_EventSource_Update: Update
   1445            *            @arg TIM3_EventSource_CC1: Capture Compare Channel1
   1446            *            @arg TIM3_EventSource_CC2: Capture Compare Channel2 
   1447            *            @arg TIM3_EventSource_Trigger: Trigger 
   1448            *            @arg TIM3_EventSource_Break: Break  
   1449            * @retval None
   1450            */
   1451          void TIM3_GenerateEvent(TIM3_EventSource_T TIM3_EventSource)
   1452          {
   1453            /* Check the parameters */
   1454            assert_param(IS_TIM3_EVENT_SOURCE((uint8_t)TIM3_EventSource));
   1455          
   1456            /* Set the event sources */
   1457            TIM3->EGR |= (uint8_t)TIM3_EventSource;
   1458          }
   1459          
   1460          /**
   1461            * @brief  Checks whether the specified TIM3 flag is set or not.
   1462            * @param  TIM3_FLAG: Specifies the flag to check.
   1463            *          This parameter can be any combination of the following values:
   1464            *            @arg TIM3_FLAG_Update: Update
   1465            *            @arg TIM3_FLAG_CC1: Capture Compare Channel1
   1466            *            @arg TIM3_FLAG_CC2: Capture Compare Channel2 
   1467            *            @arg TIM3_FLAG_Trigger: Trigger 
   1468            *            @arg TIM3_FLAG_Break: Break  
   1469            *            @arg TIM3_FLAG_CC1OF: Capture compare 1 over capture
   1470            *            @arg TIM3_FLAG_CC2OF: Capture compare 2 over capture   
   1471            * @retval FlagStatus: The new state of TIM3_FLAG (SET or RESET)
   1472            */
   1473          FlagStatus TIM3_GetFlagStatus(TIM3_FLAG_T TIM3_FLAG)
   1474          {
   1475            FlagStatus bitstatus = RESET;
   1476            uint8_t tim3_flag_l = 0, tim3_flag_h = 0;
   1477          
   1478            /* Check the parameters */
   1479            assert_param(IS_TIM3_GET_FLAG(TIM3_FLAG));
   1480          
   1481            tim3_flag_l = (uint8_t)(TIM3->SR1 & (uint8_t)(TIM3_FLAG));
   1482            tim3_flag_h = (uint8_t)(TIM3->SR2 & (uint8_t)((uint16_t)TIM3_FLAG >> 8));
   1483          
   1484            if ((uint8_t)(tim3_flag_l | tim3_flag_h) != 0)
   1485            {
   1486              bitstatus = SET;
   1487            }
   1488            else
   1489            {
   1490              bitstatus = RESET;
   1491            }
   1492            return ((FlagStatus)bitstatus);
   1493          }
   1494          
   1495          /**
   1496            * @brief  Clears the TIM�s pending flags.
   1497            * @param  TIM3_FLAG: Specifies the flag to clear.
   1498            *          This parameter can be any combination of the following values:
   1499            *            @arg TIM3_FLAG_Update: Update
   1500            *            @arg TIM3_FLAG_CC1: Capture Compare Channel1
   1501            *            @arg TIM3_FLAG_CC2: Capture Compare Channel2 
   1502            *            @arg TIM3_FLAG_Trigger: Trigger 
   1503            *            @arg TIM3_FLAG_Break: Break  
   1504            * @retval None
   1505            */
   1506          void TIM3_ClearFlag(TIM3_FLAG_T TIM3_FLAG)
   1507          {
   1508            /* Check the parameters */
   1509            assert_param(IS_TIM3_CLEAR_FLAG((uint16_t)TIM3_FLAG));
   1510            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing �1� has no effect*/
   1511            TIM3->SR1 = (uint8_t)(~(uint8_t)(TIM3_FLAG));
   1512            TIM3->SR2 = (uint8_t)(~(uint8_t)((uint16_t)TIM3_FLAG >> 8));
   1513          }
   1514          
   1515          /**
   1516            * @brief  Checks whether the TIM3 interrupt has occurred or not.
   1517            * @param  TIM3_IT: Specifies the TIM3 interrupt source to check.
   1518            *          This parameter can be any combination of the following values:
   1519            *            @arg TIM3_IT_Update: Update
   1520            *            @arg TIM3_IT_CC1: Capture Compare Channel1
   1521            *            @arg TIM3_IT_CC2: Capture Compare Channel2 
   1522            *            @arg TIM3_IT_Trigger: Trigger 
   1523            *            @arg TIM3_IT_Break: Break  
   1524            * @retval ITStatus: The new state of the TIM3_IT (SET or RESET)
   1525            */
   1526          ITStatus TIM3_GetITStatus(TIM3_IT_T TIM3_IT)
   1527          {
   1528            ITStatus bitstatus = RESET;
   1529          
   1530            uint8_t TIM3_itStatus = 0x0, TIM3_itEnable = 0x0;
   1531          
   1532            /* Check the parameters */
   1533            assert_param(IS_TIM3_GET_IT(TIM3_IT));
   1534          
   1535            TIM3_itStatus = (uint8_t)(TIM3->SR1 & (uint8_t)TIM3_IT);
   1536          
   1537            TIM3_itEnable = (uint8_t)(TIM3->IER & (uint8_t)TIM3_IT);
   1538          
   1539            if ((TIM3_itStatus != (uint8_t)RESET ) && (TIM3_itEnable != (uint8_t)RESET))
   1540            {
   1541              bitstatus = (ITStatus)SET;
   1542            }
   1543            else
   1544            {
   1545              bitstatus = (ITStatus)RESET;
   1546            }
   1547            return ((ITStatus)bitstatus);
   1548          }
   1549          
   1550          /**
   1551            * @brief  Clears the TIM's interrupt pending bits.
   1552            * @param  TIM3_IT: Specifies the pending bit to clear.
   1553            *          This parameter can be any combination of the following values:
   1554            *            @arg TIM3_IT_Update: Update
   1555            *            @arg TIM3_IT_CC1: Capture Compare Channel1
   1556            *            @arg TIM3_IT_CC2: Capture Compare Channel2 
   1557            *            @arg TIM3_IT_Trigger: Trigger 
   1558            *            @arg TIM3_IT_Break: Break  
   1559            * @retval None
   1560            */
   1561          void TIM3_ClearITPendingBit(TIM3_IT_T TIM3_IT)
   1562          {
   1563            /* Check the parameters */
   1564            assert_param(IS_TIM3_IT(TIM3_IT));
   1565          
   1566            /* Clear the IT pending Bit */
   1567            TIM3->SR1 = (uint8_t)(~(uint8_t)TIM3_IT);
   1568          }
   1569          
   1570          /**
   1571            * @brief  Enables or disables the TIM3 DMA Requests.
   1572            * @param  TIM3_DMASource: specifies the DMA Request sources.
   1573            *          This parameter can be any combination of the following values:
   1574            *            @arg TIM3_DMASource_Update: TIM3 DMA Update Request
   1575            *            @arg TIM3_DMASource_CC1: TIM3 DMA CC1 Request
   1576            *            @arg TIM3_DMASource_CC2: TIM3 DMA CC2 Request 
   1577            * @param  NewState: new state of the DMA Request sources.
   1578            *          This parameter can be: ENABLE or DISABLE.
   1579            * @retval None
   1580            */
   1581          void TIM3_DMACmd( TIM3_DMASource_T TIM3_DMASource, FunctionalState NewState)
   1582          {
   1583            /* Check the parameters */
   1584            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1585            assert_param(IS_TIM3_DMA_SOURCE(TIM3_DMASource));
   1586          
   1587            if (NewState != DISABLE)
   1588            {
   1589              /* Enable the DMA sources */
   1590              TIM3->DER |= TIM3_DMASource;
   1591            }
   1592            else
   1593            {
   1594              /* Disable the DMA sources */
   1595              TIM3->DER &= (uint8_t)(~TIM3_DMASource);
   1596            }
   1597          }
   1598          
   1599          /**
   1600            * @brief  Selects the TIM3 peripheral Capture Compare DMA source.
   1601            * @param   NewState: new state of the Capture Compare DMA source.
   1602            *           This parameter can be: ENABLE or DISABLE.
   1603            * @retval None
   1604            */
   1605          void TIM3_SelectCCDMA(FunctionalState NewState)
   1606          {
   1607            /* Check the parameters */
   1608            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1609          
   1610            if (NewState != DISABLE)
   1611            {
   1612              /* Set the CCDS Bit */
   1613              TIM3->CR2 |= TIM_CR2_CCDS;
   1614            }
   1615            else
   1616            {
   1617              /* Reset the CCDS Bit */
   1618              TIM3->CR2 &= (uint8_t)(~TIM_CR2_CCDS);
   1619            }
   1620          }
   1621          
   1622          /**
   1623            * @}
   1624            */
   1625          
   1626          /** @defgroup TIM3_Group5 Clocks management functions
   1627           *  @brief    Clocks management functions
   1628           *
   1629          @verbatim   
   1630           ===============================================================================
   1631                                   Clocks management functions
   1632           ===============================================================================  
   1633          
   1634          @endverbatim
   1635            * @{
   1636            */
   1637          
   1638          /**
   1639            * @brief  Enables the TIM3 internal Clock.
   1640            * @par Parameters:
   1641            * None
   1642            * @retval None
   1643            */
   1644          void TIM3_InternalClockConfig(void)
   1645          {
   1646            /* Disable slave mode to clock the prescaler directly with the internal clock */
   1647            TIM3->SMCR &=  (uint8_t)(~TIM_SMCR_SMS);
   1648          }
   1649          
   1650          /**
   1651            * @brief  Configures the TIM3 Trigger as External Clock.
   1652            * @param  TIM3_TIxExternalCLKSource: Specifies Trigger source.
   1653            *          This parameter can be one of the following values:
   1654            *            @arg TIM3_TIxExternalCLK1Source_TI1ED: External Clock mode 1 source = TI1ED
   1655            *            @arg TIM3_TIxExternalCLK1Source_TI1: External Clock mode 1 source = TI1 
   1656            *            @arg TIM3_TIxExternalCLK1Source_TI2: External Clock mode 1 source = TI2  
   1657            * @param  TIM3_ICPolarity: Specifies the TIx Polarity.
   1658            *          This parameter can be one of the following values:
   1659            *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
   1660            *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
   1661            * @param  ICFilter: Specifies the filter value.
   1662            *          This parameter must be a value between 0x00 and 0x0F
   1663            * @retval None
   1664            */
   1665          void TIM3_TIxExternalClockConfig(TIM3_TIxExternalCLK1Source_T TIM3_TIxExternalCLKSource,
   1666                                           TIM3_ICPolarity_T TIM3_ICPolarity,
   1667                                           uint8_t ICFilter)
   1668          {
   1669            /* Check the parameters */
   1670            assert_param(IS_TIM3_TIXCLK_SOURCE(TIM3_TIxExternalCLKSource));
   1671            assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
   1672            assert_param(IS_TIM3_IC_FILTER(ICFilter));
   1673          
   1674            /* Configure the TIM3 Input Clock Source */
   1675            if (TIM3_TIxExternalCLKSource == TIM3_TIxExternalCLK1Source_TI2)
   1676            {
   1677              TI2_Config(TIM3_ICPolarity, TIM3_ICSelection_DirectTI, ICFilter);
   1678            }
   1679            else
   1680            {
   1681              TI1_Config(TIM3_ICPolarity, TIM3_ICSelection_DirectTI, ICFilter);
   1682            }
   1683          
   1684            /* Select the Trigger source */
   1685            TIM3_SelectInputTrigger((TIM3_TRGSelection_T)TIM3_TIxExternalCLKSource);
   1686          
   1687            /* Select the External clock mode1 */
   1688            TIM3->SMCR |= (uint8_t)(TIM3_SlaveMode_External1);
   1689          }
   1690          
   1691          /**
   1692            * @brief  Configures the TIM3 External clock Mode1.
   1693            * @param  TIM3_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1694            *          This parameter can be one of the following values:
   1695            *            @arg TIM3_ExtTRGPSC_OFF: No External Trigger prescaler
   1696            *            @arg TIM3_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1697            *            @arg TIM3_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1698            *            @arg TIM3_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)   
   1699            * @param  TIM3_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1700            *          This parameter can be one of the following values:
   1701            *            @arg TIM3_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1702            *            @arg TIM3_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1703            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1704            *          This parameter must be a value between 0x00 and 0x0F
   1705            * @retval None
   1706            */
   1707          void TIM3_ETRClockMode1Config(TIM3_ExtTRGPSC_T TIM3_ExtTRGPrescaler,
   1708                                        TIM3_ExtTRGPolarity_T TIM3_ExtTRGPolarity,
   1709                                        uint8_t ExtTRGFilter)
   1710          {
   1711            /* Configure the ETR Clock source */
   1712            TIM3_ETRConfig(TIM3_ExtTRGPrescaler, TIM3_ExtTRGPolarity, ExtTRGFilter);
   1713          
   1714            /* Select the External clock mode1 */
   1715            TIM3->SMCR &= (uint8_t)(~TIM_SMCR_SMS);
   1716            TIM3->SMCR |= (uint8_t)(TIM3_SlaveMode_External1);
   1717          
   1718            /* Select the Trigger selection: ETRF */
   1719            TIM3->SMCR &= (uint8_t)(~TIM_SMCR_TS);
   1720            TIM3->SMCR |= (uint8_t)((TIM3_TRGSelection_T)TIM3_TRGSelection_ETRF);
   1721          }
   1722          
   1723          /**
   1724            * @brief  Configures the TIM3 External clock Mode2.
   1725            * @param  TIM3_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1726            *          This parameter can be one of the following values:
   1727            *            @arg TIM3_ExtTRGPSC_OFF: No External Trigger prescaler
   1728            *            @arg TIM3_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1729            *            @arg TIM3_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4) 
   1730            *            @arg TIM3_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8) 
   1731            * @param  TIM3_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1732            *          This parameter can be one of the following values:
   1733            *            @arg TIM3_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1734            *            @arg TIM3_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1735            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1736            *          This parameter must be a value between 0x00 and 0x0F
   1737            * @retval None
   1738            */
   1739          void TIM3_ETRClockMode2Config(TIM3_ExtTRGPSC_T TIM3_ExtTRGPrescaler,
   1740                                        TIM3_ExtTRGPolarity_T TIM3_ExtTRGPolarity,
   1741                                        uint8_t ExtTRGFilter)
   1742          {
   1743            /* Configure the ETR Clock source */
   1744            TIM3_ETRConfig(TIM3_ExtTRGPrescaler, TIM3_ExtTRGPolarity, ExtTRGFilter);
   1745          
   1746            /* Enable the External clock mode2 */
   1747            TIM3->ETR |= TIM_ETR_ECE ;
   1748          }
   1749          
   1750          /**
   1751            * @}
   1752            */
   1753          
   1754          /** @defgroup TIM3_Group6 Synchronization management functions
   1755           *  @brief    Synchronization management functions 
   1756           *
   1757          @verbatim   
   1758           ===============================================================================
   1759                                 Synchronization management functions
   1760           ===============================================================================  
   1761                             
   1762                 ===================================================================      
   1763                        TIM3 Driver: how to use it in synchronization Mode
   1764                 =================================================================== 
   1765                 Case of two/several Timers
   1766                 **************************
   1767                 1. If TIM3 is used as master to other timers use the following functions:
   1768                    - TIM3_SelectOutputTrigger()
   1769                    - TIM3_SelectMasterSlaveMode()
   1770                 2. If TIM3 is used as slave to other timers use the following functions:
   1771                    - TIM3_SelectInputTrigger()
   1772                    - TIM3_SelectSlaveMode()
   1773                    
   1774                 Case of Timers and external trigger (TRIG pin)
   1775                 ********************************************       
   1776                 1. Configure the External trigger using TIM3_ETRConfig()
   1777                 2. Configure the Slave Timer using the following functions:
   1778                    - TIM3_SelectInputTrigger()
   1779                    - TIM3_SelectSlaveMode()
   1780          
   1781          @endverbatim
   1782            * @{
   1783            */
   1784          
   1785          /**
   1786            * @brief  Selects the TIM3 Input Trigger source.
   1787            * @param  TIM3_InputTriggerSource: Specifies Input Trigger source.
   1788            *          This parameter can be one of the following values:
   1789            *            @arg TIM3_TRGSelection_TIM4: TRIG Input source =  TIM TRIG Output
   1790            *            @arg TIM3_TRGSelection_TIM1: TRIG Input source =  TIM TRIG Output
   1791            *            @arg TIM3_TRGSelection_TIM3: TRIG Input source =  TIM TRIG Output
   1792            *            @arg TIM3_TRGSelection_TIM2: TRIG Input source =  TIM TRIG Output
   1793            *            @arg TIM3_TRGSelection_TI1F_ED: TRIG Input source = TI1F_ED (TI1 Edge Detector)
   1794            *            @arg TIM3_TRGSelection_TI1FP1: TRIG Input source = TI1FP1 (Filtered Timer Input 1)
   1795            *            @arg TIM3_TRGSelection_TI2FP2: TRIG Input source = TI2FP2 (Filtered Timer Input 2)
   1796            *            @arg TIM3_TRGSelection_ETRF: TRIG Input source =  ETRF (External Trigger Input )      
   1797            * @retval None
   1798            */
   1799          void TIM3_SelectInputTrigger(TIM3_TRGSelection_T TIM3_InputTriggerSource)
   1800          {
   1801            uint8_t tmpsmcr = 0;
   1802          
   1803            /* Check the parameters */
   1804            assert_param(IS_TIM3_TRIGGER_SELECTION(TIM3_InputTriggerSource));
   1805          
   1806            tmpsmcr = TIM3->SMCR;
   1807          
   1808            /* Select the Trigger Source */
   1809            tmpsmcr &= (uint8_t)(~TIM_SMCR_TS);
   1810            tmpsmcr |= (uint8_t)TIM3_InputTriggerSource;
   1811          
   1812            TIM3->SMCR = (uint8_t)tmpsmcr;
   1813          }
   1814          
   1815          /**
   1816            * @brief  Selects the TIM3 Trigger Output Mode.
   1817            * @param  TIM3_TRGOSource: Specifies the Trigger Output source.
   1818            *          This parameter can be one of the following values:
   1819            *            @arg TIM3_TRGOSource_Reset: Trigger Output source = Reset 
   1820            *            @arg TIM3_TRGOSource_Enable: Trigger Output source = TIM3 is enabled 
   1821            *            @arg TIM3_TRGOSource_Update: Trigger Output source = Update event
   1822            *            @arg TIM3_TRGOSource_OC1: Trigger Output source = output compare channel1
   1823            *            @arg TIM3_TRGOSource_OC1REF: Trigger Output source = output compare channel 1 reference
   1824            *            @arg TIM3_TRGOSource_OC2REF: Trigger Output source = output compare channel 2 reference   
   1825            * @retval None
   1826            */
   1827          void TIM3_SelectOutputTrigger(TIM3_TRGOSource_T TIM3_TRGOSource)
   1828          {
   1829            uint8_t tmpcr2 = 0;
   1830          
   1831            /* Check the parameters */
   1832            assert_param(IS_TIM3_TRGO_SOURCE(TIM3_TRGOSource));
   1833          
   1834            tmpcr2 = TIM3->CR2;
   1835          
   1836            /* Reset the MMS Bits */
   1837            tmpcr2 &= (uint8_t)(~TIM_CR2_MMS);
   1838          
   1839            /* Select the TRGO source */
   1840            tmpcr2 |=  (uint8_t)TIM3_TRGOSource;
   1841          
   1842            TIM3->CR2 = tmpcr2;
   1843          }
   1844          
   1845          /**
   1846            * @brief  Selects the TIM3 Slave Mode.
   1847            * @param  TIM3_SlaveMode: Specifies the TIM3 Slave Mode.
   1848            *          This parameter can be one of the following values:
   1849            *            @arg TIM3_SlaveMode_Reset: Slave Mode Selection  = Reset
   1850            *            @arg TIM3_SlaveMode_Gated: Slave Mode Selection  = Gated
   1851            *            @arg TIM3_SlaveMode_Trigger: Slave Mode Selection  = Trigger
   1852            *            @arg TIM3_SlaveMode_External1: Slave Mode Selection  = External 1  
   1853            * @retval None
   1854            */
   1855          void TIM3_SelectSlaveMode(TIM3_SlaveMode_T TIM3_SlaveMode)
   1856          {
   1857            uint8_t tmpsmcr = 0;
   1858          
   1859            /* Check the parameters */
   1860            assert_param(IS_TIM3_SLAVE_MODE(TIM3_SlaveMode));
   1861          
   1862            tmpsmcr = TIM3->SMCR;
   1863          
   1864            /* Reset the SMS Bits */
   1865            tmpsmcr &= (uint8_t)(~TIM_SMCR_SMS);
   1866          
   1867            /* Select the Slave Mode */
   1868            tmpsmcr |= (uint8_t)TIM3_SlaveMode;
   1869          
   1870            TIM3->SMCR = tmpsmcr;
   1871          }
   1872          
   1873          /**
   1874            * @brief  Sets or Resets the TIM3 Master/Slave Mode.
   1875            * @param  NewState: The new state of the synchronization between TIM3 and its slaves (through TRGO).
   1876            *          This parameter can be ENABLE or DISABLE
   1877            * @retval None
   1878            */
   1879          void TIM3_SelectMasterSlaveMode(FunctionalState NewState)
   1880          {
   1881            /* Check the parameters */
   1882            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1883          
   1884            /* Set or Reset the MSM Bit */
   1885            if (NewState != DISABLE)
   1886            {
   1887              TIM3->SMCR |= TIM_SMCR_MSM;
   1888            }
   1889            else
   1890            {
   1891              TIM3->SMCR &= (uint8_t)(~TIM_SMCR_MSM);
   1892            }
   1893          }
   1894          
   1895          /**
   1896            * @brief  Configures the TIM3 External Trigger.
   1897            * @param  TIM3_ExtTRGPrescaler: Specifies the external Trigger Prescaler.
   1898            *          This parameter can be one of the following values:
   1899            *            @arg TIM3_ExtTRGPSC_OFF: No External Trigger prescaler
   1900            *            @arg TIM3_ExtTRGPSC_DIV2: External Trigger prescaler = 2 (ETRP frequency divided by 2)
   1901            *            @arg TIM3_ExtTRGPSC_DIV4: External Trigger prescaler = 4 (ETRP frequency divided by 4)
   1902            *            @arg TIM3_ExtTRGPSC_DIV8: External Trigger prescaler = 8 (ETRP frequency divided by 8)    
   1903            * @param  TIM3_ExtTRGPolarity: Specifies the external Trigger Polarity.
   1904            *          This parameter can be one of the following values:
   1905            *            @arg TIM3_ExtTRGPolarity_Inverted: External Trigger Polarity = inverted
   1906            *            @arg TIM3_ExtTRGPolarity_NonInverted: External Trigger Polarity = non inverted
   1907            * @param  ExtTRGFilter: Specifies the External Trigger Filter.
   1908            *          This parameter must be a value between 0x00 and 0x0F
   1909            * @retval None
   1910            */
   1911          void TIM3_ETRConfig(TIM3_ExtTRGPSC_T TIM3_ExtTRGPrescaler,
   1912                              TIM3_ExtTRGPolarity_T TIM3_ExtTRGPolarity,
   1913                              uint8_t ExtTRGFilter)
   1914          {
   1915            /* Check the parameters */
   1916            assert_param(IS_TIM3_EXT_PRESCALER(TIM3_ExtTRGPrescaler));
   1917            assert_param(IS_TIM3_EXT_POLARITY(TIM3_ExtTRGPolarity));
   1918            assert_param(IS_TIM3_EXT_FILTER(ExtTRGFilter));
   1919          
   1920            /* Set the Prescaler, the Filter value and the Polarity */
   1921            TIM3->ETR |= (uint8_t)((uint8_t)((uint8_t)TIM3_ExtTRGPrescaler | (uint8_t)TIM3_ExtTRGPolarity)
   1922                                   | (uint8_t)ExtTRGFilter);
   1923          }
   1924          
   1925          /**
   1926            * @}
   1927            */
   1928          
   1929          /** @defgroup TIM3_Group7 Specific interface management functions
   1930           *  @brief    Specific interface management functions 
   1931           *
   1932          @verbatim   
   1933           ===============================================================================
   1934                              Specific interface management functions
   1935           ===============================================================================  
   1936          
   1937          @endverbatim
   1938            * @{
   1939            */
   1940          
   1941          /**
   1942            * @brief  Configures the TIM3 Encoder Interface.
   1943            * @param  TIM3_EncoderMode: Specifies the TIM3 Encoder Mode.
   1944            *          This parameter can be one of the following values:
   1945            *            @arg TIM3_EncoderMode_TI1: Encoder mode 1
   1946            *            @arg TIM3_EncoderMode_TI2: Encoder mode 2
   1947            *            @arg TIM3_EncoderMode_TI12: Encoder mode 3   
   1948            * @param  TIM3_IC1Polarity: Specifies the IC1 Polarity.
   1949            *          This parameter can be one of the following values:
   1950            *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
   1951            *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
   1952            * @param  TIM3_IC2Polarity: Specifies the IC2 Polarity.
   1953            *          This parameter can be one of the following values:
   1954            *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
   1955            *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
   1956            * @retval None
   1957            */
   1958          void TIM3_EncoderInterfaceConfig(TIM3_EncoderMode_T TIM3_EncoderMode,
   1959                                           TIM3_ICPolarity_T TIM3_IC1Polarity,
   1960                                           TIM3_ICPolarity_T TIM3_IC2Polarity)
   1961          {
   1962            uint8_t tmpsmcr = 0;
   1963            uint8_t tmpccmr1 = 0;
   1964            uint8_t tmpccmr2 = 0;
   1965          
   1966            /* Check the parameters */
   1967            assert_param(IS_TIM3_ENCODER_MODE(TIM3_EncoderMode));
   1968            assert_param(IS_TIM3_IC_POLARITY(TIM3_IC1Polarity));
   1969            assert_param(IS_TIM3_IC_POLARITY(TIM3_IC2Polarity));
   1970          
   1971            tmpsmcr = TIM3->SMCR;
   1972            tmpccmr1 = TIM3->CCMR1;
   1973            tmpccmr2 = TIM3->CCMR2;
   1974          
   1975            /* Set the encoder Mode */
   1976            tmpsmcr &= (uint8_t)(TIM_SMCR_MSM | TIM_SMCR_TS)  ;
   1977            tmpsmcr |= (uint8_t)TIM3_EncoderMode;
   1978          
   1979            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1980            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS);
   1981            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS);
   1982            tmpccmr1 |= TIM_CCMR_TIxDirect_Set;
   1983            tmpccmr2 |= TIM_CCMR_TIxDirect_Set;
   1984          
   1985            /* Set the TI1 and the TI2 Polarities */
   1986            if (TIM3_IC1Polarity == TIM3_ICPolarity_Falling)
   1987            {
   1988              TIM3->CCER1 |= TIM_CCER1_CC1P ;
   1989            }
   1990            else
   1991            {
   1992              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P) ;
   1993            }
   1994          
   1995            if (TIM3_IC2Polarity == TIM3_ICPolarity_Falling)
   1996            {
   1997              TIM3->CCER1 |= TIM_CCER1_CC2P ;
   1998            }
   1999            else
   2000            {
   2001              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   2002            }
   2003          
   2004            TIM3->SMCR = tmpsmcr;
   2005            TIM3->CCMR1 = tmpccmr1;
   2006            TIM3->CCMR2 = tmpccmr2;
   2007          }
   2008          
   2009          /**
   2010            * @brief  Enables or Disables the TIM�s Hall sensor interface.
   2011            * @param  NewState: The new state of the TIM3 Hall sensor interface.
   2012            *          This parameter can be ENABLE or DISABLE
   2013            * @retval None
   2014            */
   2015          void TIM3_SelectHallSensor(FunctionalState NewState)
   2016          {
   2017            /* Check the parameters */
   2018            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2019          
   2020            /* Set or Reset the TI1S Bit */
   2021            if (NewState != DISABLE)
   2022            {
   2023              TIM3->CR2 |= TIM_CR2_TI1S;
   2024            }
   2025            else
   2026            {
   2027              TIM3->CR2 &= (uint8_t)(~TIM_CR2_TI1S);
   2028            }
   2029          }
   2030          
   2031          /**
   2032            * @}
   2033            */
   2034          
   2035          /**
   2036            * @brief  Configure the TI1 as Input.
   2037            * @param  TIM3_ICPolarity: Input Capture Polarity
   2038            *          This parameter can be one of the following values:
   2039            *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
   2040            *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
   2041            * @param  TIM3_ICSelection: Specifies the input to be used.
   2042            *          This parameter can be one of the following values:
   2043            *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
   2044            *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2045            *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2046            * @param  TIM3_ICFilter: Specifies the Input Capture Filter.
   2047            *          This parameter must be a value between 0x00 and 0x0F.
   2048            * @retval None
   2049            */
   2050          static void TI1_Config(TIM3_ICPolarity_T TIM3_ICPolarity, \
   2051                                 TIM3_ICSelection_T TIM3_ICSelection, \
   2052                                 uint8_t TIM3_ICFilter)
   2053          {
   2054            uint8_t tmpccmr1 = 0;
   2055            uint8_t tmpicpolarity = TIM3_ICPolarity;
   2056            tmpccmr1 = TIM3->CCMR1;
   2057          
   2058            /* Check the parameters */
   2059            assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
   2060            assert_param(IS_TIM3_IC_SELECTION(TIM3_ICSelection));
   2061            assert_param(IS_TIM3_IC_FILTER(TIM3_ICFilter));
   2062          
   2063            /* Disable the Channel 1: Reset the CCE Bit */
   2064            TIM3->CCER1 &=  (uint8_t)(~TIM_CCER1_CC1E);
   2065          
   2066            /* Select the Input and set the filter */
   2067            tmpccmr1 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   2068            tmpccmr1 |= (uint8_t)(((uint8_t)(TIM3_ICSelection)) | ((uint8_t)(TIM3_ICFilter << 4)));
   2069          
   2070            TIM3->CCMR1 = tmpccmr1;
   2071          
   2072            /* Select the Polarity */
   2073            if (tmpicpolarity == (uint8_t)(TIM3_ICPolarity_Falling))
   2074            {
   2075              TIM3->CCER1 |= TIM_CCER1_CC1P;
   2076            }
   2077            else
   2078            {
   2079              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC1P);
   2080            }
   2081          
   2082            /* Set the CCE Bit */
   2083            TIM3->CCER1 |=  TIM_CCER1_CC1E;
   2084          }
   2085          
   2086          /**
   2087            * @brief  Configure the TI2 as Input.
   2088            * @param  TIM3_ICPolarity: Input Capture Polarity
   2089            *          This parameter can be one of the following values:
   2090            *            @arg TIM3_ICPolarity_Rising: Input Capture on Rising Edge
   2091            *            @arg TIM3_ICPolarity_Falling: Input Capture on Falling Edge  
   2092            * @param  TIM3_ICSelection: Specifies the input to be used.
   2093            *          This parameter can be one of the following values:
   2094            *            @arg TIM3_ICSelection_DirectTI: Input Capture mapped on the direct input
   2095            *            @arg TIM3_ICSelection_IndirectTI: Input Capture mapped on the indirect input
   2096            *            @arg TIM3_ICSelection_TRGI: Input Capture mapped on the Trigger Input   
   2097            * @param  TIM3_ICFilter: Specifies the Input Capture Filter.
   2098            *          This parameter must be a value between 0x00 and 0x0F.
   2099            * @retval None
   2100            */
   2101          static void TI2_Config(TIM3_ICPolarity_T TIM3_ICPolarity,
   2102                                 TIM3_ICSelection_T TIM3_ICSelection,
   2103                                 uint8_t TIM3_ICFilter)
   2104          {
   2105            uint8_t tmpccmr2 = 0;
   2106            uint8_t tmpicpolarity = TIM3_ICPolarity;
   2107          
   2108            /* Check the parameters */
   2109            assert_param(IS_TIM3_IC_POLARITY(TIM3_ICPolarity));
   2110            assert_param(IS_TIM3_IC_SELECTION(TIM3_ICSelection));
   2111            assert_param(IS_TIM3_IC_FILTER(TIM3_ICFilter));
   2112          
   2113            tmpccmr2 = TIM3->CCMR2;
   2114          
   2115            /* Disable the Channel 2: Reset the CCE Bit */
   2116            TIM3->CCER1 &=  (uint8_t)(~TIM_CCER1_CC2E);
   2117          
   2118            /* Select the Input and set the filter */
   2119            tmpccmr2 &= (uint8_t)(~TIM_CCMR_CCxS) & (uint8_t)(~TIM_CCMR_ICxF);
   2120            tmpccmr2 |= (uint8_t)(((uint8_t)(TIM3_ICSelection)) | ((uint8_t)(TIM3_ICFilter << 4)));
   2121          
   2122            TIM3->CCMR2 = tmpccmr2;
   2123          
   2124            /* Select the Polarity */
   2125            if (tmpicpolarity == TIM3_ICPolarity_Falling)
   2126            {
   2127              TIM3->CCER1 |= TIM_CCER1_CC2P ;
   2128            }
   2129            else
   2130            {
   2131              TIM3->CCER1 &= (uint8_t)(~TIM_CCER1_CC2P) ;
   2132            }
   2133          
   2134            /* Set the CCE Bit */
   2135            TIM3->CCER1 |=  TIM_CCER1_CC2E;
   2136          }
   2137          
   2138          /**
   2139            * @}
   2140            */ 
   2141          
   2142          /**
   2143            * @}
   2144            */ 
   2145            
   2146          /**
   2147            * @}
   2148            */
   2149          
   2150          /**
   2151            * @}
   2152            */
   2153          
   2154          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ??Subroutine15_0
       8  ??Subroutine16_0
      22  ?Subroutine0
      15  ?Subroutine1
      14  ?Subroutine10
      12  ?Subroutine11
      12  ?Subroutine12
       8  ?Subroutine13
       8  ?Subroutine14
      14  ?Subroutine2
       9  ?Subroutine3
      15  ?Subroutine4
       2  ?Subroutine5
       9  ?Subroutine6
      15  ?Subroutine7
       2  ?Subroutine8
      12  ?Subroutine9
      34  TI1_Config
      34  TI2_Config
      13  TIM3_ARRPreloadConfig
      16  TIM3_BKRConfig
      31  TIM3_CCxCmd
      13  TIM3_ClearFlag
       5  TIM3_ClearITPendingBit
      13  TIM3_Cmd
      13  TIM3_CounterModeConfig
      13  TIM3_CtrlPWMOutputs
      17  TIM3_DMACmd
     101  TIM3_DeInit
      30  TIM3_ETRClockMode1Config
       9  TIM3_ETRClockMode2Config
       5  TIM3_ETRConfig
      89  TIM3_EncoderInterfaceConfig
      13  TIM3_ForcedOC1Config
      13  TIM3_ForcedOC2Config
       7  TIM3_GenerateEvent
      13  TIM3_GetCapture1
      13  TIM3_GetCapture2
      13  TIM3_GetCounter
      38  TIM3_GetFlagStatus
      33  TIM3_GetITStatus
       4  TIM3_GetPrescaler
      83  TIM3_ICInit
      17  TIM3_ITConfig
       9  TIM3_InternalClockConfig
      13  TIM3_OC1FastConfig
      63  TIM3_OC1Init
      14  TIM3_OC1PolarityConfig
      13  TIM3_OC1PreloadConfig
      13  TIM3_OC2FastConfig
      63  TIM3_OC2Init
      14  TIM3_OC2PolarityConfig
      13  TIM3_OC2PreloadConfig
      88  TIM3_PWMIConfig
      19  TIM3_PrescalerConfig
      13  TIM3_SelectCCDMA
      13  TIM3_SelectHallSensor
      13  TIM3_SelectInputTrigger
      13  TIM3_SelectMasterSlaveMode
      45  TIM3_SelectOCxM
      14  TIM3_SelectOnePulseMode
      13  TIM3_SelectOutputTrigger
      13  TIM3_SelectSlaveMode
       5  TIM3_SetAutoreload
       7  TIM3_SetCompare1
       7  TIM3_SetCompare2
      14  TIM3_SetCounter
      13  TIM3_SetIC1Prescaler
      13  TIM3_SetIC2Prescaler
      81  TIM3_TIxExternalClockConfig
      32  TIM3_TimeBaseInit
      13  TIM3_UpdateDisableConfig
      14  TIM3_UpdateRequestConfig

 
 1 526 bytes in section .far_func.text
 
 1 526 bytes of CODE memory

Errors: none
Warnings: none
