###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:07
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_dma.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_dma.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_dma.lst
#    Object file  =  H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_dma.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides all the DMA firmware functions.
      8           * @brief   This file provides firmware functions to manage the following 
      9            *          functionalities of the Direct Memory Access controller (DMA):           
     10            *           - Initialization and Configuration
     11            *           - Data Counter
     12            *           - Interrupts and flags management
     13            *           
     14            *  @verbatim
     15            *      
     16            *          ===================================================================      
     17            *                                 How to use this driver
     18            *          =================================================================== 
     19            *          1. Enable The DMA controller clock using CLK_PeripheralClockConfig() 
     20            *            function: CLK_PeripheralClockConfig(CLK_Peripheral_DMA1, ENABLE).
     21            *
     22            *          2. Enable and configure the peripheral to be connected to the DMA 
     23            *            channel (except for internal SRAM / FLASH memories: no 
     24            *            initialization is necessary). 
     25            *        
     26            *          3. For a given Channel, program the Source and Destination 
     27            *             addresses, the transfer Direction, the Buffer Size, the 
     28            *             Peripheral and Memory Incrementation mode and Data Size, 
     29            *             the Circular or Normal mode, the channel transfer Priority 
     30            *             and the Memory-to-Memory transfer mode (for channel 3 only, 
     31            *             if needed) using the DMA_Init() function.
     32            *
     33            *          4. Enable the corresponding interrupt(s) using the function 
     34            *             DMA_ITConfig() if you need to use DMA interrupts. 
     35            *
     36            *          5. Enable the DMA channel using the DMA_Cmd() function. 
     37            *                
     38            *          6. Activate the needed channel Request using PPP_DMACmd() function 
     39            *            for any PPP peripheral except internal SRAM and FLASH (ie. TIM4, 
     40            *             USART ...). The function allowing this operation is provided in 
     41            *             each PPP peripheral driver (ie. TIM4_DMACmd for TIM4 peripheral).     
     42            *
     43            *          7. Optionally, you can configure the number of data to be 
     44            *             transferred when the channel is disabled (ie. after each 
     45            *             Transfer Complete event or when a Transfer Error occurs) using 
     46            *             the function DMA_SetCurrDataCounter().
     47            *             And you can get the number of remaining data to be transferred 
     48            *             using the function DMA_GetCurrDataCounter() at run time (when 
     49            *             the DMA channel is enabled and running).  
     50            *                   
     51            *          8. To control DMA events you can use one of the following 
     52            *              two methods:
     53            *               a- Check on DMA channel flags using the function 
     54            *                  DMA_GetFlagStatus().  
     55            *               b- Use DMA interrupts through the function DMA_ITConfig() 
     56            *                   at initialization phase and DMA_GetITStatus() function 
     57            *                   into interrupt routines in communication phase.  
     58            *              After checking on a flag you should clear it using 
     59            *              DMA_ClearFlag() function. And after checking on an interrupt 
     60            *              event you should clear it using DMA_ClearITPendingBit() 
     61            *              function.     
     62            *                 
     63            *  @endverbatim
     64            *                                  
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     69            *
     70            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     71            * You may not use this file except in compliance with the License.
     72            * You may obtain a copy of the License at:
     73            *
     74            *        http://www.st.com/software_license_agreement_liberty_v2
     75            *
     76            * Unless required by applicable law or agreed to in writing, software 
     77            * distributed under the License is distributed on an "AS IS" BASIS, 
     78            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     79            * See the License for the specific language governing permissions and
     80            * limitations under the License.
     81            *
     82            ******************************************************************************
     83            */ 
     84          
     85          /* Includes ------------------------------------------------------------------*/
     86          #include "stm8l15x_dma.h"
     87          
     88          /** @addtogroup STM8L15x_StdPeriph_Driver
     89            * @{
     90            */
     91          
     92          /** @defgroup DMA 
     93            * @brief  DMA driver modules
     94            * @{
     95            */ 
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          /* Private function prototypes -----------------------------------------------*/
    101          /* Private functions ---------------------------------------------------------*/
    102          
    103          /** @defgroup DMA_Private_Functions
    104            * @{
    105            */ 
    106          
    107          /** @defgroup DMA_Group1 Initialization and Configuration functions
    108           *  @brief   Initialization and Configuration functions
    109           *
    110          @verbatim   
    111           ===============================================================================
    112                           Initialization and Configuration functions
    113           ===============================================================================  
    114          
    115            This subsection provides functions allowing to initialize the DMA channel 
    116            source and destination addresses, incrementation and data sizes, transfer 
    117            direction, buffer size, circular/normal mode selection, memory-to-memory mode 
    118            selection and channel priority value.
    119            
    120            - The DMA_Init() function follows the DMA configuration procedures.
    121            - All DMA channels can be enabled and disabled in the same time using 
    122              DMA_GlobalCmd() function.
    123            - The DMA has 4 channels, User can enable or disable channels using 
    124              DMA_Cmd() function.
    125            - The timeout duration (number of wait cycles starting from the latest 
    126              request) is configured using DMA_SetTimeOut() function. The DMA then waits 
    127              until this timeout has elapsed before requesting from the core a high 
    128              priority access to the bus. 
    129          
    130          @endverbatim
    131            * @{
    132            */
    133          
    134          /**
    135            * @brief  Deinitializes the DMA Global Status register to its default reset
    136            *         values.
    137            * @param  None
    138            * @retval None
    139            */
    140          void DMA_GlobalDeInit(void)
    141          {
    142            /* Disable the  DMA    */
    143            DMA1->GCSR &= (uint8_t)~(DMA_GCSR_GE);
    144          
    145            /* Reset DMA Channelx control register */
    146            DMA1->GCSR  = (uint8_t)DMA_GCSR_RESET_VALUE;
    147          }
    148          
    149          /**
    150            * @brief  Deinitializes the DMA Channelx registers to their default reset 
    151            *         values.
    152            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    153            * @retval None
    154            */
    155          void DMA_DeInit(DMA_Channel_T* DMA_Channelx)
    156          {
    157            /* Check the parameters */
    158            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    159          
    160            /* Disable the selected DMA Channelx */
    161            DMA_Channelx->CCR &= (uint8_t)~(DMA_CCR_CE);
    162          
    163            /* Reset DMA Channelx control register */
    164            DMA_Channelx->CCR  = DMA_CCR_RESET_VALUE;
    165          
    166            /* Reset DMA Channelx remaining bytes register */
    167            DMA_Channelx->CNBTR = DMA_CNBTR_RESET_VALUE;
    168          
    169            /* Reset DMA Channelx peripheral address register */
    170            if (DMA_Channelx == DMA1_Channel3)
    171            {
    172              DMA_Channelx->CPARH  = DMA_C3PARH_RESET_VALUE;
    173              DMA_Channelx->CM0EAR = DMA_C3M0EAR_RESET_VALUE;
    174            }
    175            else
    176            {
    177              DMA_Channelx->CPARH  = DMA_CPARH_RESET_VALUE;
    178            }
    179            DMA_Channelx->CPARL  = DMA_CPARL_RESET_VALUE;
    180          
    181            /* Reset DMA Channelx memory address register */
    182            DMA_Channelx->CM0ARH = DMA_CM0ARH_RESET_VALUE;
    183            DMA_Channelx->CM0ARL = DMA_CM0ARL_RESET_VALUE;
    184          
    185            /* Reset interrupt pending bits for DMA Channel */
    186            DMA_Channelx->CSPR = DMA_CSPR_RESET_VALUE;
    187          }
    188          
    189          
    190          /**
    191            * @brief  Initializes the DMA Channelx according to the specified parameters.
    192            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    193            * @param  DMA_Memory0BaseAddr: Specifies  Memory 0 Base Address
    194            * @param  DMA_PeripheralMemory1BaseAddr: Specifies DMA channelx Peripheral 
    195            *         Base Address (if data is from/to  peripheral) or DMA channelx 
    196            *         Memory1 Base Address (if data is from Memory0 to Memory1).
    197            * @param  DMA_BufferSize: Specifies the size of the DMA channelx Buffer.
    198            *         This parameter must be a value greater than 0.
    199            * @param  DMA_DIR: Specifies the DMA Channelx transfer direction.
    200            *          This parameter can be one of the following values:
    201            *            @arg DMA_DIR_PeripheralToMemory: Data transfer direction is Peripheral To Memory
    202            *            @arg DMA_DIR_MemoryToPeripheral: Data transfer direction is Memory To Peripheral
    203            *            @arg DMA_DIR_Memory0ToMemory1: Data transfer direction is Memory0 To Memory 1    
    204            * @param  DMA_Mode: Specifies the DMA channelx mode.
    205            *          This parameter can be one of the following values:
    206            *            @arg DMA_Mode_Normal: DMA normal buffer mode
    207            *            @arg DMA_Mode_Circular: DMA circular buffer mode
    208            * @param  DMA_MemoryIncMode: Specifies the DMA channelx memory Incremental/Decremental mode 
    209            *          This parameter can be one of the following values:
    210            *            @arg DMA_MemoryIncMode_Dec: DMA memory incremented mode is decremental
    211            *            @arg DMA_MemoryIncMode_Inc: DMA memory incremented mode is incremental  
    212            * @param  DMA_Priority: Specifies the DMA channelx priority.
    213            *          This parameter can be one of the following values:
    214            *            @arg DMA_Priority_Low: Software Priority is Low
    215            *            @arg DMA_Priority_Medium: Software Priority is Medium
    216            *            @arg DMA_Priority_High: Software Priority is High
    217            *            @arg DMA_Priority_VeryHigh: Software Priority is Very High
    218            * @param  DMA_MemoryDataSize: Specifies the DMA channelx transfer Data size
    219            *          This parameter can be one of the following values:
    220            *            @arg DMA_MemoryDataSize_Byte: Memory Data Size is 1 Byte
    221            *            @arg DMA_MemoryDataSize_HalfWord: Memory Data Size is 2 Bytes  
    222            * @retval None
    223            */
    224          void DMA_Init(DMA_Channel_T* DMA_Channelx,
    225                        uint32_t DMA_Memory0BaseAddr,
    226                        uint16_t DMA_PeripheralMemory1BaseAddr,
    227                        uint8_t DMA_BufferSize,
    228                        DMA_DIR_T DMA_DIR,
    229                        DMA_Mode_T DMA_Mode,
    230                        DMA_MemoryIncMode_T DMA_MemoryIncMode,
    231                        DMA_Priority_T DMA_Priority,
    232                        DMA_MemoryDataSize_T DMA_MemoryDataSize )
    233          {
    234            /* Check the parameters */
    235            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    236            assert_param(IS_DMA_DIR(DMA_DIR));
    237            assert_param(IS_DMA_BUFFER_SIZE(DMA_BufferSize));
    238            assert_param(IS_DMA_MODE(DMA_Mode));
    239            assert_param(IS_DMA_MEMORY_INC_MODE(DMA_MemoryIncMode));
    240            assert_param(IS_DMA_PRIORITY(DMA_Priority));
    241          
    242            /*--------------------------- DMA Channelx CCR Configuration ---------------*/
    243            /* Disable the selected DMA Channelx */
    244            DMA_Channelx->CCR &= (uint8_t)~(DMA_CCR_CE);
    245          
    246            /* Reset DMA Channelx control register */
    247            DMA_Channelx->CCR  = DMA_CCR_RESET_VALUE;
    248          
    249            /* Set DMA direction & Mode & Incremental Memory mode */
    250            DMA_Channelx->CCR |= (uint8_t)((uint8_t)((uint8_t)DMA_DIR | \
    251                                                     (uint8_t)DMA_Mode) | \
    252                                                     (uint8_t)DMA_MemoryIncMode);
    253          
    254            /*Clear old priority and memory data size  option */
    255            DMA_Channelx->CSPR &= (uint8_t)(~(uint8_t)(DMA_CSPR_PL | DMA_CSPR_16BM));
    256          
    257            /* Set old priority and memory data size  option */
    258            DMA_Channelx->CSPR |= (uint8_t)((uint8_t)DMA_Priority | \
    259                                            (uint8_t)DMA_MemoryDataSize);
    260          
    261            /*--------------------------- DMA Channelx CNDTR Configuration -------------*/
    262            /* Write to DMA Channelx CNDTR */
    263            DMA_Channelx->CNBTR = (uint8_t)DMA_BufferSize;
    264          
    265            /*--------------------------- DMA Channelx CPAR Configuration --------------*/
    266            /* Write to DMA Channelx (0, 1 or 2)  Peripheral address  or  Write to 
    267            DMA Channel 3 Memory 1 address  */
    268            DMA_Channelx->CPARH = (uint8_t)(DMA_PeripheralMemory1BaseAddr >> (uint8_t)8);
    269            DMA_Channelx->CPARL = (uint8_t)(DMA_PeripheralMemory1BaseAddr);
    270          
    271            /*--------------------------- DMA Channelx CMAR Configuration --------------*/
    272            /* Write to DMA Channelx Memory address */
    273            if (DMA_Channelx == DMA1_Channel3)
    274            {
    275              DMA_Channelx->CM0EAR = (uint8_t)(DMA_Memory0BaseAddr >> (uint8_t)16);
    276            }
    277            DMA_Channelx->CM0ARH = (uint8_t)(DMA_Memory0BaseAddr >> (uint8_t)8);
    278            DMA_Channelx->CM0ARL = (uint8_t)(DMA_Memory0BaseAddr);
    279          
    280          }
    281          
    282          /**
    283            * @brief  Enables or disables All the DMA.
    284            * @param  NewState: new state of the DMA. This parameter can be: ENABLE 
    285            *                   or DISABLE.
    286            * @retval None
    287            */
    288          void DMA_GlobalCmd(FunctionalState NewState)
    289          {
    290            /* Check the parameters */
    291            assert_param(IS_FUNCTIONAL_STATE(NewState));
    292          
    293            if (NewState != DISABLE)
    294            {
    295              /* Enable the  DMA      */
    296              DMA1->GCSR |= (uint8_t)DMA_GCSR_GE;
    297            }
    298            else
    299            {
    300              /* Disable the DMA */
    301              DMA1->GCSR &= (uint8_t)(~DMA_GCSR_GE);
    302            }
    303          }
    304          
    305          /**
    306            * @brief  Enables or disables the specified DMA Channelx.
    307            * @note   DMA_GlobalCmd function must be called first to enable or disable
    308            *         the global DMA.
    309            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    310            * @param  NewState: new state of the DMA Channelx.
    311              *         This parameter can be: ENABLE or DISABLE.
    312            * @retval None
    313            */
    314          void DMA_Cmd(DMA_Channel_T* DMA_Channelx, FunctionalState NewState)
    315          {
    316            /* Check the parameters */
    317            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    318            assert_param(IS_FUNCTIONAL_STATE(NewState));
    319          
    320            if (NewState != DISABLE)
    321            {
    322              /* Enable the selected DMA Channelx */
    323              DMA_Channelx->CCR |= DMA_CCR_CE;
    324            }
    325            else
    326            {
    327              /* Disable the selected DMA Channelx */
    328              DMA_Channelx->CCR &= (uint8_t)(~DMA_CCR_CE);
    329            }
    330          }
    331          
    332          /**
    333            * @brief  Sets the Time out Value.
    334            * @param  DMA_TimeOut: an integer from 0 to 63
    335            * @note   If timeout duration >0 (number of wait cycles starting from the
    336            *         latest request), the DMA waits until this timeout has elapsed before
    337            *         requesting from the core a high priority access to the bus.
    338            * @note   If timeout duration =0, there is no timeout and once a request is served,
    339            *         the DMA immediately asks to the CPU a high priority access to the bus.
    340            * @retval None
    341            */
    342          void DMA_SetTimeOut(uint8_t DMA_TimeOut)
    343          {
    344            /* Check the parameters */
    345            assert_param(IS_DMA_TIMEOUT(DMA_TimeOut));
    346          
    347            /* set the time out, GB and GE must be = 0 */
    348            DMA1->GCSR = 0;
    349            DMA1->GCSR = (uint8_t)(DMA_TimeOut << (uint8_t)2);
    350          
    351          }
    352          
    353          /**
    354            * @}
    355            */
    356          
    357          /** @defgroup DMA_Group2 Data Counter functions
    358           *  @brief   Data Counter functions 
    359           *
    360          @verbatim   
    361           ===============================================================================
    362                                     Data Counter functions
    363           ===============================================================================  
    364          
    365            This subsection provides functions allowing to configure and read the buffer 
    366            size (number of data to be transferred). 
    367          
    368            The DMA data counter can be written only when the DMA channel is disabled 
    369            (ie. after transfer complete event).
    370          
    371            The DMA_SetCurrDataCounter() function can be used to write the Channel data 
    372            counter value.
    373            
    374          
    375            Note: It is advised to use this function rather than DMA_Init() (DMA_BufferSize 
    376                  parameter) in situations where only the Data buffer needs to be reloaded.
    377          
    378            The DMA data counter can be read to indicate the number of remaining transfers 
    379            for the relative DMA channel. This counter is decremented at the end of each 
    380            data transfer and when the transfer is complete: 
    381             - If Normal mode is selected: the counter is set to 0.
    382             - If Circular mode is selected: the counter is reloaded with the initial value
    383               (configured before enabling the DMA channel)
    384             
    385            The DMA_GetCurrDataCounter() function can be used to read the Channel current 
    386            data counter value.
    387               
    388          @endverbatim
    389            * @{
    390            */
    391            
    392          /**
    393            * @brief  Set the number of data units to transfer for DMA Channelx.
    394            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    395            * @param  DataNumber: The number of  data units to transfer, it can be any value
    396            *         from 0 to 255
    397            * @note   It is advised to use this function rather than DMA_Init() in situations
    398            *         where only the Data buffer needs to be reloaded.  
    399            * @retval None
    400            */
    401          void DMA_SetCurrDataCounter(DMA_Channel_T* DMA_Channelx, uint8_t DataNumber)
    402          {
    403            /* Check the parameters */
    404            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    405          
    406            /*Set the number of data units for DMA Channelx */
    407            DMA_Channelx->CNBTR = DataNumber;
    408          }
    409          
    410          /**
    411            * @brief  Returns the number of remaining data units in the current DMA Channelx transfer.
    412            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    413            * @retval The number of remaining data units in the current DMA Channelx
    414            */
    415          uint8_t DMA_GetCurrDataCounter(DMA_Channel_T* DMA_Channelx)
    416          {
    417            /* Check the parameters */
    418            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    419          
    420            /* Return the number of remaining data units for DMA Channelx */
    421            return ((uint8_t)(DMA_Channelx->CNBTR));
    422          }
    423          
    424          /**
    425            * @}
    426            */
    427          
    428          /** @defgroup DMA_Group3 Interrupts and flags management functions
    429           *  @brief   Interrupts and flags management functions 
    430           *
    431          @verbatim   
    432           ===============================================================================
    433                            Interrupts and flags management functions
    434           ===============================================================================  
    435          
    436            This subsection provides functions allowing to configure the DMA Interrupts 
    437            sources and check or clear the flags or pending bits status.
    438            The user should identify which mode will be used in his application to manage 
    439            the DMA controller events: Polling mode or Interrupt mode. 
    440              
    441            Polling Mode
    442            =============
    443              Each DMA channel can be managed through 2 event Flags:
    444              (x: DMA channel number )
    445                 1. DMA1_FLAG_TCx: to indicate that a Transfer Complete event occurred
    446                 2. DMA1_FLAG_HTx: to indicate that a Half-Transfer Complete event 
    447                                    occurred
    448          
    449             In this Mode it is advised to use DMA_GetFlagStatus() and  DMA_ClearFlag() 
    450             functions. 
    451                
    452          
    453            Interrupt Mode
    454            ===============
    455              Each DMA channel can be managed through 2 Interrupts:
    456          
    457              Interrupt Source
    458              ----------------
    459                 1. DMA_IT_TC: specifies the interrupt source for the Transfer Complete 
    460                               event.  
    461                 2. DMA_IT_HT: specifies the interrupt source for the Half-transfer 
    462                                Complete event.
    463               
    464            In this Mode it is advised to use DMA_ITConfig(), DMA_GetITStatus() and
    465            DMA_ClearITPendingBit() functions.
    466          
    467          @endverbatim
    468            * @{
    469            */
    470          
    471          /**
    472            * @brief  Enables or disables the specified DMA Channelx interrupts.
    473            * @param  DMA_Channelx: selects the DMA Channelx where x can be 0 to 3
    474            * @param  DMA_ITx: specifies the DMA interrupts sources to be enabled or disabled. 
    475            *          This parameter can be one of the following values:
    476            *            @arg DMA_ITx_TC: Transaction Complete Interrupt
    477            *            @arg DMA_ITx_HT: Half Transaction Interrupt  
    478            * @param  NewState: new state of the specified DMA interrupts.
    479              *       This parameter can be: ENABLE or DISABLE.
    480            * @retval None
    481            */
    482          void DMA_ITConfig(DMA_Channel_T* DMA_Channelx, 
    483                            DMA_ITx_T DMA_ITx,
    484                            FunctionalState NewState)
    485          {
    486            /* Check the parameters */
    487            assert_param(IS_DMA_CHANNEL(DMA_Channelx));
    488            assert_param(IS_DMA_CONFIG_ITX(DMA_ITx));
    489            assert_param(IS_FUNCTIONAL_STATE(NewState));
    490          
    491            if (NewState != DISABLE)
    492            {
    493              /* Enable the selected DMA interrupts */
    494              DMA_Channelx->CCR |= (uint8_t)(DMA_ITx);
    495            }
    496            else
    497            {
    498              /* Disable the selected DMA interrupts */
    499              DMA_Channelx->CCR &= (uint8_t)~(DMA_ITx);
    500            }
    501          }
    502          
    503          /**
    504            * @brief  Checks whether the specified DMA Channelx flag is set or not.
    505            * @param  DMA_FLAG: specifies the flag to check.
    506            *          This parameter can be one of the following values:
    507            *            @arg DMA1_FLAG_GB: Global Busy Flag
    508            *            @arg DMA1_FLAG_IFC0: Global Interrupt Flag Channel 0
    509            *            @arg DMA1_FLAG_IFC1: Global Interrupt Flag Channel 1
    510            *            @arg DMA1_FLAG_IFC2: Global Interrupt Flag Channel 2
    511            *            @arg DMA1_FLAG_IFC3: Global Interrupt Flag Channel 3
    512            *            @arg DMA1_FLAG_TC0: Transaction Complete Interrupt Flag Channel 0
    513            *            @arg DMA1_FLAG_TC1: Transaction Complete Interrupt Flag Channel 1
    514            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 2
    515            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 3
    516            *            @arg DMA1_FLAG_HT0: Half Transaction Interrupt Flag Channel 0
    517            *            @arg DMA1_FLAG_HT1: Half Transaction Interrupt Flag Channel 1
    518            *            @arg DMA1_FLAG_HT2: Half Transaction Interrupt Flag Channel 2
    519            *            @arg DMA1_FLAG_HT3: Half Transaction Interrupt Flag Channel 3
    520            *            @arg DMA1_FLAG_PEND0: DMA Request pending on Channel 0
    521            *            @arg DMA1_FLAG_PEND1: DMA Request pending on Channel 1
    522            *            @arg DMA1_FLAG_PEND2: DMA Request pending on Channel 2
    523            *            @arg DMA1_FLAG_PEND3: DMA Request pending on Channel 3
    524            *            @arg DMA1_FLAG_BUSY0: No DMA transfer on going in Channel 0
    525            *            @arg DMA1_FLAG_BUSY1: No DMA transfer on going in Channel 1 
    526            *            @arg DMA1_FLAG_BUSY2: No DMA transfer on going in Channel 2 
    527            *            @arg DMA1_FLAG_BUSY3: No DMA transfer on going in Channel 3                                        
    528            * @retval  The status of DMA_FLAG (SET or RESET).
    529            */
    530          FlagStatus DMA_GetFlagStatus(DMA_FLAG_T DMA_FLAG)
    531          {
    532            FlagStatus flagstatus = RESET;
    533            DMA_Channel_T* DMA_Channelx =  DMA1_Channel0;
    534            uint8_t tmpgir1 = 0;
    535            uint8_t tmpgcsr = 0;
    536          
    537            /* Check the parameters */
    538            assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
    539          
    540            /* Get flags registers values*/
    541            tmpgcsr = DMA1->GCSR;
    542            tmpgir1 = DMA1->GIR1;
    543          
    544            if (((uint16_t)DMA_FLAG & (uint16_t)0x0F00) != (uint16_t)RESET)
    545            {
    546              /* find  the used DMA  channel */
    547              if (((uint16_t)DMA_FLAG & 0x0100) != (uint16_t)RESET)
    548              {
    549                DMA_Channelx = DMA1_Channel0;
    550              }
    551              else if  (((uint16_t)DMA_FLAG & 0x0200) != (uint16_t)RESET)
    552              {
    553                DMA_Channelx = DMA1_Channel1;
    554              }
    555              else if  (((uint16_t)DMA_FLAG & 0x0400) != (uint16_t)RESET)
    556              {
    557                DMA_Channelx = DMA1_Channel2;
    558              }
    559              else
    560              {
    561                DMA_Channelx = DMA1_Channel3;
    562              }
    563          
    564              /*   Get the specified DMA Channelx flag status. */
    565              flagstatus = (FlagStatus)((uint8_t)(DMA_Channelx->CSPR) & (uint8_t)DMA_FLAG);
    566            }
    567            else if (((uint16_t)DMA_FLAG & 0x1000) != (uint16_t)RESET)
    568            {
    569              /*   Get the specified DMA Channelx flag status. */
    570              flagstatus = (FlagStatus)(tmpgir1 & (uint8_t)DMA_FLAG);
    571            }
    572            else /*if ((DMA_FLAG & DMA_FLAG_GB) != (uint16_t)RESET)*/
    573            {
    574              /*   Get the specified DMA Channelx flag status. */
    575              flagstatus = (FlagStatus)(tmpgcsr & DMA_GCSR_GB);
    576            }
    577          
    578            /*  Return the specified DMA Channelx flag status. */
    579            return (flagstatus);
    580          }
    581          
    582          /**
    583            * @brief  Clears the DMA Channels selected flags.
    584            * @param  DMA_FLAG: specifies the flag to clear.
    585            *          This parameter can be one or a combination (for the same channel)of
    586            *          the following values:
    587            *            @arg DMA1_FLAG_TC0: Transaction Complete Interrupt Flag Channel 0
    588            *            @arg DMA1_FLAG_TC1: Transaction Complete Interrupt Flag Channel 1
    589            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 2
    590            *            @arg DMA1_FLAG_TC2: Transaction Complete Interrupt Flag Channel 3
    591            *            @arg DMA1_FLAG_HT0: Half Transaction Interrupt Flag Channel 0
    592            *            @arg DMA1_FLAG_HT1: Half Transaction Interrupt Flag Channel 1
    593            *            @arg DMA1_FLAG_HT2: Half Transaction Interrupt Flag Channel 2
    594            *            @arg DMA1_FLAG_HT3: Half Transaction Interrupt Flag Channel 3
    595            * @retval None
    596            */
    597          void DMA_ClearFlag(DMA_FLAG_T DMA_FLAG)
    598          {
    599            DMA_Channel_T* DMA_Channelx =  DMA1_Channel0;
    600          
    601            /* Check the parameters */
    602            assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
    603          
    604            /* Identify  the used DMA  channel */
    605            if (((uint16_t)DMA_FLAG & (uint16_t)0x0100) != (uint16_t)RESET)
    606            {
    607              DMA_Channelx = DMA1_Channel0;
    608            }
    609            else
    610            {
    611              if (((uint16_t)DMA_FLAG & (uint16_t)0x0200) != (uint16_t)RESET)
    612              {
    613                DMA_Channelx = DMA1_Channel1;
    614              }
    615              else
    616              {
    617                if (((uint16_t)DMA_FLAG & (uint16_t)0x0400) != (uint16_t)RESET)
    618                {
    619                  DMA_Channelx = DMA1_Channel2;
    620                }
    621                else
    622                {
    623                  DMA_Channelx = DMA1_Channel3;
    624                }
    625              }
    626            }
    627          
    628            /*Clears the DMA flags.*/
    629            DMA_Channelx->CSPR &= (uint8_t)~(uint8_t)((uint8_t)DMA_FLAG & (uint8_t)0x06);
    630          }
    631          
    632          /**
    633            * @brief  Checks whether the specified DMA Channelx interrupt has occurred or not.
    634            * @param  DMA_IT: specifies the DMA interrupt source to check.
    635            *          This parameter can be one or a combination of the following values:
    636            *            @arg DMA1_IT_TC0: Transaction Complete Interrupt Channel 0
    637            *            @arg DMA1_IT_TC1: Transaction Complete Interrupt Channel 1
    638            *            @arg DMA1_IT_TC2: Transaction Complete Interrupt Channel 2
    639            *            @arg DMA1_IT_TC3: Transaction Complete Interrupt Channel 3
    640            *            @arg DMA1_IT_HT0: Half Transaction Interrupt Channel 0
    641            *            @arg DMA1_IT_HT1: Half Transaction Interrupt Channel 1
    642            *            @arg DMA1_IT_HT2: Half Transaction Interrupt Channel 2
    643            *            @arg DMA1_IT_HT3: Half Transaction Interrupt Channel 3    
    644            * @retval ITStatus: The status of DMA_IT (SET or RESET).
    645            */
    646          ITStatus DMA_GetITStatus(DMA_IT_T DMA_IT)
    647          {
    648            ITStatus itstatus = RESET;
    649            uint8_t tmpreg = 0;
    650            uint8_t tmp2 = 0;
    651            DMA_Channel_T* DMA_Channelx =  DMA1_Channel0;
    652          
    653            /* Check the parameters */
    654            assert_param(IS_DMA_GET_IT(DMA_IT));
    655          
    656            /* Identify  the used DMA  channel */
    657            if ((DMA_IT & 0x10) != (uint8_t)RESET)
    658            {
    659              DMA_Channelx = DMA1_Channel0;
    660            }
    661            else
    662            {
    663              if  ((DMA_IT & 0x20) != (uint8_t)RESET)
    664              {
    665                DMA_Channelx = DMA1_Channel1;
    666              }
    667              else
    668              {
    669                if  ((DMA_IT & 0x40) != (uint8_t)RESET)
    670                {
    671                  DMA_Channelx = DMA1_Channel2;
    672                }
    673                else
    674                {
    675                  DMA_Channelx = DMA1_Channel3;
    676                }
    677              }
    678            }
    679            /*   Get the specified DMA Channelx interrupt status. */
    680            tmpreg =  DMA_Channelx->CSPR ;
    681            tmpreg &= DMA_Channelx->CCR ;
    682            tmp2 = (uint8_t)(DMA_IT & (uint8_t)(DMA_CCR_TCIE | DMA_CCR_HTIE));
    683            itstatus = (ITStatus)((uint8_t)tmpreg & (uint8_t)tmp2);
    684          
    685            /*   Return the specified DMA Channelx interrupt status. */
    686            return (itstatus);
    687          }
    688          
    689          /**
    690            * @brief  Clears the DMA Channelx�s interrupt pending bits.
    691            * @param  DMA_IT: specifies the DMA interrupt pending bit to clear.
    692            *          This parameter can be one or a combination(for the same channel)of 
    693            *          the following values:
    694            *            @arg DMA1_IT_TC0: Transaction Complete Interrupt Channel 0
    695            *            @arg DMA1_IT_TC1: Transaction Complete Interrupt Channel 1
    696            *            @arg DMA1_IT_TC2: Transaction Complete Interrupt Channel 2
    697            *            @arg DMA1_IT_TC3: Transaction Complete Interrupt Channel 3
    698            *            @arg DMA1_IT_HT0: Half Transaction Interrupt Channel 0
    699            *            @arg DMA1_IT_HT1: Half Transaction Interrupt Channel 1
    700            *            @arg DMA1_IT_HT2: Half Transaction Interrupt Channel 2
    701            *            @arg DMA1_IT_HT3: Half Transaction Interrupt Channel 3 
    702            * @retval None
    703            */
    704          void DMA_ClearITPendingBit(DMA_IT_T DMA_IT)
    705          {
    706            DMA_Channel_T* DMA_Channelx =  DMA1_Channel0;
    707          
    708            /* Check the parameters */
    709            assert_param(IS_DMA_CLEAR_IT(DMA_IT));
    710            /* Identify  the used DMA  channel */
    711            if ((DMA_IT & 0x10) != (uint8_t)RESET)
    712            {
    713              DMA_Channelx = DMA1_Channel0;
    714            }
    715            else
    716            {
    717              if ((DMA_IT & 0x20) != (uint8_t)RESET)
    718              {
    719                DMA_Channelx = DMA1_Channel1;
    720              }
    721              else
    722              {
    723                if ((DMA_IT & 0x40) != (uint8_t)RESET)
    724                {
    725                  DMA_Channelx = DMA1_Channel2;
    726                }
    727                else
    728                {
    729                  DMA_Channelx = DMA1_Channel3;
    730                }
    731              }
    732            }
    733            /*Clears the DMA Channelx�s interrupt pending bits*/
    734            DMA_Channelx->CSPR &= (uint8_t)~(uint8_t)(DMA_IT & (uint8_t)0x06);
    735          }
    736          
    737          /**
    738            * @}
    739            */ 
    740          
    741          /**
    742            * @}
    743            */ 
    744            
    745          /**
    746            * @}
    747            */
    748          
    749          /**
    750            * @}
    751            */
    752          
    753          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       7  ??Subroutine1_0
       3  ?Subroutine0
      61  DMA_ClearFlag
      44  DMA_ClearITPendingBit
      13  DMA_Cmd
      67  DMA_DeInit
       5  DMA_GetCurrDataCounter
      99  DMA_GetFlagStatus
      50  DMA_GetITStatus
      13  DMA_GlobalCmd
       9  DMA_GlobalDeInit
      11  DMA_ITConfig
     122  DMA_Init
       5  DMA_SetCurrDataCounter
      10  DMA_SetTimeOut

 
 519 bytes in section .far_func.text
 
 519 bytes of CODE memory

Errors: none
Warnings: none
