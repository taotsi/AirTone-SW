###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:11
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_i2c.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_i2c.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_i2c.lst
#    Object file  =  H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_i2c.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following
      8            *          functionalities of the Inter-integrated circuit (I2C)
      9            *           - Initialization and Configuration
     10            *           - Data transfers
     11            *           - PEC management
     12            *           - DMA transfers management
     13            *           - Interrupts, events and flags management
     14            *
     15            *  @verbatim
     16            *
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *          1. Enable peripheral clock using CLK_PeripheralClockConfig(CLK_Peripheral_I2Cx,
     21            *             ENABLE) function (Refer to the product datasheet for the available I2C
     22            *           	peripherals)
     23            *
     24            *
     25            *          2. Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
     26            *             Address using the I2C_Init() function.
     27            *
     28            *          3. Optionally you can enable/configure the following parameters without
     29            *             re-initialization (i.e there is no need to call again I2C_Init() function):
     30            *              - Enable the acknowledge feature using I2C_AcknowledgeConfig() function
     31            *              - Enable the dual addressing mode using I2C_DualAddressCmd() function
     32            *              - Enable the general call using the I2C_GeneralCallCmd() function
     33            *              - Enable the clock stretching using I2C_StretchClockCmd() function
     34            *              - Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
     35            *                function
     36            *              - Enable the PEC Calculation using I2C_CalculatePEC() function
     37            *              - For SMBus Mode:
     38            *                   - Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
     39            *                   - Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
     40            *
     41            *          4. Enable the interrupt using the function I2C_ITConfig() if you need
     42            *             to use interrupt mode.
     43            *
     44            *          5. When using the DMA mode
     45            *                   - Configure the DMA using DMA_Init() function
     46            *                   - Active the needed channel Request using I2C_DMACmd() or
     47            *                     I2C_DMALastTransferCmd() function
     48            *              Note: When using DMA mode, I2C interrupts may be used at the same time to
     49            *                    control the communication flow (Start/Stop/Ack... events and errors).
     50            *
     51            *          6. Enable the I2C using the I2C_Cmd() function.
     52            *
     53            *          7. Enable the DMA using the DMA_Cmd() function when using DMA mode in the
     54            *             transfers.
     55            *
     56            *         Note: The external Pull-up resistors must be connected on SDA and SCL.
     57            *
     58            *  @endverbatim
     59            *
     60            ******************************************************************************
     61            * @attention
     62            *
     63            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     64            *
     65            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     66            * You may not use this file except in compliance with the License.
     67            * You may obtain a copy of the License at:
     68            *
     69            *        http://www.st.com/software_license_agreement_liberty_v2
     70            *
     71            * Unless required by applicable law or agreed to in writing, software 
     72            * distributed under the License is distributed on an "AS IS" BASIS, 
     73            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     74            * See the License for the specific language governing permissions and
     75            * limitations under the License.
     76            *
     77            ******************************************************************************
     78            */
     79          
     80          /* Includes ------------------------------------------------------------------*/
     81          #include "stm8l15x_i2c.h"
     82          #include "stm8l15x_clk.h"
     83          
     84          /** @addtogroup STM8L15x_StdPeriph_Driver
     85            * @{
     86            */
     87          
     88          /** @defgroup I2C
     89            * @brief I2C driver modules
     90            * @{
     91            */
     92          
     93          /* Private typedef -----------------------------------------------------------*/
     94          /* Private define ------------------------------------------------------------*/
     95          /** @defgroup I2C_Private_Define
     96            * @{
     97            */
     98          
     99          /* I2C register mask */
    100          #define REGISTER_Mask               ((uint16_t)0x3000)
    101          #define REGISTER_SR1_Index          ((uint16_t)0x0100)
    102          #define REGISTER_SR2_Index          ((uint16_t)0x0200)
    103          /* I2C Interrupt Enable mask */
    104          #define ITEN_Mask                   ((uint16_t)0x0700)
    105          /* I2C FLAG mask */
    106          #define FLAG_Mask                   ((uint16_t)0x00FF)
    107          /* I2C ADD0 mask */
    108          #define OAR1_ADD0_Set               ((uint8_t)0x01)
    109          #define OAR1_ADD0_Reset             ((uint8_t)0xFE)
    110          
    111          /**
    112            * @}
    113            */
    114          
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /* Private function prototypes -----------------------------------------------*/
    118          /* Private functions ---------------------------------------------------------*/
    119          
    120          /** @defgroup I2C_Private_Functions
    121            * @{
    122            */
    123          
    124          /** @defgroup I2C_Group1 Initialization and Configuration functions
    125           *  @brief   Initialization and Configuration functions
    126           *
    127          @verbatim
    128           ===============================================================================
    129                             Initialization and Configuration functions
    130           ===============================================================================
    131          
    132          @endverbatim
    133            * @{
    134            */
    135          
    136          /**
    137            * @brief  Deinitializes the I2C peripheral registers to their default reset values.
    138            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    139            * @retval None
    140            */
    141          void I2C_DeInit(I2C_T* I2Cx)
    142          {
    143            I2Cx->CR1 = I2C_CR1_RESET_VALUE;
    144            I2Cx->CR2 = I2C_CR2_RESET_VALUE;
    145            I2Cx->FREQR = I2C_FREQR_RESET_VALUE;
    146            I2Cx->OARL = I2C_OARL_RESET_VALUE;
    147            I2Cx->OARH = I2C_OARH_RESET_VALUE;
    148            I2Cx->OAR2 = I2C_OAR2_RESET_VALUE;
    149            I2Cx->ITR = I2C_ITR_RESET_VALUE;
    150            I2Cx->CCRL = I2C_CCRL_RESET_VALUE;
    151            I2Cx->CCRH = I2C_CCRH_RESET_VALUE;
    152            I2Cx->TRISER = I2C_TRISER_RESET_VALUE;
    153          }
    154          
    155          /**
    156            * @brief  Initializes the I2C according to the specified parameters in standard
    157            *         or fast mode.
    158            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    159            * @param  OutputClockFrequency: Specifies the output clock frequency in Hz.
    160            * @param  OwnAddress: Specifies the own address.
    161            * @param  I2C_Mode: Specifies the addressing mode to apply.
    162            *          This parameter can be one of the following values:
    163            *            @arg I2C_Mode_I2C: I2C mode
    164            *            @arg I2C_Mode_SMBusDevice: SMBus Device mode
    165            *            @arg I2C_Mode_SMBusHost: SMBus Host mode
    166            * @param  I2C_DutyCycle: Specifies the duty cycle to apply in fast mode.
    167            *          This parameter can be one of the following values:
    168            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    169            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    170            * @note   The I2C_DutyCycle parameter doesn't have impact when the OutputClockFrequency
    171            *         is lower than 100KHz.
    172            * @param  I2C_Ack: Specifies the acknowledge mode to apply.
    173            *          This parameter can be one of the following values:
    174            *            @arg I2C_Ack_Disable: No acknowledge
    175            *            @arg I2C_Ack_Enable: Acknowledge Enabled
    176            * @param  I2C_AcknowledgedAddress: Specifies the acknowledge address to apply.
    177            *          This parameter can be one of the following values:
    178            *            @arg I2C_AcknowledgedAddress_7bit: 7-bit slave address
    179            *            @arg I2C_AcknowledgedAddress_10bit: 10-bit slave address
    180            * @note   To use the I2C at 400 KHz (in fast mode), the PCLK frequency
    181            *         (I2C peripheral input clock) must be a multiple of 10 MHz.
    182            * @retval None
    183            */
    184          void I2C_Init(I2C_T* I2Cx, uint32_t OutputClockFrequency, uint16_t OwnAddress,
    185                        I2C_Mode_T I2C_Mode, I2C_DutyCycle_T I2C_DutyCycle,
    186                        I2C_Ack_T I2C_Ack, I2C_AcknowledgedAddress_T I2C_AcknowledgedAddress)
    187          {
    188            uint32_t result = 0x0004;
    189            uint16_t tmpval = 0;
    190            uint8_t tmpccrh = 0;
    191            uint8_t input_clock = 0;
    192          
    193            /* Check the parameters */
    194            assert_param(IS_I2C_MODE(I2C_Mode));
    195            assert_param(IS_I2C_ACK_STATE(I2C_Ack));
    196            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_AcknowledgedAddress));
    197            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    198            assert_param(IS_I2C_OWN_ADDRESS(OwnAddress));
    199            assert_param(IS_I2C_OUTPUT_CLOCK_FREQ(OutputClockFrequency));
    200          
    201          
    202            /* Get system clock frequency */
    203            input_clock = (uint8_t) (CLK_GetClockFreq() / 1000000);
    204          
    205            /*------------------------- I2C FREQ Configuration ------------------------*/
    206            /* Clear frequency bits */
    207            I2Cx->FREQR &= (uint8_t)(~I2C_FREQR_FREQ);
    208            /* Write new value */
    209            I2Cx->FREQR |= input_clock;
    210          
    211            /*--------------------------- I2C CCR Configuration ------------------------*/
    212            /* Disable I2C to configure TRISER */
    213            I2Cx->CR1 &= (uint8_t)(~I2C_CR1_PE);
    214          
    215            /* Clear CCRH & CCRL */
    216            I2Cx->CCRH &= (uint8_t)(~(I2C_CCRH_FS | I2C_CCRH_DUTY | I2C_CCRH_CCR));
    217            I2Cx->CCRL &= (uint8_t)(~I2C_CCRL_CCR);
    218          
    219            /* Detect Fast or Standard mode depending on the Output clock frequency selected */
    220            if (OutputClockFrequency > I2C_MAX_STANDARD_FREQ) /* FAST MODE */
    221            {
    222              /* Set F/S bit for fast mode */
    223              tmpccrh = I2C_CCRH_FS;
    224          
    225              if (I2C_DutyCycle == I2C_DutyCycle_2)
    226              {
    227                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    228                result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 3));
    229              }
    230              else /* I2C_DUTYCYCLE_16_9 */
    231              {
    232                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    233                result = (uint32_t) ((input_clock * 1000000) / (OutputClockFrequency * 25));
    234                /* Set DUTY bit */
    235                tmpccrh |= I2C_CCRH_DUTY;
    236              }
    237          
    238              /* Verify and correct CCR value if below minimum value */
    239              if (result < (uint16_t)0x01)
    240              {
    241                /* Set the minimum allowed value */
    242                result = (uint16_t)0x0001;
    243              }
    244          
    245              /* Set Maximum Rise Time: 300ns max in Fast Mode
    246              = [300ns/(1/input_clock.10e6)]+1
    247              = [(input_clock * 3)/10]+1 */
    248              tmpval = ((input_clock * 3) / 10) + 1;
    249              I2Cx->TRISER = (uint8_t)tmpval;
    250          
    251            }
    252            else /* STANDARD MODE */
    253            {
    254          
    255              /* Calculate standard mode speed */
    256              result = (uint16_t)((input_clock * 1000000) / (OutputClockFrequency << (uint8_t)1));
    257          
    258              /* Verify and correct CCR value if below minimum value */
    259              if (result < (uint16_t)0x0004)
    260              {
    261                /* Set the minimum allowed value */
    262                result = (uint16_t)0x0004;
    263              }
    264          
    265              /* Set Maximum Rise Time: 1000ns max in Standard Mode
    266              = [1000ns/(1/input_clock.10e6)]+1
    267              = input_clock+1 */
    268              I2Cx->TRISER = (uint8_t)((uint8_t)input_clock + (uint8_t)1);
    269          
    270            }
    271          
    272            /* Write CCR with new calculated value */
    273            I2Cx->CCRL = (uint8_t)result;
    274            I2Cx->CCRH = (uint8_t)((uint8_t)((uint8_t)((uint8_t)result >> 8) & I2C_CCRH_CCR) | tmpccrh);
    275          
    276            /* Enable I2C and  Configure its mode*/
    277            I2Cx->CR1 |= (uint8_t)(I2C_CR1_PE | I2C_Mode);
    278          
    279            /* Configure I2C acknowledgement */
    280            I2Cx->CR2 |= (uint8_t)I2C_Ack;
    281          
    282            /*--------------------------- I2C OAR Configuration ------------------------*/
    283            I2Cx->OARL = (uint8_t)(OwnAddress);
    284            I2Cx->OARH = (uint8_t)((uint8_t)(I2C_AcknowledgedAddress | I2C_OARH_ADDCONF ) | \
    285                                   (uint8_t)((uint16_t)( (uint16_t)OwnAddress &  (uint16_t)0x0300) >> 7));
    286          }
    287          
    288          /**
    289            * @brief  Enables or disables the I2C peripheral.
    290            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    291            * @param  NewState: Indicate the new I2C peripheral state.
    292            *         This parameter can be: ENABLE or DISABLE.
    293            * @retval None
    294            */
    295          void I2C_Cmd(I2C_T* I2Cx, FunctionalState NewState)
    296          {
    297          
    298            /* Check function parameters */
    299            assert_param(IS_FUNCTIONAL_STATE(NewState));
    300          
    301            if (NewState != DISABLE)
    302            {
    303              /* Enable I2C peripheral */
    304              I2Cx->CR1 |= I2C_CR1_PE;
    305            }
    306            else /* NewState == DISABLE */
    307            {
    308              /* Disable I2C peripheral */
    309              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_PE);
    310            }
    311          }
    312          
    313          /**
    314            * @brief  Enables or disables the I2C General Call feature.
    315            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    316            * @param  NewState: State of the General Call feature.
    317            *         This parameter can be: ENABLE or DISABLE.
    318            * @retval None
    319            */
    320          void I2C_GeneralCallCmd(I2C_T* I2Cx, FunctionalState NewState)
    321          {
    322          
    323            /* Check function parameters */
    324            assert_param(IS_FUNCTIONAL_STATE(NewState));
    325          
    326            if (NewState != DISABLE)
    327            {
    328              /* Enable General Call */
    329              I2Cx->CR1 |= I2C_CR1_ENGC;
    330            }
    331            else /* NewState == DISABLE */
    332            {
    333              /* Disable General Call */
    334              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ENGC);
    335            }
    336          }
    337          
    338          /**
    339            * @brief  Generates I2C communication START condition.
    340            * @note   CCR must be programmed, i.e. I2C_Init function must have been called
    341            *         with a valid I2C_ClockSpeed
    342            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    343            * @param  NewState: Enable or disable the start condition.
    344            *         This parameter can be: ENABLE or DISABLE.
    345            * @retval None
    346            */
    347          void I2C_GenerateSTART(I2C_T* I2Cx, FunctionalState NewState)
    348          {
    349          
    350            /* Check function parameters */
    351            assert_param(IS_FUNCTIONAL_STATE(NewState));
    352          
    353            if (NewState != DISABLE)
    354            {
    355              /* Generate a START condition */
    356              I2Cx->CR2 |= I2C_CR2_START;
    357            }
    358            else /* NewState == DISABLE */
    359            {
    360              /* Disable the START condition generation */
    361              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_START);
    362            }
    363          }
    364          
    365          /**
    366            * @brief  Generates I2C communication STOP condition.
    367            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    368            * @param  NewState: Enable or disable the stop condition.
    369            *         This parameter can be: ENABLE or DISABLE.
    370            * @retval None
    371            */
    372          void I2C_GenerateSTOP(I2C_T* I2Cx, FunctionalState NewState)
    373          {
    374          
    375            /* Check function parameters */
    376            assert_param(IS_FUNCTIONAL_STATE(NewState));
    377          
    378            if (NewState != DISABLE)
    379            {
    380              /* Generate a STOP condition */
    381              I2Cx->CR2 |= I2C_CR2_STOP;
    382            }
    383            else /* NewState == DISABLE */
    384            {
    385              /* Disable the STOP condition generation */
    386              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_STOP);
    387            }
    388          }
    389          
    390          /**
    391            * @brief  Enables or disables I2C software reset.
    392            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    393            * @param  NewState: Specifies the new state of the I2C software reset.
    394            *         This parameter can be: ENABLE or DISABLE.
    395            * @retval None
    396            */
    397          void I2C_SoftwareResetCmd(I2C_T* I2Cx, FunctionalState NewState)
    398          {
    399            /* Check function parameters */
    400            assert_param(IS_FUNCTIONAL_STATE(NewState));
    401          
    402            if (NewState != DISABLE)
    403            {
    404              /* Peripheral under reset */
    405              I2Cx->CR2 |= I2C_CR2_SWRST;
    406            }
    407            else /* NewState == DISABLE */
    408            {
    409              /* Peripheral not under reset */
    410              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_SWRST);
    411            }
    412          }
    413          
    414          /**
    415            * @brief  Enables or disables the I2C clock stretching.
    416            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    417            * @param  NewState: Specifies the new state of the I2C Clock stretching.
    418            *         This parameter can be: ENABLE or DISABLE.
    419            * @retval None
    420            */
    421          void I2C_StretchClockCmd(I2C_T* I2Cx, FunctionalState NewState)
    422          {
    423            /* Check function parameters */
    424            assert_param(IS_FUNCTIONAL_STATE(NewState));
    425          
    426            if (NewState != DISABLE)
    427            {
    428              /* Clock Stretching Enable */
    429              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_NOSTRETCH);
    430          
    431            }
    432            else /* NewState == DISABLE */
    433            {
    434              /* Clock Stretching Disable (Slave mode) */
    435              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
    436            }
    437          }
    438          
    439          /**
    440            * @brief  Enables or disables the I2C ARP.
    441            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    442            * @param  NewState: Specifies the new state of the I2C ARP
    443            *         This parameter can be: ENABLE or DISABLE.
    444            * @retval None
    445            */
    446          void I2C_ARPCmd(I2C_T* I2Cx, FunctionalState NewState)
    447          {
    448            /* Check function parameters */
    449            assert_param(IS_FUNCTIONAL_STATE(NewState));
    450          
    451            if (NewState != DISABLE)
    452            {
    453              /* ARP Enable */
    454              I2Cx->CR1 |= I2C_CR1_ARP;
    455          
    456            }
    457            else /* NewState == DISABLE */
    458            {
    459              /* ARP Disable  */
    460              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ARP);
    461            }
    462          }
    463          
    464          /**
    465            * @brief  Enable or Disable the I2C acknowledge feature.
    466            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    467            * @param  NewState: Specifies the new state of the I2C acknowledge.
    468            *         This parameter can be: ENABLE or DISABLE.
    469            * @retval None
    470            */
    471          void I2C_AcknowledgeConfig(I2C_T* I2Cx, FunctionalState NewState)
    472          {
    473            /* Check function parameters */
    474            assert_param(IS_FUNCTIONAL_STATE(NewState));
    475          
    476            if (NewState != DISABLE)
    477            {
    478              /* Enable the acknowledgement */
    479              I2Cx->CR2 |= I2C_CR2_ACK;
    480            }
    481            else
    482            {
    483              /* Disable the acknowledgement */
    484              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_ACK);
    485            }
    486          }
    487          
    488          /**
    489            * @brief  Configures the specified I2C own address2.
    490            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    491            * @param  Address: specifies the 7bit I2C own address2.
    492            * @retval None.
    493            */
    494          void I2C_OwnAddress2Config(I2C_T* I2Cx, uint8_t Address)
    495          {
    496            uint8_t tmpreg = 0;
    497          
    498            /* Get the old register value */
    499            tmpreg = I2Cx->OAR2;
    500          
    501            /* Reset I2Cx Own address2 bit [7:1] */
    502            tmpreg &= (uint8_t)(~I2C_OAR2_ADD2);
    503          
    504            /* Set I2Cx Own address2 */
    505            tmpreg |= (uint8_t) ((uint8_t)Address & (uint8_t)0xFE);
    506          
    507            /* Store the new register value */
    508            I2Cx->OAR2 = tmpreg;
    509          }
    510          
    511          /**
    512            * @brief  Enables or disables the specified I2C dual addressing mode.
    513            * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
    514            * @param  NewState: new state of the I2C dual addressing mode.
    515              *         This parameter can be: ENABLE or DISABLE.
    516            * @retval None
    517            */
    518          void I2C_DualAddressCmd(I2C_T* I2Cx, FunctionalState NewState)
    519          {
    520            /* Check the parameters */
    521            assert_param(IS_FUNCTIONAL_STATE(NewState));
    522          
    523            if (NewState != DISABLE)
    524            {
    525              /* Enable dual addressing mode */
    526              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
    527            }
    528            else
    529            {
    530              /* Disable dual addressing mode */
    531              I2Cx->OAR2 &= (uint8_t)(~I2C_OAR2_ENDUAL);
    532            }
    533          }
    534          
    535          /**
    536            * @brief  Selects the specified I2C Ack position.
    537            * @note   This function must be called before data reception starts.
    538            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    539            * @param  I2C_AckPosition: specifies the Ack position.
    540            *          This parameter can be one of the following values:
    541            *            @arg I2C_AckPosition_Current: Acknowledge on the current byte
    542            *            @arg I2C_AckPosition_Next: Acknowledge on the next byte
    543            * @retval None
    544            */
    545          void I2C_AckPositionConfig(I2C_T* I2Cx, I2C_AckPosition_T I2C_AckPosition)
    546          {
    547            /* Check function parameters */
    548            assert_param(IS_I2C_ACK_POSITION(I2C_AckPosition));
    549          
    550            /* Clear the I2C Ack position */
    551            I2Cx->CR2 &= (uint8_t)(~I2C_CR2_POS);
    552            /* Configure the specified I2C Ack position*/
    553            I2Cx->CR2 |= (uint8_t)I2C_AckPosition;
    554          }
    555          
    556          /**
    557            * @brief  Drives the SMBusAlert pin high or low.
    558            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    559            * @param  I2C_SMBusAlert: SMBusAlert pin state.
    560            *          This parameter can be one of the following values:
    561            *            @arg I2C_SMBusAlert_High: SMBAlert pin high
    562            *            @arg I2C_SMBusAlert_Low: SMBAlert pin Low
    563            * @retval None
    564            */
    565          void I2C_SMBusAlertConfig(I2C_T* I2Cx, I2C_SMBusAlert_T I2C_SMBusAlert)
    566          {
    567          
    568            /* Check functions parameters */
    569            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
    570          
    571            if (I2C_SMBusAlert != I2C_SMBusAlert_High)
    572            {
    573              /* SMBus Alert pin low */
    574              I2Cx->CR2 |= (uint8_t)I2C_CR2_ALERT;
    575            }
    576            else /*I2C_SMBusAlert = I2C_SMBusAlert_High */
    577            {
    578              /* SMBus Alert pin high */
    579              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_ALERT);
    580            }
    581          }
    582          
    583          /**
    584            * @brief  Selects I2C fast mode duty cycle.
    585            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    586            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    587            *          This parameter can be one of the following values:
    588            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    589            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    590            * @retval None
    591            */
    592          void I2C_FastModeDutyCycleConfig(I2C_T* I2Cx, I2C_DutyCycle_T I2C_DutyCycle)
    593          {
    594          
    595            /* Check function parameters */
    596            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
    597          
    598            if (I2C_DutyCycle == I2C_DutyCycle_16_9)
    599            {
    600              /* I2C fast mode Tlow/Thigh = 16/9 */
    601              I2Cx->CCRH |= I2C_CCRH_DUTY;
    602            }
    603            else /* I2C_DUTYCYCLE_2 */
    604            {
    605              /* I2C fast mode Tlow/Thigh = 2 */
    606              I2Cx->CCRH &= (uint8_t)(~I2C_CCRH_DUTY);
    607            }
    608          }
    609          
    610          /**
    611            * @brief  Transmits the 7-bit address (to select the) slave device.
    612            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    613            * @param  Address: Specifies the slave address which will be transmitted.
    614            * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
    615            *         or a Receiver.
    616            *          This parameter can be one of the following values
    617            *            @arg I2C_Direction_Transmitter: Transmitter mode
    618            *            @arg I2C_Direction_Receiver: Receiver mode
    619            * @retval None
    620            */
    621          void I2C_Send7bitAddress(I2C_T* I2Cx, uint8_t Address, I2C_Direction_T I2C_Direction)
    622          {
    623            /* Check function parameters */
    624            assert_param(IS_I2C_ADDRESS(Address));
    625            assert_param(IS_I2C_DIRECTION(I2C_Direction));
    626          
    627            /* Test on the direction to set/reset the read/write bit */
    628            if (I2C_Direction != I2C_Direction_Transmitter)
    629            {
    630              /* Set the address bit0 for read */
    631              Address |= OAR1_ADD0_Set;
    632            }
    633            else
    634            {
    635              /* Reset the address bit0 for write */
    636              Address &= OAR1_ADD0_Reset;
    637            }
    638            /* Send the address */
    639            I2Cx->DR = Address;
    640          }
    641          
    642          /**
    643            * @}
    644            */
    645          
    646          /** @defgroup I2C_Group2 Data transfers functions
    647           *  @brief   Data transfers functions
    648           *
    649          @verbatim
    650           ===============================================================================
    651                                  Data transfers functions
    652           ===============================================================================
    653          
    654          @endverbatim
    655            * @{
    656            */
    657          
    658          /**
    659            * @brief  Send a byte by writing in the DR register.
    660            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    661            * @param  Data: Byte to be sent.
    662            * @retval None
    663            */
    664          void I2C_SendData(I2C_T* I2Cx, uint8_t Data)
    665          {
    666            /* Write in the DR register the data to be sent */
    667            I2Cx->DR = Data;
    668          }
    669          
    670          /**
    671            * @brief  Returns the most recent received data.
    672            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    673            * @param  None
    674            * @retval The value of the received byte data.
    675            */
    676          uint8_t I2C_ReceiveData(I2C_T* I2Cx)
    677          {
    678            /* Return the data present in the DR register */
    679            return ((uint8_t)I2Cx->DR);
    680          }
    681          
    682          /**
    683            * @}
    684            */
    685          
    686          /** @defgroup I2C_Group3 PEC management functions
    687           *  @brief   PEC management functions
    688           *
    689          @verbatim
    690           ===============================================================================
    691                                   PEC management functions
    692           ===============================================================================
    693          
    694          @endverbatim
    695            * @{
    696            */
    697          
    698          /**
    699            * @brief  Enables or disables PEC transfer.
    700            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    701            * @param  NewState: indicates the PEC  transfer state.
    702            *         This parameter can be: ENABLE or DISABLE.
    703            * @retval None
    704            */
    705          void I2C_TransmitPEC(I2C_T* I2Cx, FunctionalState NewState)
    706          {
    707            /* Check the parameters */
    708            assert_param(IS_FUNCTIONAL_STATE(NewState));
    709          
    710            if (NewState != DISABLE)
    711            {
    712              /* Enable the PEC transmission */
    713              I2Cx->CR2 |= I2C_CR2_PEC;
    714            }
    715            else
    716            {
    717              /* Disable the PEC transmission */
    718              I2Cx->CR2 &= (uint8_t)(~I2C_CR2_PEC);
    719            }
    720          }
    721          
    722          /**
    723            * @brief  Enables or disables PEC calculation.
    724            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    725            * @param  NewState: indicates the PEC  calculation state.
    726            *         This parameter can be: ENABLE or DISABLE.
    727            * @retval None
    728            */
    729          void I2C_CalculatePEC(I2C_T* I2Cx, FunctionalState NewState)
    730          {
    731            /* Check the parameters */
    732            assert_param(IS_FUNCTIONAL_STATE(NewState));
    733          
    734            if (NewState != DISABLE)
    735            {
    736              /* Enable PEC calculation */
    737              I2Cx->CR1 |= I2C_CR1_ENPEC;
    738            }
    739            else
    740            {
    741              /* Disable PEC calculation */
    742              I2Cx->CR1 &= (uint8_t)(~I2C_CR1_ENPEC);
    743            }
    744          }
    745          
    746          /**
    747            * @brief  Selects I2C PEC position..
    748            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    749            * @param  I2C_PECPosition:PEC position.
    750            *          This parameter can be one of the following values:
    751            *            @arg I2C_PECPosition_Current: Current byte in shift register is PEC
    752            *            @arg I2C_PECPosition_Next: Next  byte in shift register is PEC
    753            * @retval None
    754            */
    755          void I2C_PECPositionConfig(I2C_T* I2Cx, I2C_PECPosition_T I2C_PECPosition)
    756          {
    757            /* Check the parameters */
    758            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
    759          
    760            /* Clear the I2C PEC position */
    761            I2Cx->CR2 &= (uint8_t)(~I2C_CR2_POS);
    762            /* Configure the specified I2C PEC position*/
    763            I2Cx->CR2 |= (uint8_t)I2C_PECPosition;
    764          }
    765          
    766          /**
    767            * @brief  Returns PEC value.
    768            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    769            * @param  None
    770            * @retval The value of the PEC.
    771            */
    772          uint8_t I2C_GetPEC(I2C_T* I2Cx)
    773          {
    774            /* Return the PEC value */
    775            return (I2Cx->PECR);
    776          }
    777          
    778          /**
    779            * @}
    780            */
    781          
    782          /** @defgroup I2C_Group4 DMA transfers management functions
    783           *  @brief   DMA transfers management functions
    784           *
    785          @verbatim
    786           ===============================================================================
    787                                   DMA transfers management functions
    788           ===============================================================================
    789            This section provides functions allowing to configure the I2C DMA channels
    790            requests.
    791          
    792          @endverbatim
    793            * @{
    794            */
    795          
    796          /**
    797            * @brief  Enables or disables the I2C DMA requests .
    798            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    799            * @param  NewState: Indicate the new I2C DMA state.
    800            *         This parameter can be: ENABLE or DISABLE.
    801            * @retval None
    802            */
    803          void I2C_DMACmd(I2C_T* I2Cx, FunctionalState NewState)
    804          {
    805            /* Check the parameters */
    806            assert_param(IS_FUNCTIONAL_STATE(NewState));
    807          
    808            if (NewState != DISABLE)
    809            {
    810              /* Enable I2C DMA requests */
    811              I2Cx->ITR |= I2C_ITR_DMAEN;
    812            }
    813            else
    814            {
    815              /* Disable I2C DMA requests */
    816              I2Cx->ITR &= (uint8_t)(~I2C_ITR_DMAEN);
    817            }
    818          }
    819          
    820          /**
    821            * @brief  Specifies that the next DMA transfer is the last one .
    822            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    823            * @param  NewState: Indicate the new I2C DMA state.
    824            *         This parameter can be: ENABLE or DISABLE.
    825            * @retval None
    826            */
    827          void I2C_DMALastTransferCmd(I2C_T* I2Cx, FunctionalState NewState)
    828          {
    829            /* Check the parameters */
    830            assert_param(IS_FUNCTIONAL_STATE(NewState));
    831          
    832            if (NewState != DISABLE)
    833            {
    834              /* Enable I2C DMA requests */
    835              I2Cx->ITR |= I2C_ITR_LAST;
    836            }
    837            else
    838            {
    839              /* Disable I2C DMA requests */
    840              I2Cx->ITR &= (uint8_t)(~I2C_ITR_LAST);
    841            }
    842          }
    843          
    844          /**
    845            * @}
    846            */
    847          
    848          /** @defgroup I2C_Group5 Interrupts events and flags management functions
    849           *  @brief   Interrupts, events and flags management functions
    850           *
    851          @verbatim
    852           ===============================================================================
    853                          Interrupts, events and flags management functions
    854           ===============================================================================
    855            This section provides functions allowing to configure the I2C Interrupts
    856            sources and check or clear the flags or pending bits status.
    857            The user should identify which mode will be used in his application to manage
    858            the communication: Polling mode, Interrupt mode or DMA mode.
    859          
    860           ===============================================================================
    861                                    I2C State Monitoring Functions
    862           ===============================================================================
    863           This I2C driver provides three different ways for I2C state monitoring
    864            depending on the application requirements and constraints:
    865          
    866          
    867               1. Basic state monitoring (Using I2C_CheckEvent() function)
    868               -----------------------------------------------------------
    869              It compares the status registers (SR1, SR2 and SR3) content to a given event
    870              (can be the combination of one or more flags).
    871              It returns SUCCESS if the current status includes the given flags
    872              and returns ERROR if one or more flags are missing in the current status.
    873              - When to use:
    874                - This function is suitable for most applications as well as for startup
    875                activity since the events are fully described in the product reference manual
    876                (RM0031).
    877                - It is also suitable for users who need to define their own events.
    878              - Limitations:
    879                - If an error occurs (ie. error flags are set besides to the monitored flags),
    880                  the I2C_CheckEvent() function may return SUCCESS despite the communication
    881                  hold or corrupted real state.
    882                  In this case, it is advised to use error interrupts to monitor the error
    883                  events and handle them in the interrupt IRQ handler.
    884          
    885                  @note
    886                  For error management, it is advised to use the following functions:
    887                    - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    888                    - I2Cx_IRQHandler() which is called when the I2C interrupts occur.
    889                      Where x is the peripheral instance (I2C1,...)
    890                   - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into the
    891                     I2Cx_IRQHandler() function in order to determine which error occurred.
    892                    - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()
    893                      and/or I2C_GenerateStop() in order to clear the error flag and
    894                      source and return to correct communication status.
    895          
    896          
    897               2. Advanced state monitoring (Using the function I2C_GetLastEvent())
    898               --------------------------------------------------------------------
    899               Using the function I2C_GetLastEvent() which returns the image of both SR1
    900               & SR3 status registers in a single word (uint16_t) (Status Register 3 value
    901               is shifted left by 8 bits and concatenated to Status Register 1).
    902               - When to use:
    903                 - This function is suitable for the same applications above but it allows to
    904                   overcome the limitations of I2C_GetFlagStatus() function (see below).
    905                   The returned value could be compared to events already defined in the
    906                   library (stm8l15x_i2c.h) or to custom values defined by user.
    907                 - This function is suitable when multiple flags are monitored at the same time.
    908                 - At the opposite of I2C_CheckEvent() function, this function allows user to
    909                   choose when an event is accepted (when all events flags are set and no
    910                   other flags are set or just when the needed flags are set like
    911                   I2C_CheckEvent() function).
    912               - Limitations:
    913                 - User may need to define his own events.
    914                 - Same remark concerning the error management is applicable for this
    915                   function if user decides to check only regular communication flags (and
    916                   ignores error flags).
    917          
    918          
    919               3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
    920               -----------------------------------------------------------------------
    921               Using the function I2C_GetFlagStatus() which simply returns the status of
    922               one single flag (ie. I2C_FLAG_RXNE ...).
    923               - When to use:
    924                  - This function could be used for specific applications or in debug phase.
    925                  - It is suitable when only one flag checking is needed (most I2C events
    926                    are monitored through multiple flags).
    927               - Limitations:
    928                  - When calling this function, the Status register is accessed. Some flags are
    929                    cleared when the status register is accessed. So checking the status
    930                    of one Flag, may clear other ones.
    931                  - Function may need to be called twice or more in order to monitor one
    932                    single event.
    933          
    934            For detailed description of Events, please refer to section I2C_Events in
    935            stm8l15x_i2c.h file.
    936          
    937          
    938          @endverbatim
    939            * @{
    940            */
    941          
    942          /**
    943            * @brief  Enables or disables the specified I2C interrupt.
    944            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    945            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled.
    946            *          This parameter can be any combination of the following values:
    947            *            @arg I2C_IT_BUF: Buffer interrupt mask
    948            *            @arg I2C_IT_EVT: Event interrupt mask
    949            *            @arg I2C_IT_ERR: Error interrupt mask
    950            * @param  NewState: State of the interrupt.
    951            *         This parameter can be: ENABLE or DISABLE.
    952            * @retval None
    953            */
    954          void I2C_ITConfig(I2C_T* I2Cx, I2C_IT_T I2C_IT, FunctionalState NewState)
    955          {
    956            /* Check functions parameters */
    957            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
    958            assert_param(IS_FUNCTIONAL_STATE(NewState));
    959          
    960            if (NewState != DISABLE)
    961            {
    962              /* Enable the selected I2C interrupts */
    963              I2Cx->ITR |= (uint8_t)I2C_IT;
    964            }
    965            else /* NewState == DISABLE */
    966            {
    967              /* Disable the selected I2C interrupts */
    968              I2Cx->ITR &= (uint8_t)(~(uint8_t)I2C_IT);
    969            }
    970          }
    971          
    972          /**
    973            * @brief  Reads the specified I2C register and returns its value.
    974            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
    975            * @param  I2C_Register: specifies the register to read.
    976            *          This parameter can be one of the following values:
    977            *            @arg I2C_Register_CR1: CR1 register.
    978            *            @arg I2C_Register_CR2: CR2 register.
    979            *            @arg I2C_Register_FREQR: Frequency register.
    980            *            @arg I2C_Register_OARL: Own address register LSB.
    981            *            @arg I2C_Register_OARH: Own address register MSB
    982            *            @arg I2C_Register_DR: DR register.
    983            *            @arg I2C_Register_SR1: SR1 register.
    984            *            @arg I2C_Register_SR2: SR2 register.
    985            *            @arg I2C_Register_SR3: SR3 register.
    986            *            @arg I2C_Register_ITR: Interrupt and DMA register.
    987            *            @arg I2C_Register_CCRL: Clock control register low.
    988            *            @arg I2C_Register_CCRH: Clock control register high.
    989            *            @arg I2C_Register_TRISER: TRISE register.
    990            *            @arg I2C_Register_PECR: PEC register.
    991            * @retval The value of the read register.
    992            */
    993          
    994          uint8_t I2C_ReadRegister(I2C_T* I2Cx, I2C_Register_T I2C_Register)
    995          {
    996            __IO uint16_t tmp = 0;
    997            /* Check the parameters */
    998            assert_param(IS_I2C_REGISTER(I2C_Register));
    999          
   1000            tmp = (uint16_t) I2Cx;
   1001            tmp += I2C_Register;
   1002          
   1003            /* Return the selected register value */
   1004            return (*(__IO uint8_t *) tmp);
   1005          }
   1006          
   1007          
   1008          /**
   1009           ===============================================================================
   1010                                    1. Basic state monitoring
   1011           ===============================================================================
   1012           */
   1013          
   1014          /**
   1015            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1016            *   as parameter.
   1017            * @param  I2Cx: where x can be 1 to select the I2C peripheral.
   1018            * @param  I2C_EVENT: specifies the event to be checked.
   1019            *          This parameter can be one of the following values:
   1020            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1021            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1022            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1023            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1024            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1025            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1026            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1027            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1028            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1029            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1030            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6
   1031            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1032            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1033            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1034            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1035            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1036            *
   1037            * @note: For detailed description of Events, please refer to section
   1038            *    I2C_Events in stm8l15x_i2c.h file.
   1039            *
   1040            * @retval An ErrorStatus enumeration value:
   1041            *         - SUCCESS: Last event is equal to the I2C_EVENT
   1042            *         - ERROR: Last event is different from the I2C_EVENT
   1043            */
   1044          ErrorStatus I2C_CheckEvent(I2C_T* I2Cx, I2C_Event_T I2C_Event)
   1045          {
   1046            __IO uint16_t lastevent = 0x00;
   1047            uint8_t flag1 = 0x00 ;
   1048            uint8_t flag2 = 0x00;
   1049            ErrorStatus status = ERROR;
   1050          
   1051            /* Check the parameters */
   1052            assert_param(IS_I2C_EVENT(I2C_Event));
   1053          
   1054            if (I2C_Event == I2C_EVENT_SLAVE_ACK_FAILURE)
   1055            {
   1056              lastevent = I2Cx->SR2 & I2C_SR2_AF;
   1057            }
   1058            else
   1059            {
   1060              flag1 = I2Cx->SR1;
   1061              flag2 = I2Cx->SR3;
   1062              lastevent = ((uint16_t)((uint16_t)flag2 << (uint16_t)8) | (uint16_t)flag1);
   1063            }
   1064            /* Check whether the last event is equal to I2C_EVENT */
   1065            if (((uint16_t)lastevent & (uint16_t)I2C_Event) == (uint16_t)I2C_Event)
   1066            {
   1067              /* SUCCESS: last event is equal to I2C_EVENT */
   1068              status = SUCCESS;
   1069            }
   1070            else
   1071            {
   1072              /* ERROR: last event is different from I2C_EVENT */
   1073              status = ERROR;
   1074            }
   1075          
   1076            /* Return status */
   1077            return status;
   1078          }
   1079          
   1080          /**
   1081           ===============================================================================
   1082                                    2. Advanced state monitoring
   1083           ===============================================================================
   1084           */
   1085          
   1086          /**
   1087            * @brief  Returns the last I2C Event.
   1088            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1089            *
   1090            * @note: For detailed description of Events, please refer to section
   1091            *    I2C_Events in stm8l15xx_i2c.h file.
   1092            *
   1093            * @retval The last event
   1094            */
   1095          I2C_Event_T I2C_GetLastEvent(I2C_T* I2Cx)
   1096          {
   1097            __IO uint16_t lastevent = 0;
   1098            uint16_t flag1 = 0;
   1099            uint16_t flag2 = 0;
   1100          
   1101            if ((I2Cx->SR2 & I2C_SR2_AF) != 0x00)
   1102            {
   1103              lastevent = I2C_EVENT_SLAVE_ACK_FAILURE;
   1104            }
   1105            else
   1106            {
   1107              /* Read the I2C status register */
   1108              flag1 = I2Cx->SR1;
   1109              flag2 = I2Cx->SR3;
   1110          
   1111              /* Get the last event value from I2C status register */
   1112              lastevent = ((uint16_t)((uint16_t)flag2 << 8) | (uint16_t)flag1);
   1113            }
   1114            /* Return status */
   1115            return (I2C_Event_T)lastevent;
   1116          }
   1117          
   1118          /**
   1119           ===============================================================================
   1120                                    3. Flag-based state monitoring
   1121           ===============================================================================
   1122           */
   1123          
   1124          /**
   1125            * @brief  Checks whether the specified I2C flag is set or not.
   1126            * @param  I2Cx: where x can be 1 select the I2C peripheral.
   1127            * @param  I2C_FLAG: specifies the flag to check.
   1128            *          This parameter can be one of the following values:
   1129            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1130            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1131            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1132            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1133            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1134            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1135            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1136            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1137            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1138            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1139            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1140            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1141            *            @arg I2C_FLAG_BERR: Bus error flag
   1142            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1143            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1144            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1145            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1146            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1147            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) �ADSL�
   1148            *   Address matched flag (Slave mode)�ENDAD�
   1149            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1150            * @retval The new state of I2C_FLAG (SET or RESET).
   1151            */
   1152          FlagStatus I2C_GetFlagStatus(I2C_T* I2Cx, I2C_FLAG_T I2C_FLAG)
   1153          {
   1154            uint8_t tempreg = 0;
   1155            uint8_t regindex = 0;
   1156            FlagStatus bitstatus = RESET;
   1157          
   1158            /* Check the parameters */
   1159            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   1160          
   1161            /* Read flag register index */
   1162            regindex = (uint8_t)((uint16_t)I2C_FLAG >> 8);
   1163            /* Check SRx index */
   1164            switch (regindex)
   1165            {
   1166                /* Returns whether the status register to check is SR1 */
   1167              case 0x01:
   1168                tempreg = (uint8_t)I2Cx->SR1;
   1169                break;
   1170          
   1171                /* Returns whether the status register to check is SR2 */
   1172              case 0x02:
   1173                tempreg = (uint8_t)I2Cx->SR2;
   1174                break;
   1175          
   1176                /* Returns whether the status register to check is SR3 */
   1177              case 0x03:
   1178                tempreg = (uint8_t)I2Cx->SR3;
   1179                break;
   1180          
   1181              default:
   1182                break;
   1183            }
   1184          
   1185            /* Check the status of the specified I2C flag */
   1186            if ((tempreg & (uint8_t)I2C_FLAG ) != 0)
   1187            {
   1188              /* Flag is set */
   1189              bitstatus = SET;
   1190            }
   1191            else
   1192            {
   1193              /* Flag is reset */
   1194              bitstatus = RESET;
   1195            }
   1196            /* Return the flag status */
   1197            return bitstatus;
   1198          }
   1199          /**
   1200            * @brief  Clear flags
   1201            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1202            * @param  I2C_Flag: Specifies the flag to clear
   1203            *          This parameter can be any combination of the following values:
   1204            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1205            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1206            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1207            *            @arg I2C_FLAG_WUFH: Wakeup from Halt
   1208            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1209            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1210            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1211            *            @arg I2C_FLAG_BERR: Bus error flag.
   1212            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation
   1213            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation
   1214            *          to I2C_CR2 register.
   1215            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read
   1216            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the
   1217            *          second byte of the address in DR register.
   1218            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read
   1219            *         operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a
   1220            *         read/write to I2C_DR register (I2C_SendData()).
   1221            * @note   ADDR (Address sent) is cleared by software sequence: a read operation
   1222            *         to I2C_SR1 register(I2C_GetFlagStatus()) followed by a read operation
   1223            *         to I2C_SR3 register ((void)(I2Cx->SR3)).
   1224            * @note   SB (Start Bit) is cleared software sequence: a read operation to
   1225            *         I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation
   1226            *         to I2C_DR register (I2C_SendData()).
   1227            * @retval None
   1228            */
   1229          void I2C_ClearFlag(I2C_T* I2Cx, I2C_FLAG_T I2C_FLAG)
   1230          {
   1231            uint16_t flagpos = 0;
   1232            /* Check the parameters */
   1233            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   1234          
   1235            /* Get the I2C flag position */
   1236            flagpos = (uint16_t)I2C_FLAG & FLAG_Mask;
   1237            /* Clear the selected I2C flag */
   1238            I2Cx->SR2 = (uint8_t)((uint16_t)(~flagpos));
   1239          }
   1240          
   1241          /**
   1242            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1243            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1244            * @param  I2C_IT: specifies the interrupt source to check.
   1245            *            This parameter can be one of the following values:
   1246            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1247            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1248            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1249            *            @arg I2C_IT_WUFH: Wakeup from Halt
   1250            *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1251            *            @arg I2C_IT_AF: Acknowledge failure flag
   1252            *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1253            *            @arg I2C_IT_BERR: Bus error flag
   1254            *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1255            *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1256            *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1257            *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1258            *            @arg I2C_IT_BTF: Byte transfer finished flag
   1259            *            @arg I2C_IT_ADDR: Address sent flag (Master mode) �ADSL�
   1260            *                              Address matched flag (Slave mode)�ENDAD�
   1261            *            @arg I2C_IT_SB: Start bit flag (Master mode)
   1262            * @retval The new state of I2C_IT
   1263            */
   1264          ITStatus I2C_GetITStatus(I2C_T* I2Cx, I2C_IT_T I2C_IT)
   1265          {
   1266            ITStatus bitstatus = RESET;
   1267            __IO uint8_t enablestatus = 0;
   1268            uint16_t tempregister = 0;
   1269          
   1270            /* Check the parameters */
   1271            assert_param(IS_I2C_GET_IT(I2C_IT));
   1272          
   1273            tempregister = (uint8_t)( ((uint16_t)((uint16_t)I2C_IT & ITEN_Mask)) >> 8);
   1274          
   1275            /* Check if the interrupt source is enabled or not */
   1276            enablestatus = (uint8_t)(I2Cx->ITR & ( uint8_t)tempregister);
   1277          
   1278            if ((uint16_t)((uint16_t)I2C_IT & REGISTER_Mask) == REGISTER_SR1_Index)
   1279            {
   1280              /* Check the status of the specified I2C flag */
   1281              if (((I2Cx->SR1 & (uint8_t)I2C_IT) != RESET) && enablestatus)
   1282              {
   1283                /* I2C_IT is set */
   1284                bitstatus = SET;
   1285              }
   1286              else
   1287              {
   1288                /* I2C_IT is reset */
   1289                bitstatus = RESET;
   1290              }
   1291            }
   1292            else
   1293            {
   1294              /* Check the status of the specified I2C flag */
   1295              if (((I2Cx->SR2 & (uint8_t)I2C_IT) != RESET) && enablestatus)
   1296              {
   1297                /* I2C_IT is set */
   1298                bitstatus = SET;
   1299              }
   1300              else
   1301              {
   1302                /* I2C_IT is reset */
   1303                bitstatus = RESET;
   1304              }
   1305            }
   1306            /* Return the I2C_IT status */
   1307            return  bitstatus;
   1308          }
   1309          /**
   1310            * @brief  Clear IT pending bit
   1311            * @param  I2Cx: where x can be 1 to select the specified I2C peripheral.
   1312            * @param  I2C_IT: specifies the interrupt pending bit to clear.
   1313            *            This parameter can be any combination of the following values:
   1314            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1315            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1316            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1317            *            @arg I2C_IT_WUFH: Wakeup from Halt
   1318            *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1319            *            @arg I2C_IT_AF: Acknowledge failure interrupt
   1320            *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1321            *            @arg I2C_IT_BERR: Bus error interrupt
   1322            *
   1323            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation
   1324            *         to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
   1325            *         I2C_CR2 register (I2C_AcknowledgeConfig() to configure the I2C peripheral Acknowledge).
   1326            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read
   1327            *         operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second
   1328            *         byte of the address in I2C_DR register.
   1329            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read
   1330            *         operation to I2C_SR1 register (I2C_GetITStatus()) followed by a read/write to
   1331            *         I2C_DR register (I2C_SendData()).
   1332            * @note   ADDR (Address sent) is cleared by software sequence: a read operation
   1333            *         to I2C_SR1 register (I2C_GetITStatus()) followed by a read operation
   1334            *         to I2C_SR3 register ((void)(I2Cx->SR3)).
   1335            * @note   SB (Start Bit) is cleared by software sequence: a read operation to
   1336            *         I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to
   1337            *         I2C_DR register (I2C_SendData()).
   1338            * @retval None
   1339            */
   1340          void I2C_ClearITPendingBit(I2C_T* I2Cx, I2C_IT_T I2C_IT)
   1341          {
   1342            uint16_t flagpos = 0;
   1343          
   1344            /* Check the parameters */
   1345            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   1346          
   1347            /* Get the I2C flag position */
   1348            flagpos = (uint16_t)I2C_IT & FLAG_Mask;
   1349          
   1350            /* Clear the selected I2C flag */
   1351            I2Cx->SR2 = (uint8_t)((uint16_t)~flagpos);
   1352          }
   1353          /**
   1354            * @}
   1355            */
   1356          
   1357          /**
   1358            * @}
   1359            */
   1360          
   1361          /**
   1362            * @}
   1363            */
   1364          
   1365          /**
   1366            * @}
   1367            */
   1368          
   1369          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      21  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine2
      13  I2C_ARPCmd
       5  I2C_AckPositionConfig
      14  I2C_AcknowledgeConfig
      13  I2C_CalculatePEC
      87  I2C_CheckEvent
       8  I2C_ClearFlag
       8  I2C_ClearITPendingBit
      13  I2C_Cmd
      16  I2C_DMACmd
      16  I2C_DMALastTransferCmd
      71  I2C_DeInit
      16  I2C_DualAddressCmd
      17  I2C_FastModeDutyCycleConfig
      13  I2C_GeneralCallCmd
      14  I2C_GenerateSTART
      14  I2C_GenerateSTOP
      56  I2C_GetFlagStatus
      45  I2C_GetITStatus
      57  I2C_GetLastEvent
       5  I2C_GetPEC
      15  I2C_ITConfig
     288  I2C_Init
      18  I2C_OwnAddress2Config
       5  I2C_PECPositionConfig
      21  I2C_ReadRegister
       5  I2C_ReceiveData
      14  I2C_SMBusAlertConfig
      15  I2C_Send7bitAddress
       5  I2C_SendData
      14  I2C_SoftwareResetCmd
      13  I2C_StretchClockCmd
      14  I2C_TransmitPEC

 
 973 bytes in section .far_func.text
 
 973 bytes of CODE memory

Errors: none
Warnings: none
