###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:19
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_rtc.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_rtc.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_rtc.lst
#    Object file  =  H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_rtc.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:           
      9            *           - Initialization
     10            *           - Calendar (Time and Date) configuration
     11            *           - Alarm configuration
     12            *           - WakeUp Timer configuration
     13            *           - Daylight Saving configuration
     14            *           - Output pin Configuration
     15            *           - Smooth Calibration configuration
     16            *           - Tampers configuration
     17            *           - Output Type configuration
     18            *           - Interrupts and flags management       
     19            *                     
     20            *  @verbatim
     21            *       
     22            *          ===================================================================      
     23            *                                    RTC Domain Reset
     24            *          ===================================================================          
     25            *          After power-on reset, the RTC domain (RTC registers) is reset.        
     26            *         
     27            *          ===================================================================      
     28            *                                  RTC Operating Condition      
     29            *          ===================================================================            
     30            *          As long as the supply voltage remains in the operating range, 
     31            *          the RTC never stops, regardless of the device status (Run mode, 
     32            *          low power modes or under reset).
     33            *              
     34            *          ===================================================================      
     35            *                                   RTC Domain Access     
     36            *          ===================================================================         
     37            *          After reset, the RTC domain (RTC registers) is protected against 
     38            *          possible stray write accesses. 
     39            *          To enable access to the RTC registers, proceed as follows:
     40            *            - Select the RTC clock source using the CLK_RTCClockConfig()
     41            *              function : HSE, HSI, LSE or LSI.
     42            *              CLK_RTCClockConfig(CLK_RTCCLKSource_HSI, CLK_RTCCLKDiv_1)    
     43            *            - Enable RTC Clock using the CLK_PeripheralClockConfig() function 
     44            *               : CLK_PeripheralClockConfig(CLK_Peripheral_RTC, ENABLE).
     45            *              
     46            *          ===================================================================      
     47            *                                   RTC Driver: how to use it
     48            *          ===================================================================          
     49            *            - Enable the RTC domain access (see description in the section above)
     50            *            - Configure the RTC Prescaler (Asynchronous and Synchronous) and
     51            *              RTC hour format using the RTC_Init() function.
     52            *                
     53            *          Time and Date configuration
     54            *          ===========================    
     55            *            - To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     56            *              and RTC_SetDate() functions.
     57            *            - To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate()
     58            *              functions.
     59            *            - Use the RTC_DayLightSavingConfig() function to add or sub 1hour
     60            *              to the RTC Calendar.    
     61            *                
     62            *          Alarm configuration
     63            *          ===================    
     64            *            - To configure the RTC Alarm use the RTC_SetAlarm() function.
     65            *            - Enable the selected RTC Alarm using the RTC_AlarmCmd() function  
     66            *            - To read the RTC Alarm, use the RTC_GetAlarm() function.
     67            *              
     68            *          RTC Wakeup configuration
     69            *          ========================    
     70            *            - Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
     71            *              function.
     72            *            - Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() 
     73            *              function  
     74            *            - Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
     75            *            - To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
     76            *              function.
     77            *                
     78            *          Outputs configuration
     79            *          =====================  
     80            *          The RTC has 2 different outputs:
     81            *            - AFO_ALARM: this output is used to manage the RTC Alarm and 
     82            *              WaKeUp signals.          
     83            *              To output the selected RTC signal on RTC_ALARM pin, use the 
     84            *              RTC_OutputConfig() function.                
     85            *            - AFO_CALIB: this output is used to manage the RTC Clock divided 
     86            *              by 64 (512Hz) signal or divided by 32768 (1Hz) which can be 
     87            *              configured using RTC_CalibOutputConfig() function.
     88            *              To output the RTC Clock on RTC_CALIB pin, use the 
     89            *              RTC_CalibOutputCmd() function.                
     90            *                                                           
     91            *          Smooth Calibration configuration                    
     92            *          =================================    
     93            *            - Configure the RTC Smooth Calibration Value and the corresponding
     94            *              sign using the RTC_SmoothCalibConfig() function.
     95          
     96            *                
     97            *
     98            *          Tamper configuration                     
     99            *          ====================    
    100            *            - Configure the RTC Tamper Level using the RTC_TamperConfig() 
    101            *              function.
    102            *            - Enable the RTC Tamper using the RTC_TamperCmd() function.
    103            *
    104            *                                  
    105            *          ===================================================================      
    106            *                                  RTC and low power modes
    107            *          =================================================================== 
    108            *           The MCU can be woken up from a low power mode by an RTC alternate 
    109            *           function.
    110            *           The RTC alternate functions are the RTC alarms, 
    111            *           RTC wakeup and RTC tamper event detection.
    112            *           These RTC alternate functions can wake up the system from the 
    113            *           lowpower modes.
    114            *           The system can also wake up from low power modes without depending 
    115            *           on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    116            *           or the RTC wakeup events.
    117            *           The RTC provides a programmable time base for waking up from the 
    118            *           halt or wfe or wfi modes at regular intervals.
    119            *           
    120            *                         
    121            *  @endverbatim
    122            *                      
    123            ******************************************************************************
    124            * @attention
    125            *
    126            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
    127            *
    128            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    129            * You may not use this file except in compliance with the License.
    130            * You may obtain a copy of the License at:
    131            *
    132            *        http://www.st.com/software_license_agreement_liberty_v2
    133            *
    134            * Unless required by applicable law or agreed to in writing, software 
    135            * distributed under the License is distributed on an "AS IS" BASIS, 
    136            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    137            * See the License for the specific language governing permissions and
    138            * limitations under the License.
    139            *
    140            ******************************************************************************
    141            */    
    142          
    143          /* Includes ------------------------------------------------------------------*/
    144          #include "stm8l15x_rtc.h"
    145          
    146          /** @addtogroup STM8L15x_StdPeriph_Driver
    147            * @{
    148            */
    149            
    150          /** @defgroup RTC 
    151            * @brief RTC driver modules
    152            * @{
    153            */
    154            
    155          /* Private typedef -----------------------------------------------------------*/
    156          /* Private define ------------------------------------------------------------*/
    157          #define INIT_TIMEOUT       ((uint16_t)0xFFFF)
    158          #define RSF_TIMEOUT        ((uint16_t)0xFFFF)
    159          #define INITF_TIMEOUT      ((uint16_t)0xFFFF)
    160          #define WUTWF_TIMEOUT      ((uint16_t)0xFFFF)
    161          #define ALRAWF_TIMEOUT     ((uint16_t)0xFFFF)
    162          #define RECALPF_TIMEOUT    ((uint16_t)0xFFFF)
    163          #define SHPF_TIMEOUT       ((uint16_t)0xFFFF)
    164          
    165          #define TEN_VALUE_BCD      ((uint8_t)0x10)
    166          #define TEN_VALUE_BIN      ((uint8_t)0x0A)
    167          
    168          /* Private macro -------------------------------------------------------------*/
    169          /* Private variables ---------------------------------------------------------*/
    170          
    171          /** @defgroup RTC_Private_Functions_Prototype
    172            * @{
    173            */
    174          static uint8_t ByteToBcd2(uint8_t Value);
    175          static uint8_t Bcd2ToByte(uint8_t Value);
    176          
    177          /**
    178           * @}
    179           */
    180          
    181          /** @defgroup RTC_Private_Functions
    182            * @{
    183            */
    184          
    185          /** @defgroup RTC_Group1 Initialization and Configuration functions
    186           *  @brief   Initialization and Configuration functions 
    187           *
    188          @verbatim   
    189           ===============================================================================
    190                           Initialization and Configuration functions
    191           ===============================================================================  
    192          
    193            This section provide functions allowing to initialize and configure the RTC
    194            Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    195            Write protection, enter and exit the RTC initialization mode, RTC registers
    196            synchronization check and reference clock detection enable.
    197            
    198            1. The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    199               split into 2 programmable prescaler to minimize power consumption.
    200               - A 7-bit asynchronous prescaler and A 13-bit or 15-bit synchronous 
    201                 prescaler depending to density of the mcu package.
    202               - When both prescaler are used, it is recommended to configure the 
    203                 asynchronous prescaler to a high value to minimize consumption.
    204          
    205            2. All RTC registers are Write protected. Writing to the RTC registers
    206               is enabled by writing a key into the Write Protection register, RTC_WPR.
    207          
    208            3. To Configure the RTC Calendar, user application should enter initialization
    209               mode. In this mode, the Calendar counter is stopped and its value can be 
    210               updated. When the initialization sequence is complete, the Calendar restarts 
    211               counting after 4 RTCCLK cycles.
    212          
    213            4. To read the Calendar through the shadow registers after Calendar initialization,
    214               Calendar update or after wakeup from low power modes the software must first 
    215               clear the RSF flag. The software must then wait until it is set again before 
    216               reading the Calendar, which means that the Calendar registers have been 
    217               correctly copied into the RTC_TR and RTC_DR shadow registers.
    218               The RTC_WaitForSynchro() function implements the above software sequence 
    219               (RSF clear and RSF check).
    220          
    221          @endverbatim
    222            * @{
    223            */
    224          /**
    225          * @brief  Deinitializes the RTC registers to their default reset values.
    226          * @note   This function doesn't reset the RTC Clock source.  
    227          * @param  None
    228          * @retval An ErrorStatus enumeration value:
    229          *          - SUCCESS: RTC registers are deinitialized
    230          *          - ERROR: RTC registers are not deinitialized
    231          */
    232          ErrorStatus RTC_DeInit(void)
    233          {
    234            ErrorStatus status = ERROR;
    235            uint16_t wutwfcount = 0;
    236            uint16_t recalpfcount = 0;
    237          
    238            /* Disable the write protection for RTC registers */
    239            RTC->WPR = 0xCA;
    240            RTC->WPR = 0x53;
    241          
    242            /* Set Initialization mode */
    243            if (RTC_EnterInitMode() == ERROR)
    244            {
    245              status = ERROR;
    246              /* Enable the write protection for RTC registers */
    247              RTC->WPR = 0xFF; 
    248            }
    249            else
    250            {
    251              /* Reset TR registers */
    252              RTC->TR1 = RTC_TR1_RESET_VALUE;
    253              RTC->TR2 = RTC_TR2_RESET_VALUE;
    254              RTC->TR3 = RTC_TR3_RESET_VALUE;
    255          
    256              /* Reset DR registers */
    257              RTC->DR1 = RTC_DR1_RESET_VALUE;
    258              RTC->DR2 = RTC_DR2_RESET_VALUE;
    259              RTC->DR3 = RTC_DR3_RESET_VALUE;
    260          
    261              /* Reset SPER & ARPER registers */
    262              RTC->SPRERH = RTC_SPRERH_RESET_VALUE;
    263              RTC->SPRERL = RTC_SPRERL_RESET_VALUE;
    264              RTC->APRER  = RTC_APRER_RESET_VALUE;
    265          
    266              RTC->TCR1 = RTC_TCR1_RESET_VALUE;
    267              RTC->TCR2 = RTC_TCR2_RESET_VALUE;
    268          
    269              /* Reset All CR1 bits except CR1[2:0] */
    270          
    271              RTC->CR1 = RTC_CR1_RESET_VALUE;
    272              RTC->CR2 = RTC_CR2_RESET_VALUE;
    273              RTC->CR3 = RTC_CR3_RESET_VALUE;
    274          
    275              /* Wait till RTC WUTWF flag is set or if Time out is reached exit */
    276              while (((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET) && ( wutwfcount != WUTWF_TIMEOUT))
    277              {
    278                wutwfcount++;
    279                RTC->ISR1 = 0;
    280              }
    281          
    282              if ((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET)
    283              {
    284                status = ERROR;
    285                /* Enable the write protection for RTC registers */
    286                RTC->WPR = 0xFF; 
    287              }
    288              else
    289              {
    290                /* Reset All CR1 bits */
    291                RTC->CR1 = RTC_CR1_RESET_VALUE;
    292          
    293                /* Reset WUTR registers */
    294                RTC->WUTRH = RTC_WUTRH_RESET_VALUE;
    295                RTC->WUTRL = RTC_WUTRL_RESET_VALUE;
    296          
    297                /* Reset ALARM registers */
    298                RTC->ALRMAR1 = RTC_ALRMAR1_RESET_VALUE;
    299                RTC->ALRMAR2 = RTC_ALRMAR2_RESET_VALUE;
    300                RTC->ALRMAR3 = RTC_ALRMAR3_RESET_VALUE;
    301                RTC->ALRMAR4 = RTC_ALRMAR4_RESET_VALUE;
    302          
    303                RTC->ALRMASSRH = RTC_ALRMASSRH_RESET_VALUE;
    304                RTC->ALRMASSRL = RTC_ALRMASSRL_RESET_VALUE;
    305                RTC->ALRMASSMSKR = RTC_ALRMASSMSKR_RESET_VALUE;
    306          
    307                /* Reset ISR register and exit initialization mode */
    308                RTC->ISR1 = (uint8_t)0x00;
    309                RTC->ISR2 = RTC_ISR2_RESET_VALUE;
    310          
    311                if ((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET)
    312                {
    313                  while (((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
    314                  {
    315                    recalpfcount++;
    316                  }
    317                }
    318                if ((RTC->ISR1 & RTC_ISR1_RECALPF) == RESET)
    319                {
    320                  RTC->CALRH = RTC_CALRH_RESET_VALUE;
    321                  RTC->CALRL = RTC_CALRL_RESET_VALUE;
    322          
    323                  if (RTC_WaitForSynchro() == ERROR)
    324                  {
    325                    status = ERROR;
    326                  }
    327                  else
    328                  {
    329                    status = SUCCESS;
    330                  }
    331                }
    332                else
    333                {
    334                  status = ERROR;
    335                }
    336          
    337                /* Enable the write protection for RTC registers */
    338                RTC->WPR = 0xFF; 
    339              }
    340            }
    341          
    342            /* return Deinitialize RTC registers status*/
    343            return (ErrorStatus)status;
    344          }
    345          
    346          
    347          
    348          /**
    349          * @brief  Initializes the RTC registers according to the specified parameters
    350          *         in RTC_InitStruct.
    351          * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains
    352          *         the configuration information for the RTC peripheral.
    353          * @note   The RTC Prescaler register is write protected and can be written in 
    354          *         initialization mode only.  
    355          * @retval An ErrorStatus enumeration value:
    356          *          - SUCCESS: RTC registers are initialized
    357          *          - ERROR: RTC registers are not initialized
    358          */
    359          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    360          {
    361            ErrorStatus status = ERROR;
    362          
    363            /* Check the parameters */
    364            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
    365            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
    366            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
    367          
    368            /* Disable the write protection for RTC registers */
    369            RTC->WPR = 0xCA;
    370            RTC->WPR = 0x53;
    371          
    372            /* Set Initialization mode */
    373            if (RTC_EnterInitMode() == ERROR)
    374            {
    375              status = ERROR;
    376            }
    377            else
    378            {
    379              /* Clear the bits to be configured first */
    380              RTC->CR1 &= ((uint8_t)~( RTC_CR1_FMT ));
    381          
    382              /* Set RTC_CR1 register */
    383              RTC->CR1 |=  ((uint8_t)(RTC_InitStruct->RTC_HourFormat));
    384          
    385              /* Set Prescalers registers */
    386              RTC->SPRERH = (uint8_t)(RTC_InitStruct->RTC_SynchPrediv >> 8);
    387              RTC->SPRERL = (uint8_t)(RTC_InitStruct->RTC_SynchPrediv);
    388              RTC->APRER =  (uint8_t)(RTC_InitStruct->RTC_AsynchPrediv);
    389          
    390              /* Exit Initialization mode */
    391              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
    392          
    393              status = SUCCESS;
    394            }
    395          
    396            /* Enable the write protection for RTC registers */
    397            RTC->WPR = 0xFF; 
    398          
    399            /* return Initialize the RTC registers status*/
    400            return (ErrorStatus)(status);
    401          }
    402          
    403          /**
    404          * @brief  Fills each RTC_InitStruct member with its default value
    405          *         Hour format = 24h / Prescalers configured to their reset values.
    406          * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be
    407          *         initialized.
    408          * @retval None
    409          */
    410          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    411          {
    412            /* Initialize the RTC_Hourformat member */
    413            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
    414          
    415            /* Initialize the RTC_AsynchPrediv member */
    416            RTC_InitStruct->RTC_AsynchPrediv = RTC_APRER_RESET_VALUE;
    417          
    418            /* Initialize the RTC_SynchPrediv member */
    419            RTC_InitStruct->RTC_SynchPrediv = RTC_SPRERL_RESET_VALUE;
    420          }
    421          
    422          /**
    423          * @brief  Enables or disables the RTC registers write protection.
    424          * @param  NewState: new state of the write protection.
    425            *         This parameter can be: ENABLE or DISABLE.
    426          * @note   Writing a wrong key reactivates the write protection.
    427          * @note   The protection mechanism is not affected by system reset.  
    428          * @retval None
    429          */
    430          void RTC_WriteProtectionCmd(FunctionalState NewState)
    431          {
    432            /* Check the parameters */
    433            assert_param(IS_FUNCTIONAL_STATE(NewState));
    434          
    435            if (NewState != DISABLE)
    436            {
    437              /* Enable the write protection for RTC registers */
    438              RTC->WPR = RTC_WPR_EnableKey;
    439            }
    440            else
    441            {
    442              /* Disable the write protection for RTC registers */
    443              RTC->WPR = RTC_WPR_DisableKey1;
    444              RTC->WPR = RTC_WPR_DisableKey2;
    445            }
    446          }
    447          
    448          
    449          /**
    450          * @brief  Enters the RTC Initialization mode.
    451          * @note   The RTC Initialization mode is write protected, use the 
    452          *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    453          * @param  None
    454          * @retval An ErrorStatus enumeration value:
    455          *          - SUCCESS: RTC is in Init mode
    456          *          - ERROR: RTC is not in Init mode
    457          */
    458          ErrorStatus RTC_EnterInitMode(void)
    459          {
    460            ErrorStatus status = ERROR;
    461            uint16_t initfcount = 0;
    462          
    463            /* Check if the Initialization mode is set */
    464            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
    465            {
    466              /* Set the Initialization mode */
    467              RTC->ISR1 = (uint8_t)RTC_ISR1_INIT;
    468          
    469              /* Wait until INITF flag is set */
    470              while (((RTC->ISR1 & RTC_ISR1_INITF) == RESET) && ( initfcount != INITF_TIMEOUT))
    471              {
    472                initfcount++;
    473              }
    474            }
    475          
    476            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
    477            {
    478              status = ERROR;
    479            }
    480            else
    481            {
    482              status = SUCCESS;
    483            }
    484          
    485            return (ErrorStatus)status;
    486          }
    487          
    488          
    489          /**
    490          * @brief  Exits the RTC Initialization mode.
    491          * @note   When the initialization sequence is complete, the Calendar restarts 
    492          *         counting after 4 RTCCLK cycles.  
    493          * @note   The RTC Initialization mode is write protected, use the 
    494          *         RTC_WriteProtectionCmd(DISABLE) before calling this function.     
    495          * @param  None
    496          * @retval None
    497          */
    498          void RTC_ExitInitMode(void)
    499          {
    500            /* Exit Initialization mode */
    501            RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
    502          }
    503          
    504          
    505          /**
    506          * @brief  Waits until the RTC Calendar registers (Time and Date)
    507          *         are synchronized with RTC clock.
    508          * @note   This function is meaningless when BYPASS feature is enabled in RTC_CR1
    509          *         register.
    510          * @note   To read the Calendar through the shadow registers after Calendar 
    511          *         initialization, Calendar update or after wakeup from low power modes 
    512          *         the software must first clear the RSF flag. 
    513          *         The software must then wait until it is set again before reading 
    514          *         the Calendar (if not yet done), which means that the Calendar registers
    515          *         have been correctly copied into the RTC_TRx and RTC_DRx shadow registers.
    516          * @note   RTC_SetTime() and RTC_SetDate() functions call RTC_WaitForSynchro() function
    517          *         after updating the Calendar. In Run mode, User can use RTC_GetDate(), 
    518          *         RTC_GetTime() and/or RTC_GetSubSecond() without need to call 
    519          *         RTC_WaitForSynchro() function. After waking up from low power mode, this 
    520          *         function must be called before calling RTC_GetDate(), RTC_GetTime() or 
    521          *         RTC_GetSubSecond() functions.   
    522          * @param  None
    523          * @retval An ErrorStatus enumeration value:
    524          *          - SUCCESS: RTC registers are synchronized
    525          *          - ERROR: RTC registers are not synchronized
    526          */
    527          ErrorStatus RTC_WaitForSynchro(void)
    528          {
    529            uint16_t rsfcount = 0;
    530            ErrorStatus status = ERROR;
    531            
    532            /* Disable the write protection for RTC registers */
    533            RTC->WPR = 0xCA;
    534            RTC->WPR = 0x53;
    535          
    536            /* Clear RSF flag by writing 0 in RSF bit  */
    537            RTC->ISR1 &= (uint8_t)~(RTC_ISR1_RSF | RTC_ISR1_INIT);
    538          
    539            /* Wait the registers to be synchronised */
    540            while (((RTC->ISR1 & RTC_ISR1_RSF) == RESET) && ( rsfcount != RSF_TIMEOUT))
    541            {
    542              rsfcount++;
    543            }
    544          
    545            /* Check if RSF flag occurs*/
    546            if ((RTC->ISR1 & RTC_ISR1_RSF) != RESET)
    547            {
    548              status = SUCCESS;
    549            }
    550            else
    551            {
    552              status = ERROR;
    553            }
    554          
    555            /* Enable the write protection for RTC registers */
    556            RTC->WPR = 0xFF; 
    557            
    558            return (ErrorStatus)status;
    559          }
    560          
    561          
    562          /**
    563          * @brief  Enables or Disables the RTC Ratio.
    564          * @param  NewState: new state of the Ratio feature.
    565            *         This parameter can be: ENABLE or DISABLE.
    566          * @retval None
    567          */
    568          void RTC_RatioCmd(FunctionalState NewState)
    569          {
    570            /* Check the parameters */
    571            assert_param(IS_FUNCTIONAL_STATE(NewState));
    572          
    573            /* Disable the write protection for RTC registers */
    574            RTC->WPR = 0xCA;
    575            RTC->WPR = 0x53;
    576          
    577            if (NewState != DISABLE)
    578            {
    579              /* Set the RATIO bit */
    580              RTC->CR1 |= (uint8_t)RTC_CR1_RATIO;
    581            }
    582            else
    583            {
    584              /* Reset the RATIO bit */
    585              RTC->CR1 &= (uint8_t)~RTC_CR1_RATIO;
    586            }
    587          
    588            /* Enable the write protection for RTC registers */
    589            RTC->WPR = 0xFF; 
    590          }
    591          
    592          /**
    593          * @brief  Enables or Disables the Bypass Shadow feature.
    594          * @param  NewState: new state of the Bypass Shadow feature.
    595            *         This parameter can be: ENABLE or DISABLE.
    596          * @retval None
    597          */
    598          void RTC_BypassShadowCmd(FunctionalState NewState)
    599          {
    600            /* Check the parameters */
    601            assert_param(IS_FUNCTIONAL_STATE(NewState));
    602          
    603            /* Disable the write protection for RTC registers */
    604            RTC->WPR = 0xCA;
    605            RTC->WPR = 0x53;
    606          
    607            if (NewState != DISABLE)
    608            {
    609              /* Set the BYPSHAD bit */
    610              RTC->CR1 |= (uint8_t)RTC_CR1_BYPSHAD;
    611            }
    612            else
    613            {
    614              /* Reset the BYPSHAD bit */
    615              RTC->CR1 &= (uint8_t)~RTC_CR1_BYPSHAD;
    616            }
    617          
    618            /* Enable the write protection for RTC registers */
    619            RTC->WPR = 0xFF; 
    620          }
    621          
    622          
    623          
    624          
    625          /**
    626            * @}
    627            */
    628          
    629          /** @defgroup RTC_Group2 Time and Date configuration functions
    630           *  @brief   Time and Date configuration functions 
    631           *
    632          @verbatim   
    633           ===============================================================================
    634                             Time and Date configuration functions
    635           ===============================================================================  
    636          
    637            This section provide functions allowing to program and read the RTC Calendar
    638            (Time and Date).
    639          
    640          @endverbatim
    641            * @{
    642            */
    643          
    644          
    645          /**
    646          * @brief Sets the RTC current time.
    647          * @note   After updating the Calendar, this routine clears the RSF flag and waits
    648          *         until it is set again (using RTC_WaitForSynchro() function) , which means
    649          *         that the Calendar registers have been correctly copied into the RTC_TRx
    650          *         and RTC_DRx shadow registers. 
    651          * @param  RTC_Format: specifies the format of the entered parameters.
    652          *         This parameter can be one of the @ref RTC_Format_T enumeration.
    653          * @param  RTC_TimeStruct:  pointer to a  @ref RTC_TimeTypeDef structure that
    654          *         contains the time configuration information for the RTC
    655          * @retval An ErrorStatus enumeration value:
    656          *          - SUCCESS: RTC Time register is configured
    657          *          - ERROR: RTC Time register is not configured
    658          */
    659          ErrorStatus RTC_SetTime(RTC_Format_T RTC_Format,
    660                                  RTC_TimeTypeDef* RTC_TimeStruct)
    661          {
    662            ErrorStatus status = ERROR;
    663            uint8_t temp = 0;
    664          
    665            /* Check the parameters */
    666            assert_param(IS_RTC_FORMAT(RTC_Format));
    667          
    668            if (RTC_Format == RTC_Format_BIN)
    669            {
    670              /* Check Hour Format (24h or 12h)*/
    671              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
    672              {
    673                assert_param(IS_RTC_HOUR12_MAX(RTC_TimeStruct->RTC_Hours));
    674                assert_param(IS_RTC_HOUR12_MIN(RTC_TimeStruct->RTC_Hours));
    675              }
    676              else
    677              {
    678                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
    679              }
    680              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    681              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
    682            }
    683            else
    684            {
    685              /* Check Hour Format (24h or 12h)*/
    686              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
    687              {
    688                assert_param(IS_RTC_HOUR12_MAX(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    689                assert_param(IS_RTC_HOUR12_MIN(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    690              }
    691              else
    692              {
    693                assert_param(IS_RTC_HOUR24(Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
    694              }
    695              assert_param(IS_RTC_MINUTES(Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    696              assert_param(IS_RTC_SECONDS(Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
    697            }
    698          
    699          
    700            /* Disable the write protection for RTC registers */
    701            RTC->WPR = 0xCA;
    702            RTC->WPR = 0x53;
    703          
    704            /* Set Initialization mode */
    705            if (RTC_EnterInitMode() == ERROR)
    706            {
    707              status = ERROR;
    708              /* Enable the write protection for RTC registers */
    709              RTC->WPR = 0xFF; 
    710            }
    711            else
    712            {
    713              /* Check Hour Format is 12h)*/
    714              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
    715              {
    716                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    717                temp = RTC_TimeStruct->RTC_H12;
    718              }
    719              else
    720              {
    721                temp = 0;
    722              }
    723              /* Check the input parameters format */
    724              if (RTC_Format != RTC_Format_BIN)
    725              {
    726                RTC->TR1 = (uint8_t)(RTC_TimeStruct->RTC_Seconds);
    727                RTC->TR2 = (uint8_t)(RTC_TimeStruct->RTC_Minutes) ;
    728                RTC->TR3 = (uint8_t)( temp | RTC_TimeStruct->RTC_Hours) ;
    729              }
    730              else
    731              {
    732                RTC->TR1 = (uint8_t)(ByteToBcd2(RTC_TimeStruct->RTC_Seconds));
    733                RTC->TR2 = (uint8_t)(ByteToBcd2(RTC_TimeStruct->RTC_Minutes)) ;
    734                RTC->TR3 = (uint8_t)( temp | ByteToBcd2(RTC_TimeStruct->RTC_Hours));
    735              }
    736              /* Read DR3 register to unfreeze calender registers */
    737              (void)(RTC->DR3);
    738          
    739              /* Exit Initialization mode */
    740              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
    741          
    742              /* Enable the write protection for RTC registers */
    743              RTC->WPR = 0xFF; 
    744          
    745              /* if RTC_CR1_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    746              if ((RTC->CR1 & RTC_CR1_BYPSHAD) == RESET)
    747              {
    748                if (RTC_WaitForSynchro() == ERROR)
    749                {
    750                  status = ERROR;
    751                }
    752                else
    753                {
    754                  status = SUCCESS;
    755                }
    756              }
    757              else
    758              {
    759                status = SUCCESS;
    760              }
    761            }
    762          
    763            return (ErrorStatus)status;
    764          }
    765          
    766          
    767          
    768          /**
    769          * @brief  Fills each RTC_TimeStruct member with its default value
    770          *         (Time = 00h:00min:00sec).
    771          * @param  RTC_TimeStruct: pointer to a @ref RTC_TimeTypeDef structure which will be
    772          *         initialized.
    773          * @retval None
    774          */
    775          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    776          {
    777            /* Time = 00h:00min:00sec*/
    778            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
    779            RTC_TimeStruct->RTC_Hours = 0;
    780            RTC_TimeStruct->RTC_Minutes = 0;
    781            RTC_TimeStruct->RTC_Seconds = 0;
    782          }
    783          
    784                    
    785          /**
    786          * @brief  Gets the RTC current Time.
    787          * @note   To read the Calendar after wake up from low power mode, user software 
    788          *         must first check that the RSF flag is set in RTC_ISR1, using 
    789          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    790          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    791          * @param  RTC_Format: specifies the format of the returned parameters.
    792          *         This parameter can be one of the @ref RTC_Format_T enumeration.
    793          * @param  RTC_TimeStruct: pointer to a @ref RTC_TimeTypeDef structure that
    794          *         will contain the returned current time configuration.
    795          * @retval None
    796          
    797          */
    798          void RTC_GetTime(RTC_Format_T RTC_Format,
    799                           RTC_TimeTypeDef* RTC_TimeStruct)
    800          {
    801            uint8_t  tmpreg = 0;
    802          
    803            /* Check the parameters */
    804            assert_param(IS_RTC_FORMAT(RTC_Format));
    805          
    806            /* Fill the structure fields with the read parameters */
    807            /* Get RTC seconds */
    808            RTC_TimeStruct->RTC_Seconds = RTC->TR1;
    809          
    810            /* Get RTC Minutes */
    811            RTC_TimeStruct->RTC_Minutes = RTC->TR2;
    812          
    813            /* Get the RTC_TR3 register */
    814            tmpreg = (uint8_t)RTC->TR3;
    815          
    816            /* Read DR3 register to unfreeze calender registers */
    817            (void) (RTC->DR3) ;
    818          
    819          
    820            /* Get RTC Hours */
    821            RTC_TimeStruct->RTC_Hours = (uint8_t)(tmpreg & (uint8_t)~(RTC_TR3_PM));
    822          
    823            /* Get RTC H12 state */
    824            RTC_TimeStruct->RTC_H12 = (RTC_H12_T)(tmpreg & RTC_TR3_PM);
    825          
    826            /* Check the input parameters format */
    827            if (RTC_Format == RTC_Format_BIN)
    828            {
    829              /* Convert the structure parameters to Binary format */
    830              RTC_TimeStruct->RTC_Hours = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
    831              RTC_TimeStruct->RTC_Minutes = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
    832              RTC_TimeStruct->RTC_Seconds = (uint8_t)Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
    833            }
    834          }
    835          
    836          /**
    837          * @brief  Gets the RTC current Calendar Subseconds value.
    838          * @note   To read the Calendar after wake up from low power mode, user software 
    839          *         must first check that the RSF flag is set in RTC_ISR1, using 
    840          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    841          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    842          * @param  None
    843          * @retval RTC current Calendar Subseconds value.
    844          */
    845          uint16_t RTC_GetSubSecond(void)
    846          {
    847            uint8_t ssrhreg = 0, ssrlreg = 0;
    848            uint16_t ssrreg = 0;
    849          
    850            /* Get subseconds values from the correspondent registers*/
    851            ssrhreg = RTC->SSRH;
    852            ssrlreg = RTC->SSRL;
    853          
    854            /* Read DR3 register to unfreeze calender registers */
    855            (void) (RTC->DR3);
    856          
    857          
    858            ssrreg = (uint16_t)((uint16_t)((uint16_t)ssrhreg << 8) | (uint16_t)(ssrlreg));
    859            return (uint16_t)(ssrreg);
    860          }
    861          
    862          /**
    863          * @brief  Set the RTC current date.
    864          * @note   After updating the Calendar, this routine clears the RSF flag and waits
    865          *         until it is set again (using RTC_WaitForSynchro() function) , which means
    866          *         that the Calendar registers have been correctly copied into the RTC_TRx
    867          *         and RTC_DRx shadow registers.   
    868          * @param  RTC_Format: specifies the format of the entered parameters.
    869          *         This parameter can be one of the @ref RTC_Format_T enumeration.
    870          * @param  RTC_DateStruct:  pointer to a  @ref RTC_TimeTypeDef structure that
    871          *         contains the date configuration information for the RTC.
    872          * @retval An ErrorStatus enumeration value:
    873          *          - SUCCESS: RTC Date register is configured
    874          *          - ERROR: RTC Date register is not configured
    875          */
    876          ErrorStatus RTC_SetDate(RTC_Format_T RTC_Format,
    877                                  RTC_DateTypeDef* RTC_DateStruct)
    878          {
    879            ErrorStatus status = ERROR;
    880          
    881            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & TEN_VALUE_BCD) == TEN_VALUE_BCD))
    882            {
    883              RTC_DateStruct->RTC_Month = (RTC_Month_T)((RTC_DateStruct->RTC_Month & (uint8_t)~(TEN_VALUE_BCD)) + TEN_VALUE_BIN);
    884            }
    885          
    886            /* Check the parameters */
    887            assert_param(IS_RTC_FORMAT(RTC_Format));
    888            if (RTC_Format == RTC_Format_BIN)
    889            {
    890              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
    891              assert_param(IS_RTC_MONTH_MIN(RTC_DateStruct->RTC_Month));
    892              assert_param(IS_RTC_MONTH_MAX(RTC_DateStruct->RTC_Month));
    893              assert_param(IS_RTC_DATE_MIN(RTC_DateStruct->RTC_Date));
    894              assert_param(IS_RTC_DATE_MAX(RTC_DateStruct->RTC_Date));
    895            }
    896            else
    897            {
    898              assert_param(IS_RTC_YEAR(Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    899              assert_param(IS_RTC_MONTH_MAX(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month)));
    900              assert_param(IS_RTC_MONTH_MIN(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month)));
    901              assert_param(IS_RTC_DATE_MIN(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date)));
    902              assert_param(IS_RTC_DATE_MAX(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date)));
    903            }
    904            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
    905          
    906            /* Disable the write protection for RTC registers */
    907            RTC->WPR = 0xCA;
    908            RTC->WPR = 0x53;
    909          
    910            /* Set Initialization mode */
    911            if (RTC_EnterInitMode() == ERROR)
    912            {
    913              status = ERROR;
    914              /* Enable the write protection for RTC registers */
    915              RTC->WPR = 0xFF; 
    916            }
    917            else
    918            {
    919              (void)(RTC->TR1);
    920              /* Set the RTC_DR registers */
    921              /* Check the input parameters format */
    922              if (RTC_Format != RTC_Format_BIN)
    923              {
    924                RTC->DR1 = (uint8_t)(RTC_DateStruct->RTC_Date);
    925                RTC->DR2 = (uint8_t)((RTC_DateStruct->RTC_Month) | (uint8_t)((RTC_DateStruct->RTC_WeekDay) << 5));
    926                RTC->DR3 = (uint8_t)((RTC_DateStruct->RTC_Year));
    927              }
    928              else
    929              {
    930                RTC->DR1 = (uint8_t)(ByteToBcd2 ((uint8_t)RTC_DateStruct->RTC_Date));
    931                RTC->DR2 = (uint8_t)((ByteToBcd2((uint8_t)RTC_DateStruct->RTC_Month)) | (uint8_t)((RTC_DateStruct->RTC_WeekDay) << 5));
    932                RTC->DR3 = (uint8_t)(ByteToBcd2((uint8_t)RTC_DateStruct->RTC_Year));
    933              }
    934          
    935              /* Exit Initialization mode */
    936              RTC->ISR1 &= (uint8_t)~RTC_ISR1_INIT;
    937          
    938              /* Enable the write protection for RTC registers */
    939              RTC->WPR = 0xFF; 
    940          
    941              /* if  RTC_CR1_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    942              if ((RTC->CR1 & RTC_CR1_BYPSHAD) == RESET)
    943              {
    944                if (RTC_WaitForSynchro() == ERROR)
    945                {
    946                  status = ERROR;
    947                }
    948                else
    949                {
    950                  status = SUCCESS;
    951                }
    952              }
    953              else
    954              {
    955                status = SUCCESS;
    956              }
    957            }
    958          
    959            return (ErrorStatus)status;
    960          }
    961          /**
    962          * @brief  Fills each RTC_DateStruct member with its default value
    963          *         (Monday 01 January xx00).
    964          * @param  RTC_DateStruct: pointer to a @ref RTC_DateTypeDef structure which will be
    965          *         initialized.
    966          * @retval None
    967          */
    968          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
    969          {
    970            /* * (Monday 01 January xx00)*/
    971            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
    972            RTC_DateStruct->RTC_Date = 1;
    973            RTC_DateStruct->RTC_Month = RTC_Month_January;
    974            RTC_DateStruct->RTC_Year = 0;
    975          }
    976          /**
    977          * @brief  Get the RTC current date.
    978          * @note   To read the Calendar after wake up from low power mode, user software 
    979          *         must first check that the RSF flag is set in RTC_ISR1, using 
    980          *         RTC_WaitForSynchro() function, which means that the Calendar registers
    981          *         have been correctly copied into the shadow registers (RTC_TRx and RTC_DRx).
    982          * @param  RTC_Format: specifies the format of the returned parameters.
    983          *         This parameter can be one of the @ref RTC_Format_T enumeration.
    984          * @param  RTC_DateStruct: pointer to a @ref RTC_DateTypeDef structure that
    985          *         will contain the returned current Date configuration.
    986          * @retval None
    987          */
    988          void RTC_GetDate(RTC_Format_T RTC_Format,
    989                           RTC_DateTypeDef* RTC_DateStruct)
    990          {
    991            uint8_t tmpreg = 0;
    992          
    993            /* Check the parameters */
    994            assert_param(IS_RTC_FORMAT(RTC_Format));
    995          
    996            /* Fill the structure fields with the read parameters */
    997            (void) (RTC->TR1) ;
    998            RTC_DateStruct->RTC_Date = (uint8_t)(RTC->DR1);
    999            tmpreg = (uint8_t)RTC->DR2;
   1000            RTC_DateStruct->RTC_Year = (uint8_t)(RTC->DR3);
   1001          
   1002          
   1003            RTC_DateStruct->RTC_Month = (RTC_Month_T)(tmpreg & (uint8_t)(RTC_DR2_MT | RTC_DR2_MU));
   1004            RTC_DateStruct->RTC_WeekDay = (RTC_Weekday_T)((uint8_t)((uint8_t)tmpreg & (uint8_t)(RTC_DR2_WDU)) >> (uint8_t)5);
   1005          
   1006            /* Check the input parameters format */
   1007            if (RTC_Format == RTC_Format_BIN)
   1008            {
   1009              /* Convert the structure parameters to Binary format */
   1010              RTC_DateStruct->RTC_Year = (uint8_t)Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Year);
   1011              RTC_DateStruct->RTC_Month = (RTC_Month_T)Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Month);
   1012              RTC_DateStruct->RTC_Date = (uint8_t)(Bcd2ToByte((uint8_t)RTC_DateStruct->RTC_Date));
   1013            }
   1014          }
   1015          
   1016          /**
   1017            * @}
   1018            */
   1019          
   1020          /** @defgroup RTC_Group3 Alarms configuration functions
   1021           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
   1022           *
   1023          @verbatim   
   1024           ===============================================================================
   1025                        Alarms (Alarm A and Alarm B) configuration functions
   1026           ===============================================================================  
   1027          
   1028            This section provide functions allowing to program and read the RTC Alarms.
   1029          
   1030          @endverbatim
   1031            * @{
   1032            */
   1033            
   1034          /**
   1035            * @brief  Sets the RTC Alarm configuration.
   1036            * @note   Before configuring the Alarm settings, the Alarm Unit must be disabled
   1037            *         (if enabled) using RTC_AlarmCmd(DISABLE) function.
   1038            * @param  RTC_Format: specifies the format of the entered parameters.
   1039            *         This parameter can be one of the @ref RTC_Format_T enumeration.
   1040            * @param  RTC_AlarmStruct:  pointer to a  @ref RTC_AlarmTypeDef structure that
   1041            *         contains the Alarm configuration information for the RTC.
   1042            * @retval None.
   1043            */
   1044          void RTC_SetAlarm(RTC_Format_T RTC_Format,
   1045                            RTC_AlarmTypeDef* RTC_AlarmStruct)
   1046          {
   1047            uint8_t tmpreg1 = 0;
   1048            uint8_t tmpreg2 = 0;
   1049            uint8_t tmpreg3 = 0;
   1050            uint8_t tmpreg4 = 0;
   1051          
   1052            /* Check the parameters */
   1053            assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   1054            assert_param(IS_RTC_FORMAT(RTC_Format));
   1055            assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   1056            assert_param(IS_RTC_ALARM_DATEWEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   1057          
   1058          
   1059            if (RTC_Format == RTC_Format_BIN)
   1060            {
   1061              /* Check Hour Format (24h or 12h)*/
   1062              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   1063              {
   1064                assert_param(IS_RTC_HOUR12_MAX(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1065                assert_param(IS_RTC_HOUR12_MIN(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1066              }
   1067              else
   1068              {
   1069                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   1070              }
   1071              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   1072              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   1073            }
   1074            else
   1075            {
   1076              /* Check Hour Format (24h or 12h)*/
   1077              if ((RTC->CR1 & RTC_CR1_FMT) != RESET)
   1078              {
   1079                assert_param(IS_RTC_HOUR12_MAX(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1080                assert_param(IS_RTC_HOUR12_MIN(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1081              }
   1082              else
   1083              {
   1084                assert_param(IS_RTC_HOUR24(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   1085              }
   1086          
   1087              assert_param(IS_RTC_MINUTES(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   1088          
   1089              assert_param(IS_RTC_SECONDS(Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   1090          
   1091            }
   1092          
   1093            /* if Date/Weekday field is not masked */
   1094            if ((RTC_AlarmStruct->RTC_AlarmMask & RTC_AlarmMask_DateWeekDay) == RESET )
   1095            {
   1096              if (RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_WeekDay)
   1097              {
   1098                assert_param(IS_RTC_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1099              }
   1100              else
   1101              {
   1102                assert_param(IS_RTC_DATE_MIN(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1103                assert_param(IS_RTC_DATE_MAX(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   1104              }
   1105            }
   1106          
   1107            /* Disable the write protection for RTC registers */
   1108            RTC->WPR = 0xCA;
   1109            RTC->WPR = 0x53;
   1110          
   1111          
   1112            /* Check the input parameters format & Configure the Alarm register */
   1113            if (RTC_Format != RTC_Format_BIN)
   1114            {
   1115              tmpreg1 = (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1116                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask) & (uint8_t)RTC_ALRMAR1_MSK1));
   1117          
   1118              tmpreg2 = (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) | \
   1119                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 1) & (uint8_t)RTC_ALRMAR2_MSK2));
   1120          
   1121              tmpreg3 = (uint8_t)((uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) | \
   1122                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12)) | \
   1123                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 2) & (uint8_t)RTC_ALRMAR3_MSK3));
   1124          
   1125              tmpreg4 = (uint8_t)((uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) | \
   1126                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel)) | \
   1127                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 3) & (uint8_t)RTC_ALRMAR4_MSK4));
   1128          
   1129            }
   1130            else
   1131            {
   1132              tmpreg1 = (uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1133                                  (uint8_t)(RTC_AlarmStruct->RTC_AlarmMask & RTC_ALRMAR1_MSK1));
   1134          
   1135              tmpreg2 = (uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)) | \
   1136                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 1) & (uint8_t)RTC_ALRMAR2_MSK2));
   1137          
   1138              tmpreg3 = (uint8_t)((uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)) | \
   1139                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12)) | \
   1140                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 2) & (uint8_t)RTC_ALRMAR3_MSK3));
   1141          
   1142              tmpreg4 = (uint8_t)((uint8_t)((ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay)) | \
   1143                                            (uint8_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel)) | \
   1144                                  (uint8_t)((uint8_t)(RTC_AlarmStruct->RTC_AlarmMask << 3) & (uint8_t)(RTC_ALRMAR4_MSK4)));
   1145            }
   1146          
   1147            /* Configure the Alarm register */
   1148            RTC->ALRMAR1 = tmpreg1;
   1149            RTC->ALRMAR2 = tmpreg2;
   1150            RTC->ALRMAR3 = tmpreg3;
   1151            RTC->ALRMAR4 = tmpreg4;
   1152          
   1153            /* Enable the write protection for RTC registers */
   1154            RTC->WPR = 0xFF; 
   1155          }
   1156          
   1157          /**
   1158          * @brief  Fills each RTC_AlarmStruct member with its default value
   1159          *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1160          *         all fields are masked).
   1161          * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1162          *         will be initialized.
   1163          * @retval None
   1164          */
   1165          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1166          {
   1167            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1168            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   1169            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   1170            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   1171            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   1172          
   1173            /* Alarm Date Settings : Date = 1st day of the month*/
   1174            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   1175            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   1176          
   1177            /* Alarm Masks Settings : Mask =  all fields are masked*/
   1178            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_All;
   1179          }
   1180          /**
   1181            * @brief  Gets the RTC Alarm configuration.
   1182            * @param  RTC_Format: specifies the format of the entered parameters.
   1183            *         This parameter can be one of the @ref RTC_Format_T enumeration.
   1184            * @param  RTC_AlarmStruct:  pointer to a  @ref RTC_AlarmTypeDef structure that
   1185            *         will contain the Alarm configuration information of  the RTC.
   1186            * @retval None
   1187            */
   1188          void RTC_GetAlarm(RTC_Format_T RTC_Format,
   1189                            RTC_AlarmTypeDef* RTC_AlarmStruct)
   1190          {
   1191            uint8_t tmpreg1 = 0;
   1192            uint8_t tmpreg2 = 0;
   1193            uint8_t tmpreg3 = 0;
   1194            uint8_t tmpreg4 = 0;
   1195            uint8_t alarmmask = 0;
   1196          
   1197            /* Check the parameters */
   1198            assert_param(IS_RTC_FORMAT(RTC_Format));
   1199          
   1200            /* Get Alarm registers data */
   1201            tmpreg1 = (uint8_t)RTC->ALRMAR1;
   1202            tmpreg2 = (uint8_t)RTC->ALRMAR2;
   1203            tmpreg3 = (uint8_t)RTC->ALRMAR3;
   1204            tmpreg4 = (uint8_t)RTC->ALRMAR4;
   1205          
   1206            /* Fill the structure with the read parameters */
   1207            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint8_t)((uint8_t)tmpreg1 & (uint8_t)((uint8_t)RTC_ALRMAR1_ST | (uint8_t)RTC_ALRMAR1_SU));
   1208            alarmmask = (uint8_t)(tmpreg1 & RTC_ALRMAR1_MSK1);
   1209          
   1210            /* Fill the structure with the read parameters */
   1211            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint8_t)((uint8_t)tmpreg2 & (uint8_t)((uint8_t)RTC_ALRMAR2_MNT | (uint8_t)RTC_ALRMAR2_MNU));
   1212            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)(tmpreg2 & RTC_ALRMAR2_MSK2) >> 1));
   1213          
   1214            /* Fill the structure with the read parameters */
   1215            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint8_t)((uint8_t)tmpreg3 & (uint8_t)((uint8_t)RTC_ALRMAR3_HT | (uint8_t)RTC_ALRMAR3_HU));
   1216            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (RTC_H12_T)((uint8_t)tmpreg3 & (uint8_t)RTC_ALRMAR3_PM);
   1217            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)((uint8_t)tmpreg3 & (uint8_t)RTC_ALRMAR3_MSK3) >> 2));
   1218          
   1219            /* Fill the structure with the read parameters */
   1220            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint8_t)((uint8_t)tmpreg4 & (uint8_t)((uint8_t)RTC_ALRMAR4_DT | (uint8_t)RTC_ALRMAR4_DU));
   1221            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (RTC_AlarmDateWeekDaySel_T)((uint8_t)tmpreg4 & (uint8_t)RTC_ALRMAR4_WDSEL);
   1222            alarmmask = (uint8_t)((alarmmask) | (uint8_t)((uint8_t)((uint8_t)tmpreg4 & RTC_ALRMAR4_MSK4) >> 3));
   1223          
   1224            RTC_AlarmStruct->RTC_AlarmMask = alarmmask;
   1225          
   1226            if (RTC_Format == RTC_Format_BIN)
   1227            {
   1228              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   1229              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes);
   1230              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds);
   1231              RTC_AlarmStruct->RTC_AlarmDateWeekDay = Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   1232            }
   1233          }
   1234          
   1235          /**
   1236            * @brief  Enables or disables the RTC Alarm.
   1237            * @param  NewState: new state of the alarm. This parameter can be: ENABLE or DISABLE.
   1238            * @retval An ErrorStatus enumeration value:
   1239            *          - SUCCESS: RTC Alarm is enabled/disabled
   1240            *          - ERROR: RTC Alarm is not enabled/disabled
   1241            */
   1242          ErrorStatus RTC_AlarmCmd(FunctionalState NewState)
   1243          {
   1244            __IO uint16_t alrawfcount = 0;
   1245            ErrorStatus status = ERROR;
   1246            uint8_t temp1 = 0;
   1247          
   1248            /* Check the parameters */
   1249            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1250          
   1251            /* Disable the write protection for RTC registers */
   1252            RTC->WPR = 0xCA;
   1253            RTC->WPR = 0x53;
   1254          
   1255            /* Configure the Alarm state */
   1256            if (NewState != DISABLE)
   1257            { /*Enable the Alarm*/
   1258              RTC->CR2 |= (uint8_t)(RTC_CR2_ALRAE);
   1259              status = SUCCESS;
   1260            }
   1261            else
   1262            {  /* Disable the Alarm */
   1263              RTC->CR2 &= (uint8_t)~(RTC_CR2_ALRAE) ;
   1264          
   1265              /* Wait until ALRxWF flag is set */
   1266              temp1 = (uint8_t)(RTC->ISR1 & RTC_ISR1_ALRAWF);
   1267              while ((alrawfcount != ALRAWF_TIMEOUT) && (temp1 == RESET))
   1268              {
   1269                alrawfcount++;
   1270              }
   1271          
   1272              if ((RTC->ISR1 &  RTC_ISR1_ALRAWF) == RESET)
   1273              {
   1274                status = ERROR;
   1275              }
   1276              else
   1277              {
   1278                status = SUCCESS;
   1279              }
   1280            }
   1281          
   1282            /* Enable the write protection for RTC registers */
   1283            RTC->WPR = 0xFF; 
   1284          
   1285            /* Return the status*/
   1286            return (ErrorStatus)status;
   1287          }
   1288          /**
   1289          * @brief  Configure the RTC Alarm Subseconds value and mask.
   1290          * @param  RTC_AlarmSubSecondValue: specifies the Subseconds value.
   1291          *         This parameter can be a value from 0 to 0x7FFF.
   1292          * @param  RTC_AlarmSubSecondMask:  specifies the Subseconds Mask.
   1293          *         This parameter can be one of the @ref RTC_AlarmSubSecondMask_T enumeration.
   1294          * @retval An ErrorStatus enumeration value:
   1295          *          - SUCCESS: Alarm Subseconds value and mask are configured
   1296          *          - ERROR: Alarm Subseconds value and mask are  not configured
   1297          */
   1298          ErrorStatus RTC_AlarmSubSecondConfig(uint16_t RTC_AlarmSubSecondValue,
   1299                                               RTC_AlarmSubSecondMask_T RTC_AlarmSubSecondMask)
   1300          {
   1301            uint8_t alarmstatus = 0;
   1302            ErrorStatus status = ERROR;
   1303          
   1304            /* Check the parameters */
   1305            assert_param(IS_RTC_ALARM_SS_VALUE(RTC_AlarmSubSecondValue));
   1306            assert_param(IS_RTC_ALARM_SS_MASK(RTC_AlarmSubSecondMask));
   1307          
   1308            /* Disable the write protection for RTC registers */
   1309            RTC->WPR = 0xCA;
   1310            RTC->WPR = 0x53;
   1311          
   1312            /* Check if the initialization mode is not set */
   1313            if ((RTC->ISR1 & RTC_ISR1_INITF) == RESET)
   1314            {
   1315              /* save  Alarm status */
   1316              alarmstatus = (uint8_t)(RTC->CR2 | RTC_CR2_ALRAE);
   1317          
   1318              /* Disable the Alarm */
   1319              RTC->CR2 &= (uint8_t)~(RTC_CR2_ALRAE);
   1320          
   1321              /* Configure the Alarm register */
   1322              RTC->ALRMASSRH = (uint8_t)(RTC_AlarmSubSecondValue >> 8);
   1323              RTC->ALRMASSRL = (uint8_t)(RTC_AlarmSubSecondValue);
   1324              RTC->ALRMASSMSKR = (uint8_t)RTC_AlarmSubSecondMask;
   1325          
   1326              /* restore the saved  Alarm status */
   1327              RTC->CR2 |= alarmstatus;
   1328          
   1329              status = SUCCESS;
   1330            }
   1331            else
   1332            {
   1333              status = ERROR;
   1334            }
   1335          
   1336            /* Enable the write protection for RTC registers */
   1337            RTC->WPR = 0xFF; 
   1338          
   1339            return (ErrorStatus)status;
   1340          }
   1341          
   1342          
   1343          
   1344          /**
   1345            * @}
   1346            */
   1347          
   1348          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1349           *  @brief   WakeUp Timer configuration functions 
   1350           *
   1351          @verbatim   
   1352           ===============================================================================
   1353                               WakeUp Timer configuration functions
   1354           ===============================================================================  
   1355          
   1356            This section provide functions allowing to program and read the RTC WakeUp.
   1357          
   1358          @endverbatim
   1359            * @{
   1360            */
   1361          /**
   1362            * @brief  Configures the RTC Wakeup clock source.
   1363            * @pre    Before configuring the wakeup unit Clock source, the wake up Unit must
   1364            *         be disabled (if enabled) using RTC_WakeUpCmd(Disable) .
   1365            * @param  RTC_WakeupClockSrc: specifies the Wakeup clock source,
   1366            *         this parameter  can be one of the @ref RTC_WakeupClockSrc_T enumeration.
   1367            * @retval None
   1368            */
   1369          void RTC_WakeUpClockConfig(RTC_WakeUpClock_T RTC_WakeUpClock)
   1370          {
   1371          
   1372            /* Check the parameters */
   1373            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   1374          
   1375            /* Disable the write protection for RTC registers */
   1376            RTC->WPR = 0xCA;
   1377            RTC->WPR = 0x53;
   1378          
   1379            /* Disable the Wakeup timer in RTC_CR2 register */
   1380            RTC->CR2 &= (uint8_t)~RTC_CR2_WUTE;
   1381          
   1382            /* Clear the Wakeup Timer clock source bits in CR1 register */
   1383            RTC->CR1 &= (uint8_t)~RTC_CR1_WUCKSEL;
   1384          
   1385            /* Configure the clock source */
   1386            RTC->CR1 |= (uint8_t)RTC_WakeUpClock;
   1387          
   1388            /* Enable the write protection for RTC registers */
   1389            RTC->WPR = 0xFF; 
   1390          }
   1391          
   1392          /**
   1393            * @brief  Sets the RTC Wakeup counter.
   1394            * @note   Before configuring the wakeup unit counter, the wake up Unit must be
   1395            *         disabled (if enabled) using RTC_WakeUpCmd(Disable).
   1396            * @param  RTC_WakeupCounter: specifies the Wake up counter,
   1397            *         This parameter can be a value from 0x0000 to 0xFFFF.
   1398            * @retval None.
   1399            */
   1400          void RTC_SetWakeUpCounter(uint16_t RTC_WakeupCounter)
   1401          {
   1402            /* Disable the write protection for RTC registers */
   1403            RTC->WPR = 0xCA;
   1404            RTC->WPR = 0x53;
   1405          
   1406          
   1407            /* Configure the Wakeup Timer counter */
   1408            RTC->WUTRH = (uint8_t)(RTC_WakeupCounter >> 8);
   1409            RTC->WUTRL = (uint8_t)(RTC_WakeupCounter);
   1410          
   1411            /* Enable the write protection for RTC registers */
   1412            RTC->WPR = 0xFF; 
   1413          }
   1414          
   1415          /**
   1416            * @brief  Returns the RTC Wakeup timer counter value.
   1417            * @param  None.
   1418            * @retval RTC Wakeup Counter value.
   1419            */
   1420          uint16_t RTC_GetWakeUpCounter(void)
   1421          {
   1422            uint16_t tmpreg = 0;
   1423          
   1424            /* Get the counter value */
   1425            tmpreg = ((uint16_t)RTC->WUTRH) << 8;
   1426            tmpreg |= RTC->WUTRL;
   1427          
   1428            /* return RTC Wakeup Counter value*/
   1429            return (uint16_t)tmpreg;
   1430          }
   1431          
   1432          /**
   1433            * @brief  Enables or Disables the RTC Wakeup Unit.
   1434            * @param  NewState: new state of the Wakeup Unit. This parameter can 
   1435            *                   be: ENABLE or DISABLE.
   1436            * @retval An ErrorStatus enumeration value:
   1437            *          - SUCCESS : RTC Wakeup Unit is enabled/disabled
   1438            *          - ERROR    : RTC Wakeup Unit is not enabled/disabled
   1439            */
   1440          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1441          {
   1442            ErrorStatus status = ERROR;
   1443            uint16_t wutwfcount = 0;
   1444          
   1445            /* Check the parameters */
   1446            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1447          
   1448            /* Disable the write protection for RTC registers */
   1449            RTC->WPR = 0xCA;
   1450            RTC->WPR = 0x53;
   1451          
   1452            if (NewState != DISABLE)
   1453            {
   1454              /* Enable the Wakeup Timer */
   1455              RTC->CR2 |= (uint8_t)RTC_CR2_WUTE;
   1456          
   1457              status = SUCCESS;
   1458            }
   1459            else
   1460            {
   1461              /* Disable the Wakeup Timer */
   1462              RTC->CR2 &= (uint8_t)~RTC_CR2_WUTE;
   1463          
   1464              /* Wait until WUTWF flag is set */
   1465              while (((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET) && ( wutwfcount != WUTWF_TIMEOUT))
   1466              {
   1467                wutwfcount++;
   1468              }
   1469          
   1470              /* Check WUTWF flag is set or not */
   1471              if ((RTC->ISR1 & RTC_ISR1_WUTWF) == RESET)
   1472              {
   1473                status = ERROR;
   1474              }
   1475              else
   1476              {
   1477                status = SUCCESS;
   1478              }
   1479            }
   1480          
   1481            /* Enable the write protection for RTC registers */
   1482            RTC->WPR = 0xFF; 
   1483          
   1484            /* Return the status*/
   1485            return (ErrorStatus)status;
   1486          }
   1487          
   1488          
   1489          
   1490          
   1491          
   1492          
   1493          /**
   1494            * @}
   1495            */
   1496          
   1497          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1498           *  @brief   Daylight Saving configuration functions 
   1499           *
   1500          @verbatim   
   1501           ===============================================================================
   1502                              Daylight Saving configuration functions
   1503           ===============================================================================  
   1504          
   1505            This section provide functions allowing to configure the RTC DayLight Saving.
   1506          
   1507          @endverbatim
   1508            * @{
   1509            */
   1510          
   1511          /**
   1512            * @brief  Adds or subtracts one hour from the current time depending on
   1513            *         the daylight saving parameter.
   1514            * @param  RTC_DayLightSaving: the day light saving Mode
   1515            *         This parameter can be one of the @ref RTC_DayLightSaving_T 
   1516            *         enumeration.
   1517            * @param  RTC_StoreOperation: the day light saving store operation
   1518            *         This parameter can be one of the @ref RTC_StoreOperation_T 
   1519            *         enumeration.
   1520            * @retval None
   1521            */
   1522          void RTC_DayLightSavingConfig(RTC_DayLightSaving_T RTC_DayLightSaving,
   1523                                        RTC_StoreOperation_T RTC_StoreOperation)
   1524          {
   1525            /* Check the parameters */
   1526            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   1527            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   1528          
   1529            /* Disable the write protection for RTC registers */
   1530            RTC->WPR = 0xCA;
   1531            RTC->WPR = 0x53;
   1532          
   1533            /* Clear the bits to be configured */
   1534            RTC->CR3 &= (uint8_t)~(RTC_CR3_BCK);
   1535          
   1536            /* Configure the RTC_CR3 register */
   1537            RTC->CR3 |= (uint8_t)((uint8_t)RTC_DayLightSaving | (uint8_t)RTC_StoreOperation);
   1538          
   1539            /* Enable the write protection for RTC registers */
   1540            RTC->WPR = 0xFF; 
   1541          }
   1542          
   1543          /**
   1544            * @brief  Returns the stored operation.
   1545            * @param  None
   1546            * @retval the store operation, this parameter can be one of
   1547            *         the @ref RTC_StoreOperation_T enumeration.
   1548            */
   1549          RTC_StoreOperation_T  RTC_GetStoreOperation(void)
   1550          {
   1551            /* Return the stored operation*/
   1552            return (RTC_StoreOperation_T)(RTC->CR3 & RTC_CR3_BCK);
   1553          }
   1554          
   1555          
   1556          
   1557          
   1558          
   1559          
   1560          /**
   1561            * @}
   1562            */
   1563          
   1564          /** @defgroup RTC_Group6 Output pin Configuration function
   1565           *  @brief   Output pin Configuration function 
   1566           *
   1567          @verbatim   
   1568           ===============================================================================
   1569                                   Output pin Configuration function
   1570           ===============================================================================  
   1571          
   1572            This section provide functions allowing to configure the RTC Output source.
   1573          
   1574          @endverbatim
   1575            * @{
   1576            */
   1577          /**
   1578            * @brief  Configures the RTC output for the output pin (RTC_ALARM output).
   1579            * @param  RTC_OutputSel: Specifies which signal will be mapped to the output.
   1580            *         This parameter can be one parameter from the 
   1581            *         @ref RTC_OutputSel_T enumeration.
   1582            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal.
   1583            *         This parameter can be one parameter from the 
   1584            *         @ref RTC_OutputPolarity_T enumeration.
   1585            * @retval None
   1586            */
   1587          void RTC_OutputConfig(RTC_Output_T RTC_Output,
   1588                                RTC_OutputPolarity_T RTC_OutputPolarity)
   1589          {
   1590            /* Check the parameters */
   1591            assert_param(IS_RTC_OUTPUT_SEL(RTC_Output));
   1592            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   1593          
   1594            /* Disable the write protection for RTC registers */
   1595            RTC->WPR = 0xCA;
   1596            RTC->WPR = 0x53;
   1597          
   1598            /* Clear the bits to be configured */
   1599            RTC->CR3 &= (uint8_t)~(RTC_CR3_OSEL | RTC_CR3_POL);
   1600          
   1601            /* Configure the output selection and polarity */
   1602            RTC->CR3 |= (uint8_t)((uint8_t)RTC_Output | (uint8_t)RTC_OutputPolarity);
   1603          
   1604            /* Enable the write protection for RTC registers */
   1605            RTC->WPR = 0xFF; 
   1606          }
   1607          
   1608          
   1609          
   1610          
   1611          /**
   1612            * @}
   1613            */
   1614          
   1615          /** @defgroup RTC_Group7 Output pin Configuration function
   1616           *  @brief   Output pin Configuration function 
   1617           *
   1618          @verbatim   
   1619           ===============================================================================
   1620                                   Output pin Configuration function
   1621           ===============================================================================  
   1622          
   1623            This section provide functions allowing to configure the RTC Output source.
   1624          
   1625          @endverbatim
   1626            * @{
   1627            */
   1628          /**
   1629          * @brief  Configures the Synchronization Shift Control Settings.
   1630          * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
   1631          *         This parameter can be one parameter from the @ref RTC_ShiftAdd1S_T
   1632          *         enumeration.
   1633          * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
   1634          *         This parameter can be one any value from 0 to 0x7FFF.
   1635           * @retval An ErrorStatus enumeration value:
   1636          *          - SUCCESS: RTC Shift registers are configured
   1637          *          - ERROR: RTC Shift registers are not configured
   1638          */
   1639          ErrorStatus RTC_SynchroShiftConfig(RTC_ShiftAdd1S_T RTC_ShiftAdd1S,
   1640                                             uint16_t RTC_ShiftSubFS)
   1641          {
   1642            uint8_t shiftrhreg = 0;
   1643            ErrorStatus status = ERROR;
   1644            uint16_t shpfcount = 0;
   1645          
   1646            /* Check the parameters */
   1647            assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
   1648            assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
   1649          
   1650            /* Disable the write protection for RTC registers */
   1651            RTC->WPR = 0xCA;
   1652            RTC->WPR = 0x53;
   1653          
   1654            /* Check if a Shift is pending*/
   1655            if ((RTC->ISR1 & RTC_ISR1_SHPF) != RESET)
   1656            {
   1657              /* wait until the shift is completed*/
   1658              while (((RTC->ISR1 & RTC_ISR1_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
   1659              {
   1660                shpfcount++;
   1661              }
   1662            }
   1663          
   1664            /* check if the Shift pending is completed or if there is no Shift operation at all*/
   1665            if ((RTC->ISR1 & RTC_ISR1_SHPF) == RESET)
   1666            {
   1667              /* Configure the Shift settings */
   1668              shiftrhreg = (uint8_t)((uint8_t)(RTC_ShiftSubFS >> 8) | (uint8_t)(RTC_ShiftAdd1S));
   1669              RTC->SHIFTRH = (uint8_t)(shiftrhreg);
   1670              RTC->SHIFTRL = (uint8_t)(RTC_ShiftSubFS);
   1671          
   1672              status = SUCCESS;
   1673            }
   1674            else
   1675            {
   1676              status = ERROR;
   1677            }
   1678          
   1679            /* Enable the write protection for RTC registers */
   1680            RTC->WPR = 0xFF; 
   1681          
   1682            return (ErrorStatus)(status);
   1683          }
   1684          
   1685          
   1686          
   1687          /**
   1688            * @}
   1689            */
   1690          
   1691          /** @defgroup RTC_Group8 Output pin Configuration function
   1692           *  @brief   Output pin Configuration function 
   1693           *
   1694          @verbatim   
   1695           ===============================================================================
   1696                                   Output pin Configuration function
   1697           ===============================================================================  
   1698          
   1699            This section provide functions allowing to configure the RTC Output source.
   1700          
   1701          @endverbatim
   1702            * @{
   1703            */
   1704          /**
   1705          * @brief  Configures the Smooth Calibration Settings.
   1706          * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
   1707          *         This parameter can be one parameter from
   1708          *         the @ref RTC_SmoothCalibPeriod_T enumeration.
   1709          * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
   1710          *         This parameter can be one parameter from the
   1711          *         @ref RTC_SmoothCalibPlusPulses_T enumeration.
   1712          * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1713          *         This parameter can be one any value from 0 to 0x01FF.
   1714          * @retval An ErrorStatus enumeration value:
   1715          *          - SUCCESS: RTC Calib registers are configured
   1716          *          - ERROR: RTC Calib registers are not configured
   1717          */
   1718          ErrorStatus RTC_SmoothCalibConfig(RTC_SmoothCalibPeriod_T RTC_SmoothCalibPeriod,
   1719                                            RTC_SmoothCalibPlusPulses_T RTC_SmoothCalibPlusPulses,
   1720                                            uint16_t RTC_SmouthCalibMinusPulsesValue)
   1721          {
   1722            ErrorStatus status = ERROR;
   1723            uint16_t recalpfcount = 0;
   1724          
   1725            /* Check the parameters */
   1726            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
   1727            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
   1728            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
   1729          
   1730            /* Disable the write protection for RTC registers */
   1731            RTC->WPR = 0xCA;
   1732            RTC->WPR = 0x53;
   1733          
   1734            /* check if a calibration is pending*/
   1735            if ((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET)
   1736            {
   1737              /* wait until the Calibration is completed*/
   1738              while (((RTC->ISR1 & RTC_ISR1_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
   1739              {
   1740                recalpfcount++;
   1741              }
   1742            }
   1743          
   1744            /* check if the calibration pending is completed or if there is 
   1745               no calibration operation at all*/
   1746            if ((RTC->ISR1 & RTC_ISR1_RECALPF) == RESET)
   1747            {
   1748              /* Configure the Smooth calibration settings */
   1749              RTC->CALRH = (uint8_t)((uint8_t)((uint8_t)RTC_SmoothCalibPeriod | \
   1750                                     (uint8_t)RTC_SmoothCalibPlusPulses) | \
   1751                                     (uint8_t)((uint16_t)RTC_SmouthCalibMinusPulsesValue >> 8));
   1752              RTC->CALRL = (uint8_t)(RTC_SmouthCalibMinusPulsesValue);
   1753          
   1754              status = SUCCESS;
   1755            }
   1756            else
   1757            {
   1758              status = ERROR;
   1759            }
   1760          
   1761            /* Enable the write protection for RTC registers */
   1762            RTC->WPR = 0xFF; 
   1763          
   1764            return (ErrorStatus)(status);
   1765          }
   1766          
   1767          
   1768          /**
   1769            * @}
   1770            */
   1771          
   1772          /** @defgroup RTC_Group9 Digital Calibration configuration functions
   1773           *  @brief   Digital Calibration configuration functions 
   1774           *
   1775          @verbatim   
   1776           ===============================================================================
   1777                            Calibration configuration functions
   1778           ===============================================================================  
   1779          
   1780          @endverbatim
   1781            * @{
   1782            */
   1783          /**
   1784          * @brief  Configure the Calibration Pin-out (RTC_CALIB) Selection (1Hz or 512Hz).
   1785          * @param  RTC_CalibOutput : Select the Calibration output Selection .
   1786          *         This parameter can be one parameter from the
   1787          *         @ref RTC_CalibOutput_T enumeration.
   1788          * @retval None
   1789          */
   1790          void RTC_CalibOutputConfig(RTC_CalibOutput_T RTC_CalibOutput)
   1791          {
   1792            /* Check the parameters */
   1793            assert_param(IS_RTC_CALOUTPUT_SELECT(RTC_CalibOutput));
   1794          
   1795            /* Disable the write protection for RTC registers */
   1796            RTC->WPR = 0xCA;
   1797            RTC->WPR = 0x53;
   1798          
   1799            if (RTC_CalibOutput != RTC_CalibOutput_512Hz)
   1800            {
   1801              /* Enable the RTC clock output */
   1802              RTC->CR3 |= (uint8_t)RTC_CR3_COSEL;
   1803            }
   1804            else
   1805            {
   1806              /* Disable the RTC clock output */
   1807              RTC->CR3 &= (uint8_t)~RTC_CR3_COSEL;
   1808            }
   1809          
   1810            /* Enable the write protection for RTC registers */
   1811            RTC->WPR = 0xFF; 
   1812          }
   1813          
   1814          /**
   1815          * @brief  Enables or disables the RTC clock to be output through the relative pin.
   1816          * @param  NewState: new state of the RTC Calibration output
   1817            *         This parameter can be: ENABLE or DISABLE.
   1818          * @retval None
   1819          */
   1820          void RTC_CalibOutputCmd(FunctionalState NewState)
   1821          {
   1822            /* Check the parameters */
   1823            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1824          
   1825            /* Disable the write protection for RTC registers */
   1826            RTC->WPR = 0xCA;
   1827            RTC->WPR = 0x53;
   1828          
   1829            if (NewState != DISABLE)
   1830            {
   1831              /* Enable the RTC clock output */
   1832              RTC->CR3 |= (uint8_t)RTC_CR3_COE;
   1833            }
   1834            else
   1835            {
   1836              /* Disable the RTC clock output */
   1837              RTC->CR3 &= (uint8_t)~RTC_CR3_COE;
   1838            }
   1839          
   1840            /* Enable the write protection for RTC registers */
   1841            RTC->WPR = 0xFF; 
   1842          }
   1843          
   1844          
   1845          /**
   1846            * @}
   1847            */
   1848          
   1849          /** @defgroup RTC_Group10 Tampers configuration functions
   1850           *  @brief   Tampers configuration functions 
   1851           *
   1852          @verbatim   
   1853           ===============================================================================
   1854                                 Tampers configuration functions
   1855           ===============================================================================  
   1856          
   1857          @endverbatim
   1858            * @{
   1859            */
   1860          
   1861          /**
   1862          * @brief  Configures the Tamper Sensitive Level.
   1863          * @param  RTC_Tamper: Select the tamper to configure.
   1864          *         This parameter can be one parameter from the @ref RTC_Tamper_T
   1865          *         enumeration.
   1866          * @param  RTC_TamperLevel: Select the tamper Sensitive Level.
   1867          *         This parameter can be one parameter from the 
   1868          *         @ref RTC_TamperLevel_T enumeration.
   1869          * @retval None
   1870          */
   1871          void RTC_TamperLevelConfig(RTC_Tamper_T RTC_Tamper,
   1872                                     RTC_TamperLevel_T RTC_TamperLevel)
   1873          {
   1874            /* Check the parameters */
   1875            assert_param(IS_RTC_TAMPER((uint8_t)RTC_Tamper));
   1876            assert_param(IS_RTC_TAMPER_LEVEL(RTC_TamperLevel));
   1877          
   1878            /* Disable the write protection for RTC registers */
   1879            RTC->WPR = 0xCA;
   1880            RTC->WPR = 0x53;
   1881          
   1882            if (RTC_TamperLevel != RTC_TamperLevel_Low)
   1883            {
   1884              /* Enable the selected Tampers */
   1885              RTC->TCR1 |= (uint8_t)(RTC_Tamper << 1);
   1886            }
   1887            else
   1888            {
   1889              /* Disable the selected Tampers */
   1890              RTC->TCR1 &= (uint8_t)~(uint8_t)(RTC_Tamper << 1);
   1891            }
   1892          
   1893            /* Enable the write protection for RTC registers */
   1894            RTC->WPR = 0xFF; 
   1895          }
   1896          /**
   1897            * @brief  Configures the Tampers Filter.
   1898            * @param  RTC_TamperFilter: Specifies the tampers filter.
   1899            *         This parameter can be one parameter from the
   1900            *         @ref RTC_TamperFilter_T enumeration.
   1901            * @retval None
   1902            */
   1903          void RTC_TamperFilterConfig(RTC_TamperFilter_T RTC_TamperFilter)
   1904          {
   1905          
   1906            /* Check the parameters */
   1907            assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   1908          
   1909            /* Disable the write protection for RTC registers */
   1910            RTC->WPR = 0xCA;
   1911            RTC->WPR = 0x53;
   1912          
   1913            /*clear flags before configuration */
   1914            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPFLT);
   1915          
   1916            /* Configure the RTC_TCR register */
   1917            RTC->TCR2 |= (uint8_t)RTC_TamperFilter;
   1918          
   1919            /* Enable the write protection for RTC registers */
   1920            RTC->WPR = 0xFF; 
   1921          
   1922          }
   1923          
   1924          /**
   1925            * @brief  Configures the Tampers Sampling Frequency.
   1926            * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
   1927            *         This parameter can be one parameter from the
   1928            *         @ref RTC_TamperSamplingFreq_T enumeration.
   1929            * @retval None
   1930            */
   1931          void RTC_TamperSamplingFreqConfig(RTC_TamperSamplingFreq_T RTC_TamperSamplingFreq)
   1932          {
   1933            /* Check the parameters */
   1934            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
   1935          
   1936            /* Disable the write protection for RTC registers */
   1937            RTC->WPR = 0xCA;
   1938            RTC->WPR = 0x53;
   1939          
   1940            /* Clear flags before configuration */
   1941            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPFREQ);
   1942          
   1943            /* Configure the RTC_TCR register */
   1944            RTC->TCR2 |= (uint8_t)RTC_TamperSamplingFreq;
   1945          
   1946            /* Enable the write protection for RTC registers */
   1947            RTC->WPR = 0xFF; 
   1948          }
   1949          
   1950          /**
   1951          * @brief  Configures the Tampers Pins input Precharge Duration.
   1952          * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
   1953          *         Precharge Duration.
   1954          *         This parameter can be one parameter from the
   1955          *         @ref RTC_TamperPrechargeDuration_T enumeration.
   1956          * @retval None
   1957          */
   1958          void RTC_TamperPinsPrechargeDuration(RTC_TamperPrechargeDuration_T RTC_TamperPrechargeDuration)
   1959          {
   1960            /* Check the parameters */
   1961            assert_param(IS_RTC_TAMPER_PINS_PRECHAR_DURATION(RTC_TamperPrechargeDuration));
   1962          
   1963            /* Disable the write protection for RTC registers */
   1964            RTC->WPR = 0xCA;
   1965            RTC->WPR = 0x53;
   1966          
   1967            /* Clear the tampers  pull-up  and precharge/discharge duration Old settings*/
   1968            RTC->TCR2 &= (uint8_t)~(RTC_TCR2_TAMPPUDIS | RTC_TCR2_TAMPPRCH);
   1969          
   1970            /* Configure the Tampers Precharge Duration  and pull-up New settings*/
   1971            RTC->TCR2 |= (uint8_t)RTC_TamperPrechargeDuration;
   1972          
   1973            /* Enable the write protection for RTC registers */
   1974            RTC->WPR = 0xFF; 
   1975          }
   1976          
   1977          
   1978          /**
   1979          * @brief  Enables or Disables the Tamper detection.
   1980          * @param  RTC_Tamper: Select the tamper to configure.
   1981          *         This parameter can be one parameter from the @ref RTC_Tamper_T
   1982          *         enumeration.
   1983          * @param  NewState: new state of the tamper pin.
   1984            *         This parameter can be: ENABLE or DISABLE.
   1985          * @retval None
   1986          */
   1987          void RTC_TamperCmd(RTC_Tamper_T RTC_Tamper,
   1988                             FunctionalState NewState)
   1989          {
   1990          
   1991            /* Check the parameters */
   1992            assert_param(IS_RTC_TAMPER((uint8_t)RTC_Tamper));
   1993            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1994          
   1995            /* Disable the write protection for RTC registers */
   1996            RTC->WPR = 0xCA;
   1997            RTC->WPR = 0x53;
   1998          
   1999          
   2000            if (NewState != DISABLE)
   2001            {
   2002              /* Enable the selected Tampers */
   2003              RTC->TCR1 |= (uint8_t)RTC_Tamper;
   2004            }
   2005            else
   2006            {
   2007              /* Disable the selected Tampers */
   2008              RTC->TCR1 &= (uint8_t)~RTC_Tamper;
   2009            }
   2010          
   2011          
   2012            /* Enable the write protection for RTC registers */
   2013            RTC->WPR = 0xFF; 
   2014          }
   2015          
   2016          
   2017          
   2018          /**
   2019            * @}
   2020            */
   2021          
   2022          /** @defgroup RTC_Group11 Interrupts and flags management functions
   2023           *  @brief   Interrupts and flags management functions  
   2024           *
   2025          @verbatim   
   2026           ===============================================================================
   2027                                 Interrupts and flags management functions
   2028           ===============================================================================  
   2029           
   2030           To enable the RTC Alarm interrupt, the following sequence is required:
   2031             - Configure the RTC to generate RTC alarm (Alarm A) using the RTC_SetAlarm() 
   2032               and RTC_AlarmCmd() functions.
   2033          
   2034           To enable the RTC Wakeup interrupt, the following sequence is required:
   2035             - Configure the RTC to generate the RTC wakeup timer event using the 
   2036               RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
   2037          
   2038           To enable the RTC Tamper interrupt, the following sequence is required:
   2039             - Configure the RTC to detect the RTC tamper event using the 
   2040               RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2041          
   2042          
   2043          
   2044          @endverbatim
   2045            * @{
   2046            */
   2047          /**
   2048          * @brief  Enables or Disables the specified RTC interrupts.
   2049          * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled.
   2050          *         This parameter can be any combination of the following values:
   2051          *         @arg RTC_IT_ALRA:  Alarm A interrupt
   2052          *         @arg RTC_IT_TAMP:  Tampers interrupt
   2053          *         @arg RTC_IT_WUT:  WakeUp Timer interrupt
   2054          * @param  NewState: new state of the specified RTC interrupts.
   2055            *         This parameter can be: ENABLE or DISABLE.
   2056          * @retval None
   2057          */
   2058          void RTC_ITConfig(RTC_IT_T RTC_IT, FunctionalState NewState)
   2059          {
   2060            /* Check the parameters */
   2061            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   2062            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2063          
   2064            /* Disable the write protection for RTC registers */
   2065            RTC->WPR = 0xCA;
   2066            RTC->WPR = 0x53;
   2067          
   2068            if (NewState != DISABLE)
   2069            {
   2070              /* Enable the Interrupts */
   2071              RTC->CR2 |= (uint8_t)((uint16_t)RTC_IT & (uint16_t)0x00F0);
   2072              RTC->TCR1 |= (uint8_t)((uint16_t)RTC_IT & RTC_TCR1_TAMPIE);
   2073            }
   2074            else
   2075            {
   2076              /* Disable the Interrupts */
   2077              RTC->CR2  &= (uint8_t)~(uint8_t)((uint16_t)RTC_IT & (uint16_t)0x00F0);
   2078              RTC->TCR1 &= (uint8_t)~(uint8_t)((uint16_t)RTC_IT & (uint16_t)RTC_TCR1_TAMPIE);
   2079            }
   2080          
   2081            /* Enable the write protection for RTC registers */
   2082            RTC->WPR = 0xFF; 
   2083          }
   2084          /**
   2085          * @brief  Checks whether the specified RTC flag is set or not.
   2086          * @param  RTC_FLAG: specifies the flag to check.
   2087          *         This parameter can be one of the @ref RTC_Flag_T enumeration.
   2088          * @retval Status of RTC_FLAG (SET or RESET)
   2089          */
   2090          FlagStatus RTC_GetFlagStatus(RTC_Flag_T RTC_FLAG)
   2091          {
   2092            FlagStatus flagstatus = RESET;
   2093            uint16_t tmpreg1 = 0;
   2094            uint16_t tmpreg2 = 0;
   2095          
   2096            /* Check the parameters */
   2097            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   2098          
   2099            /* Get all the flags */
   2100            tmpreg2 = (uint16_t)((uint16_t)RTC->ISR1 << 8);
   2101            tmpreg1 = (uint16_t)((uint16_t)((uint16_t)(RTC->ISR2)) | tmpreg2);
   2102          
   2103            /* Return the status of the flag */
   2104            if ((tmpreg1 & (uint16_t)RTC_FLAG) != RESET)
   2105            {
   2106              flagstatus = SET;
   2107            }
   2108            else
   2109            {
   2110              flagstatus = RESET;
   2111            }
   2112            return (FlagStatus)flagstatus;
   2113          }
   2114          
   2115          /**
   2116          * @brief  Clears the RTC's pending flags.
   2117          * @param  RTC_FLAG: specifies the RTC flag to clear.
   2118          *         This parameter can be any combination of the @ref RTC_Flag_T
   2119          *         enumeration.
   2120          * @retval None
   2121          */
   2122          void RTC_ClearFlag(RTC_Flag_T RTC_FLAG)
   2123          {
   2124            /* Check the parameters */
   2125            assert_param(IS_RTC_CLEAR_FLAG((uint16_t)RTC_FLAG));
   2126          
   2127            /* Clear the Flags in the RTC_ISR registers */
   2128            RTC->ISR2 = (uint8_t)~((uint8_t)RTC_FLAG) ;
   2129            RTC->ISR1 = (uint8_t)(((uint8_t)~(uint8_t)((uint16_t)RTC_FLAG >> (uint8_t)8)) & ((uint8_t)~(uint8_t)(RTC_ISR1_INIT)));
   2130          }
   2131          
   2132          /**
   2133          * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2134          * @param  RTC_IT: specifies the RTC interrupt source to check.
   2135          *         This parameter can be one of the @ref RTC_IT_T enumeration.
   2136          * @retval Status of RTC_IT (SET or RESET).
   2137          */
   2138          ITStatus RTC_GetITStatus(RTC_IT_T RTC_IT)
   2139          {
   2140            ITStatus itstatus = RESET;
   2141            uint8_t enablestatus = 0, tmpreg = 0;
   2142          
   2143            /* Check the parameters */
   2144            assert_param(IS_RTC_GET_IT(RTC_IT));
   2145          
   2146            /* Get the Interrupt enable Status */
   2147            enablestatus = (uint8_t)(RTC->CR2 & (uint16_t)RTC_IT);
   2148          
   2149            /* Get the Interrupt pending bit */
   2150            tmpreg = (uint8_t)(RTC->ISR2 & (uint8_t)((uint16_t)RTC_IT >> 4));
   2151          
   2152            /* Get the status of the Interrupt */
   2153            if ((enablestatus != (uint8_t)RESET) && (tmpreg != (uint8_t)RESET))
   2154            {
   2155              itstatus = SET;
   2156            }
   2157            else
   2158            {
   2159              itstatus = RESET;
   2160            }
   2161          
   2162            return (ITStatus)itstatus;
   2163          }
   2164          
   2165          /**
   2166          * @brief  Clears the RTC's interrupt pending bits.
   2167          * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2168          *         This parameter can be any combination of the @ref RTC_IT_T
   2169          *         enumeration.
   2170          * @retval None
   2171          */
   2172          void RTC_ClearITPendingBit(RTC_IT_T RTC_IT)
   2173          {
   2174            /* Check the parameters */
   2175            assert_param(IS_RTC_CLEAR_IT((uint16_t)RTC_IT));
   2176          
   2177            /* Clear the interrupt pending bits in the RTC_ISR registers */
   2178            RTC->ISR2 = (uint8_t)~(uint8_t)((uint16_t)RTC_IT >> 4);
   2179          }
   2180          
   2181          /**
   2182            * @}
   2183            */
   2184          
   2185          
   2186          
   2187          
   2188          
   2189          
   2190          
   2191          
   2192          
   2193          /**
   2194           * @addtogroup RTC_Private_Functions
   2195           * @{
   2196           */
   2197          /**
   2198          * @brief  Converts a 2 digit decimal to BCD format
   2199          * @param  Value: Byte to be converted.
   2200          * @retval Converted byte
   2201          */
   2202          static uint8_t ByteToBcd2(uint8_t Value)
   2203          {
   2204            uint8_t bcdhigh = 0;
   2205          
   2206            while (Value >= 10)
   2207            {
   2208              bcdhigh++;
   2209              Value -= 10;
   2210            }
   2211          
   2212            return  (uint8_t)((uint8_t)(bcdhigh << 4) | Value);
   2213          }
   2214          
   2215          /**
   2216          * @brief  Converts from 2 digit BCD to Binary format
   2217          * @param  Value: BCD value to be converted.
   2218          * @retval Converted word
   2219          */
   2220          static uint8_t Bcd2ToByte(uint8_t Value)
   2221          {
   2222            uint8_t tmp = 0;
   2223          
   2224            tmp = (uint8_t)((uint8_t)((uint8_t)(Value & (uint8_t)0xF0) >> 4) * (uint8_t)10);
   2225          
   2226            return (uint8_t)(tmp + (Value & (uint8_t)0x0F));
   2227          }
   2228          
   2229          /**
   2230            * @}
   2231            */ 
   2232          
   2233          /**
   2234            * @}
   2235            */ 
   2236            
   2237          /**
   2238            * @}
   2239            */
   2240          
   2241          /**
   2242            * @}
   2243            */
   2244          
   2245          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
       7  ??Subroutine24_0
      12  ??Subroutine25_0
      40  ??Subroutine26_0
       5  ??Subroutine27_0
       9  ?Subroutine0
      25  ?Subroutine1
       6  ?Subroutine10
      17  ?Subroutine11
      14  ?Subroutine12
       9  ?Subroutine13
      11  ?Subroutine14
       8  ?Subroutine15
       6  ?Subroutine16
       3  ?Subroutine17
       8  ?Subroutine18
      13  ?Subroutine19
       9  ?Subroutine2
       3  ?Subroutine20
      23  ?Subroutine21
       8  ?Subroutine22
       9  ?Subroutine23
      12  ?Subroutine3
       5  ?Subroutine4
       7  ?Subroutine5
      10  ?Subroutine6
      14  ?Subroutine7
      16  ?Subroutine8
      12  ?Subroutine9
      27  ByteToBcd2
      57  RTC_AlarmCmd
      31  RTC_AlarmStructInit
      56  RTC_AlarmSubSecondConfig
      21  RTC_BypassShadowCmd
      21  RTC_CalibOutputCmd
      21  RTC_CalibOutputConfig
      15  RTC_ClearFlag
      10  RTC_ClearITPendingBit
      17  RTC_DateStructInit
      17  RTC_DayLightSavingConfig
     224  RTC_DeInit
      28  RTC_EnterInitMode
       5  RTC_ExitInitMode
     187  RTC_GetAlarm
      65  RTC_GetDate
      33  RTC_GetFlagStatus
      36  RTC_GetITStatus
       6  RTC_GetStoreOperation
      23  RTC_GetSubSecond
      59  RTC_GetTime
      23  RTC_GetWakeUpCounter
      48  RTC_ITConfig
      90  RTC_Init
      19  RTC_OutputConfig
      21  RTC_RatioCmd
     219  RTC_SetAlarm
     192  RTC_SetDate
     184  RTC_SetTime
      22  RTC_SetWakeUpCounter
      55  RTC_SmoothCalibConfig
      19  RTC_StructInit
      49  RTC_SynchroShiftConfig
      22  RTC_TamperCmd
      11  RTC_TamperFilterConfig
      23  RTC_TamperLevelConfig
      11  RTC_TamperPinsPrechargeDuration
      11  RTC_TamperSamplingFreqConfig
       9  RTC_TimeStructInit
      23  RTC_WaitForSynchro
      31  RTC_WakeUpClockConfig
      42  RTC_WakeUpCmd
      13  RTC_WriteProtectionCmd

 
 2 417 bytes in section .far_func.text
 
 2 417 bytes of CODE memory

Errors: none
Warnings: none
