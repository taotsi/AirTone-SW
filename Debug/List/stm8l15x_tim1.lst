###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:23
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim1.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim1.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_tim1.lst
#    Object file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_tim1.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_tim1.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_tim1.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM1 peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Interrupts, DMA and flags management
     13            *            - Clocks management
     14            *            - Synchronization management
     15            *            - Specific interface management
     16            *              
     17            *  @verbatim
     18            *  
     19            *          ===================================================================
     20            *                                 How to use this driver
     21            *          ===================================================================
     22            *          This driver provides functions to configure and initialize the TIM1 
     23            *          peripheral
     24            *          These functions are split in 7 groups: 
     25            *   
     26            *          1. TIM1 TimeBase management: this group includes all needed functions 
     27            *             to configure the TIM Timebase unit:
     28            *                   - Set/Get Prescaler
     29            *                   - Set/Get Autoreload  
     30            *                   - Counter modes configuration
     31            *                   - Select the One Pulse mode
     32            *                   - Update Request Configuration
     33            *                   - Update Disable Configuration
     34            *                   - Auto-Preload Configuration 
     35            *                   - Enable/Disable the counter
     36            *                 
     37            *          2. TIM1 Output Compare management: this group includes all needed 
     38            *             functions to configure the Capture/Compare unit used in Output 
     39            *             compare mode: 
     40            *                   - Configure each channel, independently, in Output Compare mode
     41            *                   - Select the output compare modes
     42            *                   - Select the Polarities of each channel
     43            *                   - Set/Get the Capture/Compare register values
     44            *                   - Select the Output Compare Fast mode 
     45            *                   - Select the Output Compare Forced mode  
     46            *                   - Output Compare-Preload Configuration 
     47            *                   - Clear Output Compare Reference
     48            *                   - Select the OCREF Clear signal
     49            *                   - Enable/Disable the Capture/Compare Channels    
     50            *                   
     51            *          3. TIM1 Input Capture management: this group includes all needed 
     52            *             functions to configure the Capture/Compare unit used in 
     53            *             Input Capture mode:
     54            *                   - Configure each channel in input capture mode
     55            *                   - Configure Channel1/2 in PWM Input mode
     56            *                   - Set the Input Capture Prescaler
     57            *                   - Get the Capture/Compare values      
     58            *        
     59            *          4. TIM1 interrupts, DMA and flags management
     60            *                   - Enable/Disable interrupt sources
     61            *                   - Get flags status
     62            *                   - Clear flags/ Pending bits
     63            *                   - Enable/Disable DMA requests 
     64            *                   - Configure DMA burst mode
     65            *                   - Select CaptureCompare DMA request  
     66            *              
     67            *          5. TIM1 clocks management: this group includes all needed functions 
     68            *             to configure the clock controller unit:
     69            *                   - Select internal/External clock
     70            *                   - Select the external clock mode: ETR(Mode1/Mode2) or TIx
     71            *         
     72            *          6. TIM1 synchronization management: this group includes all needed 
     73            *             functions to configure the Synchronization unit:
     74            *                   - Select Input Trigger  
     75            *                   - Select Output Trigger  
     76            *                   - Select Master Slave Mode 
     77            *                   - ETR Configuration when used as external trigger   
     78            *     
     79            *          7. TIM1 specific interface management, this group includes all 
     80            *             needed functions to use the specific TIM1 interface:
     81            *                   - Encoder Interface Configuration
     82            *                   - Select Hall Sensor        
     83            *   
     84            *  @endverbatim
     85            *    
     86            ******************************************************************************
     87            * @attention
     88            *
     89            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     90            *
     91            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     92            * You may not use this file except in compliance with the License.
     93            * You may obtain a copy of the License at:
     94            *
     95            *        http://www.st.com/software_license_agreement_liberty_v2
     96            *
     97            * Unless required by applicable law or agreed to in writing, software 
     98            * distributed under the License is distributed on an "AS IS" BASIS, 
     99            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    100            * See the License for the specific language governing permissions and
    101            * limitations under the License.
    102            *
    103            ******************************************************************************
    104            */
    105          
    106          /* Includes ------------------------------------------------------------------*/
    107          #include "stm8l15x_tim1.h"
    108          
    109          /** @addtogroup STM8L15x_StdPeriph_Driver
    110            * @{
    111            */
    112          
    113          /** @defgroup TIM1
    114            * @brief TIM1 driver modules
    115            * @{
    116            */
    117            
    118          /* Private typedef -----------------------------------------------------------*/
    119          /* Private define ------------------------------------------------------------*/
    120          /* Private macro -------------------------------------------------------------*/
    121          /* Private variables ---------------------------------------------------------*/
    122          /* Private function prototypes -----------------------------------------------*/
    123          /** @defgroup TIM1_Private_Functions_Prototypes
    124            * @{
    125            */
    126          
    127          static void TI1_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    128                                 uint8_t TIM1_ICFilter);
    129          static void TI2_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    130                                 uint8_t TIM1_ICFilter);
    131          static void TI3_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    132                                 uint8_t TIM1_ICFilter);
    133          static void TI4_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection,
    134                                 uint8_t TIM1_ICFilter);
    135          
    136          /**
    137            * @}
    138            */
    139          
    140          /* Private functions ---------------------------------------------------------*/  
    141          /** @defgroup TIM1_Private_Functions
    142            * @{
    143            */
    144          
    145          /** @defgroup TIM1_Group1 TimeBase management functions
    146           *  @brief   TimeBase management functions 
    147           *
    148          @verbatim   
    149           ===============================================================================
    150                                 TimeBase management functions
    151           ===============================================================================  
    152            
    153                 ===================================================================      
    154                        TIM1 Driver: how to use it in Timing(Time base) Mode
    155                 =================================================================== 
    156                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    157                 
    158                 1. Enable TIM1 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM1, ENABLE) function.
    159                  
    160                 2. Call TIM1_TimeBaseInit() to configure the Time Base unit with the
    161                    corresponding configuration.
    162                    
    163                 3. Enable global interrupts if you need to generate the update interrupt.
    164                    
    165                 4. Enable the corresponding interrupt using the function TIM1_ITConfig(TIM1_IT_Update) 
    166                    
    167                 5. Call the TIM1_Cmd(ENABLE) function to enable the TIM1 counter.
    168                 
    169                 Note1: All other functions can be used separately to modify, if needed,
    170                    a specific feature of the Timer. 
    171          
    172          @endverbatim
    173            * @{
    174            */
    175          
    176          /**
    177            * @brief  Deinitializes the TIM1 peripheral registers to their default reset values.
    178            * @param  None
    179            * @retval None
    180            */
    181          void TIM1_DeInit(void)
    182          {
    183            TIM1->CR1  = TIM1_CR1_RESET_VALUE;
    184            TIM1->CR2  = TIM1_CR2_RESET_VALUE;
    185            TIM1->SMCR = TIM1_SMCR_RESET_VALUE;
    186            TIM1->ETR  = TIM1_ETR_RESET_VALUE;
    187            TIM1->IER  = TIM1_IER_RESET_VALUE;
    188          
    189            /* Disable channels */
    190            TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
    191            TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
    192            /* Configure channels as inputs: it is necessary if lock level is equal to 2 or 3 */
    193            TIM1->CCMR1 = 0x01;
    194            TIM1->CCMR2 = 0x01;
    195            TIM1->CCMR3 = 0x01;
    196            TIM1->CCMR4 = 0x01;
    197            /* Then reset channel registers: it also works if lock level is equal to 2 or 3 */
    198            TIM1->CCER1 = TIM1_CCER1_RESET_VALUE;
    199            TIM1->CCER2 = TIM1_CCER2_RESET_VALUE;
    200            TIM1->CCMR1 = TIM1_CCMR1_RESET_VALUE;
    201            TIM1->CCMR2 = TIM1_CCMR2_RESET_VALUE;
    202            TIM1->CCMR3 = TIM1_CCMR3_RESET_VALUE;
    203            TIM1->CCMR4 = TIM1_CCMR4_RESET_VALUE;
    204            TIM1->CNTRH = TIM1_CNTRH_RESET_VALUE;
    205            TIM1->CNTRL = TIM1_CNTRL_RESET_VALUE;
    206            TIM1->PSCRH = TIM1_PSCRH_RESET_VALUE;
    207            TIM1->PSCRL = TIM1_PSCRL_RESET_VALUE;
    208            TIM1->ARRH  = TIM1_ARRH_RESET_VALUE;
    209            TIM1->ARRL  = TIM1_ARRL_RESET_VALUE;
    210            TIM1->CCR1H = TIM1_CCR1H_RESET_VALUE;
    211            TIM1->CCR1L = TIM1_CCR1L_RESET_VALUE;
    212            TIM1->CCR2H = TIM1_CCR2H_RESET_VALUE;
    213            TIM1->CCR2L = TIM1_CCR2L_RESET_VALUE;
    214            TIM1->CCR3H = TIM1_CCR3H_RESET_VALUE;
    215            TIM1->CCR3L = TIM1_CCR3L_RESET_VALUE;
    216            TIM1->CCR4H = TIM1_CCR4H_RESET_VALUE;
    217            TIM1->CCR4L = TIM1_CCR4L_RESET_VALUE;
    218            TIM1->OISR  = TIM1_OISR_RESET_VALUE;
    219            TIM1->EGR   = 0x01; /* TIM1_EGR_UG */
    220            TIM1->DTR   = TIM1_DTR_RESET_VALUE;
    221            TIM1->BKR   = TIM1_BKR_RESET_VALUE;
    222            TIM1->RCR   = TIM1_RCR_RESET_VALUE;
    223            TIM1->SR1   = TIM1_SR1_RESET_VALUE;
    224            TIM1->SR2   = TIM1_SR2_RESET_VALUE;
    225          }
    226          
    227          /**
    228            * @brief  Initializes the TIM1 Time Base Unit according to the specified parameters.
    229            * @param  TIM1_Prescaler specifies the Prescaler value.
    230            * @param  TIM1_CounterMode specifies the counter mode from
    231            *          This parameter can be one of the following values:
    232            *            @arg TIM1_CounterMode_Up: Counter mode Up
    233            *            @arg TIM1_CounterMode_Down: Counter mode Down
    234            *            @arg TIM1_CounterMode_CenterAligned1: Counter mode center aligned
    235            *            @arg TIM1_CounterMode_CenterAligned2: Counter mode center aligned
    236            *            @arg TIM1_CounterMode_CenterAligned3: Counter mode center aligned
    237            * @param  TIM1_Period specifies the Period value.
    238            * @param  TIM1_RepetitionCounter specifies the Repetition counter value
    239            * @retval None
    240            */
    241          void TIM1_TimeBaseInit(uint16_t TIM1_Prescaler,
    242                                 TIM1_CounterMode_T TIM1_CounterMode,
    243                                 uint16_t TIM1_Period,
    244                                 uint8_t TIM1_RepetitionCounter)
    245          {
    246            /* Check parameters */
    247            assert_param(IS_TIM1_COUNTER_MODE(TIM1_CounterMode));
    248          
    249          
    250            /* Set the Autoreload value */
    251            TIM1->ARRH = (uint8_t)(TIM1_Period >> 8);
    252            TIM1->ARRL = (uint8_t)(TIM1_Period);
    253          
    254            /* Set the Prescaler value */
    255            TIM1->PSCRH = (uint8_t)(TIM1_Prescaler >> 8);
    256            TIM1->PSCRL = (uint8_t)(TIM1_Prescaler);
    257          
    258            /* Select the Counter Mode */
    259            TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)(~(TIM1_CR1_CMS | TIM1_CR1_DIR)))
    260                                  | (uint8_t)(TIM1_CounterMode));
    261          
    262            /* Set the Repetition Counter value */
    263            TIM1->RCR = TIM1_RepetitionCounter;
    264          
    265          }
    266          
    267          /**
    268            * @brief  Configures the TIM1 Prescaler.
    269            * @param  Prescaler specifies the Prescaler Register value
    270            *          This parameter must be a value between 0x0000 and 0xFFFF
    271            * @param  TIM1_PSCReloadMode specifies the TIM1 Prescaler Reload mode.
    272            *          This parameter can be one of the following values
    273            *            @arg TIM1_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
    274            *            @arg TIM1_PSCReloadMode_Update: The Prescaler is loaded at the update
    275            *         event.
    276            * @retval None
    277            */
    278          
    279          void TIM1_PrescalerConfig(uint16_t Prescaler, TIM1_PSCReloadMode_T TIM1_PSCReloadMode)
    280          {
    281            /* Check the parameters */
    282            assert_param(IS_TIM1_PRESCALER_RELOAD(TIM1_PSCReloadMode));
    283          
    284            /* Set the Prescaler value */
    285            TIM1->PSCRH = (uint8_t)(Prescaler >> 8);
    286            TIM1->PSCRL = (uint8_t)(Prescaler);
    287          
    288            /* Set or reset the UG Bit */
    289            TIM1->EGR = (uint8_t)TIM1_PSCReloadMode;
    290          }
    291          
    292          /**
    293            * @brief  Specifies the TIM1 Counter Mode to be used.
    294            * @param  TIM1_CounterMode specifies the Counter Mode to be used
    295            *          This parameter can be one of the following values:
    296            *            @arg TIM1_CounterMode_Up: TIM1 Up Counting Mode
    297            *            @arg TIM1_CounterMode_Down: TIM1 Down Counting Mode
    298            *            @arg TIM1_CounterMode_CenterAligned1: TIM1 Center Aligned Mode1
    299            *            @arg TIM1_CounterMode_CenterAligned2: TIM1 Center Aligned Mode2
    300            *            @arg IM1_CounterMode_CenterAligned3: TIM1 Center Aligned Mode3
    301            * @retval None
    302            */
    303          void TIM1_CounterModeConfig(TIM1_CounterMode_T TIM1_CounterMode)
    304          {
    305            /* Check the parameters */
    306            assert_param(IS_TIM1_COUNTER_MODE(TIM1_CounterMode));
    307          
    308          
    309            /* Reset the CMS and DIR Bits & Set the Counter Mode */
    310            TIM1->CR1 = (uint8_t)((uint8_t)(TIM1->CR1 & (uint8_t)((uint8_t)(~TIM1_CR1_CMS) & (uint8_t)(~TIM1_CR1_DIR)))
    311                                  | (uint8_t)TIM1_CounterMode);
    312          }
    313          
    314          /**
    315            * @brief  Sets the TIM1 Counter Register value.
    316            * @param  Counter specifies the Counter register new value.
    317            *          This parameter is between 0x0000 and 0xFFFF.
    318            * @retval None
    319            */
    320          void TIM1_SetCounter(uint16_t Counter)
    321          {
    322            /* Set the Counter Register value */
    323            TIM1->CNTRH = (uint8_t)(Counter >> 8);
    324            TIM1->CNTRL = (uint8_t)(Counter);
    325          }
    326          
    327          /**
    328            * @brief  Sets the TIM1 Autoreload Register value.
    329            * @param  Autoreload specifies the Autoreload register new value.
    330            *          This parameter is between 0x0000 and 0xFFFF.
    331            * @retval None
    332            */
    333          void TIM1_SetAutoreload(uint16_t Autoreload)
    334          {
    335            /* Set the Autoreload Register value */
    336            TIM1->ARRH = (uint8_t)(Autoreload >> 8);
    337            TIM1->ARRL = (uint8_t)(Autoreload);
    338          }
    339          
    340          /**
    341            * @brief  Gets the TIM1 Counter value.
    342            * @param  None
    343            * @retval Counter Register value.
    344            */
    345          uint16_t TIM1_GetCounter(void)
    346          {
    347            /* Get the Counter Register value */
    348            uint16_t tmpcntr = 0;
    349            uint8_t tmpcntrl = 0, tmpcntrh = 0;
    350          
    351            tmpcntrh = TIM1->CNTRH;
    352            tmpcntrl = TIM1->CNTRL;
    353          
    354            tmpcntr  = (uint16_t)(tmpcntrl);
    355            tmpcntr |= (uint16_t)((uint16_t)tmpcntrh << 8);
    356          
    357            /* Get the Counter Register value */
    358            return (uint16_t)tmpcntr;
    359          }
    360          
    361          /**
    362            * @brief  Gets the TIM1 Prescaler value.
    363            * @param  None
    364            * @retval Prescaler Register value.
    365            */
    366          uint16_t TIM1_GetPrescaler(void)
    367          {
    368            uint16_t tmpreg = 0;
    369            tmpreg = (uint16_t)((uint16_t)TIM1->PSCRH << 8);
    370            /* Get the Prescaler Register value */
    371            return (uint16_t)(tmpreg | TIM1->PSCRL);
    372          }
    373          
    374          /**
    375            * @brief  Enables or Disables the TIM1 Update event.
    376            * @param  NewState new state of the TIM1 peripheral Preload register.
    377            *          This parameter can be ENABLE or DISABLE.
    378            * @retval None
    379            */
    380          void TIM1_UpdateDisableConfig(FunctionalState NewState)
    381          {
    382            /* Check the parameters */
    383            assert_param(IS_FUNCTIONAL_STATE(NewState));
    384          
    385            /* Set or Reset the UDIS Bit */
    386            if (NewState != DISABLE)
    387            {
    388              TIM1->CR1 |= TIM1_CR1_UDIS;
    389            }
    390            else
    391            {
    392              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_UDIS);
    393            }
    394          }
    395          
    396          /**
    397            * @brief  Selects the TIM1 Update Request Interrupt source.
    398            * @param  TIM1_UpdateSource specifies the Update source.
    399            *          This parameter can be one of the following values
    400            *            @arg TIM1_UpdateSource_Regular
    401            *            @arg TIM1_UpdateSource_Global
    402            * @retval None
    403            */
    404          void TIM1_UpdateRequestConfig(TIM1_UpdateSource_T TIM1_UpdateSource)
    405          {
    406            /* Check the parameters */
    407            assert_param(IS_TIM1_UPDATE_SOURCE(TIM1_UpdateSource));
    408          
    409            /* Set or Reset the URS Bit */
    410            if (TIM1_UpdateSource != TIM1_UpdateSource_Global)
    411            {
    412              TIM1->CR1 |= TIM1_CR1_URS;
    413            }
    414            else
    415            {
    416              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_URS);
    417            }
    418          }
    419          
    420          /**
    421            * @brief  Enables or disables TIM1 peripheral Preload register on ARR.
    422            * @param  NewState new state of the TIM1 peripheral Preload register.
    423            *          This parameter can be ENABLE or DISABLE.
    424            * @retval None
    425            */
    426          void TIM1_ARRPreloadConfig(FunctionalState NewState)
    427          {
    428            /* Check the parameters */
    429            assert_param(IS_FUNCTIONAL_STATE(NewState));
    430          
    431            /* Set or Reset the ARPE Bit */
    432            if (NewState != DISABLE)
    433            {
    434              TIM1->CR1 |= TIM1_CR1_ARPE;
    435            }
    436            else
    437            {
    438              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_ARPE);
    439            }
    440          }
    441          
    442          /**
    443            * @brief  Selects the TIM1�s One Pulse Mode.
    444            * @param  TIM1_OPMode specifies the OPM Mode to be used.
    445            *          This parameter can be one of the following values
    446            *            @arg TIM1_OPMode_Single
    447            *            @arg TIM1_OPMode_Repetitive
    448            * @retval None
    449            */
    450          void TIM1_SelectOnePulseMode(TIM1_OPMode_T TIM1_OPMode)
    451          {
    452            /* Check the parameters */
    453            assert_param(IS_TIM1_OPM_MODE(TIM1_OPMode));
    454          
    455            /* Set or Reset the OPM Bit */
    456            if (TIM1_OPMode != TIM1_OPMode_Repetitive)
    457            {
    458              TIM1->CR1 |= TIM1_CR1_OPM;
    459            }
    460            else
    461            {
    462              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_OPM);
    463            }
    464          }
    465          
    466          /**
    467            * @brief  Enables or disables the TIM1 peripheral.
    468            * @param  NewState new state of the TIM1 peripheral. 
    469            *          This parameter can be ENABLE or DISABLE.
    470            * @retval None
    471            */
    472          void TIM1_Cmd(FunctionalState NewState)
    473          {
    474            /* Check the parameters */
    475            assert_param(IS_FUNCTIONAL_STATE(NewState));
    476          
    477            /* set or Reset the CEN Bit */
    478            if (NewState != DISABLE)
    479            {
    480              TIM1->CR1 |= TIM1_CR1_CEN;
    481            }
    482            else
    483            {
    484              TIM1->CR1 &= (uint8_t)(~TIM1_CR1_CEN);
    485            }
    486          }
    487          
    488          /**
    489            * @}
    490            */
    491          
    492          /** @defgroup TIM1_Group2 Output Compare management functions
    493           *  @brief    Output Compare management functions 
    494           *
    495          @verbatim   
    496           ===============================================================================
    497                                  Output Compare management functions
    498           ===============================================================================  
    499             
    500                 ===================================================================      
    501                        TIM1 Driver: how to use it in Output Compare Mode
    502                 =================================================================== 
    503                 To use the Timer in Output Compare mode, the following steps are mandatory:
    504                 
    505                 1. Enable TIM1 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM1, ENABLE) function.
    506                 
    507                 2. Configure the TIM1 pins in output mode by configuring the corresponding GPIO pins
    508                    
    509                 3. Configure the Time base unit as described in the first part of this driver, if needed,
    510                    otherwise the Timer will run with the default configuration:
    511                    - Autoreload value = 0xFFFF
    512                    - Prescaler value = 0x0000
    513                    - Counter mode = Up counting
    514                
    515                 4. Call TIM1_OCxInit() to configure the channel x with the desired parameters
    516                    including:
    517                    - TIM1 Output Compare mode: TIM1_OCMode
    518                    - TIM1 Output State: TIM1_OutputState
    519                    - TIM1 Complementary Output State: TIM1_OutputNState
    520                    - TIM1 Pulse value: TIM1_Pulse
    521                    - TIM1 Output Compare Polarity : TIM1_OCPolarity
    522                    - TIM1 Complementary Output Compare Polarity : TIM1_OCNPolarity
    523                    - TIM1 Output Idle State: TIM1_OCIdleState
    524                    - TIM1 Complementary Output Idle State: TIM1_OCNIdleState
    525                 
    526                 5. Call the TIM1_Cmd(ENABLE) function to enable the TIM1 counter.
    527                 
    528                 Note1: All other functions can be used separately to modify, if needed,
    529                    a specific feature of the Timer. 
    530                 
    531                 Note2: If the corresponding interrupt or DMA request are needed, the user should:
    532                        1. Enable global interrupts (or the DMA) to use the TIM1 interrupts (or DMA requests). 
    533                        2. Enable the corresponding interrupt (or DMA request) using the function 
    534                        TIM1_ITConfig(TIM1_IT_CCx) (or TIM1_DMACmd(TIM1_DMASource_CCx))   
    535          
    536          @endverbatim
    537            * @{
    538            */
    539            
    540          /**
    541            * @brief  Initializes the TIM1 Channel1 according to the specified parameters.
    542            * @param  TIM1_OCMode specifies the Output Compare mode
    543            *          This parameter can be one of the following values:
    544            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    545            *            @arg TIM1_OCMode_Active: OC Mode Active
    546            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    547            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    548            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    549            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2          
    550            * @param  TIM1_OutputState specifies the Output State
    551            *          This parameter can be one of the following values:
    552            *            @arg TIM1_OutputState_Disable: Output state disable
    553            *            @arg TIM1_OutputState_Enable: Output state enable
    554            * @param  TIM1_OutputNState specifies the Complementary Output State
    555            *          This parameter can be one of the following values:
    556            *            @arg TIM1_OutputNState_Disable: Output N state disable
    557            *            @arg TIM1_OutputNState_Enable: Output N state enable
    558            * @param  TIM1_Pulse specifies the Pulse width value.
    559            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    560            *          This parameter can be one of the following values:
    561            *            @arg TIM1_OCPolarity_High: Output Compare active low
    562            *            @arg TIM1_OCPolarity_Low: Output Compare active high
    563            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity 
    564            *          This parameter can be one of the following values:
    565            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
    566            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
    567            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    568            *          This parameter can be one of the following values:
    569            *            @arg TIM1_OCIdleState_Set: Output Compare Idle state set
    570            *            @arg TIM1_OCIdleState_Reset: Output Compare Idle state reset
    571            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle State
    572            *          This parameter can be one of the following values:
    573            *            @arg TIM1_OCNIdleState_Set: Complementary Output Compare Idle state set
    574            *            @arg TIM1_OCNIdleState_Reset: Complementary Output Compare Idle state reset
    575            * @retval None
    576            */
    577          void TIM1_OC1Init(TIM1_OCMode_T TIM1_OCMode,
    578                            TIM1_OutputState_T TIM1_OutputState,
    579                            TIM1_OutputNState_T TIM1_OutputNState,
    580                            uint16_t TIM1_Pulse,
    581                            TIM1_OCPolarity_T TIM1_OCPolarity,
    582                            TIM1_OCNPolarity_T TIM1_OCNPolarity,
    583                            TIM1_OCIdleState_T TIM1_OCIdleState,
    584                            TIM1_OCNIdleState_T TIM1_OCNIdleState)
    585          {
    586            /* Check the parameters */
    587            assert_param(IS_TIM1_OC_MODE(TIM1_OCMode));
    588            assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OutputState));
    589            assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OutputNState));
    590            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
    591            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
    592            assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCIdleState));
    593            assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCNIdleState));
    594          
    595            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State ,
    596            the Output N State, the Output Polarity & the Output N Polarity*/
    597            TIM1->CCER1 &= (uint8_t)(~(TIM1_CCER1_CC1E | TIM1_CCER1_CC1NE
    598                                       | TIM1_CCER1_CC1P | TIM1_CCER1_CC1NP));
    599            /* Set the Output State & Set the Output N State & Set the Output Polarity
    600            & Set the Output N Polarity */
    601            TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC1E)
    602                                               | (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC1NE))
    603                                     | (uint8_t)( (uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC1P)
    604                                                  | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC1NP)));
    605          
    606            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    607            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM))
    608                                    | (uint8_t)TIM1_OCMode);
    609          
    610            /* Reset the Output Idle state & the Output N Idle state bits */
    611            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS1 | TIM1_OISR_OIS1N));
    612            /* Set the Output Idle state & the Output N Idle state configuration */
    613            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OCIdleState & TIM1_OISR_OIS1)
    614                                    | (uint8_t)(TIM1_OCNIdleState & TIM1_OISR_OIS1N));
    615          
    616            /* Set the Pulse value */
    617            TIM1->CCR1H = (uint8_t)(TIM1_Pulse >> 8);
    618            TIM1->CCR1L = (uint8_t)(TIM1_Pulse);
    619          }
    620          
    621          /**
    622            * @brief  Initializes the TIM1 Channel2 according to the specified parameters.
    623            * @param  TIM1_OCMode specifies the Output Compare mode
    624            *          This parameter can be one of the following values:
    625            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    626            *            @arg TIM1_OCMode_Active: OC Mode Active
    627            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    628            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    629            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    630            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2  
    631            * @param  TIM1_OutputState specifies the Output State
    632            *          This parameter can be one of the following values:
    633            *            @arg TIM1_OutputState_Disable: Output state disable
    634            *            @arg TIM1_OutputState_Enable: Output state enable
    635            * @param  TIM1_OutputNState specifies the Complementary Output State
    636            *          This parameter can be one of the following values:
    637            *            @arg TIM1_OutputNState_Disable: Output N state disable
    638            *            @arg TIM1_OutputNState_Enable: Output N state enable
    639            * @param  TIM1_Pulse specifies the Pulse width value.
    640            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    641            *          This parameter can be one of the following values:
    642            *            @arg TIM1_OCPolarity_High: Output Compare active low
    643            *            @arg TIM1_OCPolarity_Low: Output Compare active high
    644            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare
    645            *          This parameter can be one of the following values:
    646            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
    647            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
    648            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    649            *          This parameter can be one of the following values:
    650            *            @arg TIM1_OCIdleState_Set: Output Compare Idle state set
    651            *            @arg TIM1_OCIdleState_Reset: Output Compare Idle state reset
    652            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle State
    653            *          This parameter can be one of the following values:
    654            *            @arg TIM1_OCNIdleState_Set: Complementary Output Compare Idle state set
    655            *            @arg TIM1_OCNIdleState_Reset: Complementary Output Compare Idle state reset
    656            * @retval None
    657            */
    658          void TIM1_OC2Init(TIM1_OCMode_T TIM1_OCMode,
    659                            TIM1_OutputState_T TIM1_OutputState,
    660                            TIM1_OutputNState_T TIM1_OutputNState,
    661                            uint16_t TIM1_Pulse,
    662                            TIM1_OCPolarity_T TIM1_OCPolarity,
    663                            TIM1_OCNPolarity_T TIM1_OCNPolarity,
    664                            TIM1_OCIdleState_T TIM1_OCIdleState,
    665                            TIM1_OCNIdleState_T TIM1_OCNIdleState)
    666          {
    667          
    668            /* Check the parameters */
    669            assert_param(IS_TIM1_OC_MODE(TIM1_OCMode));
    670            assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OutputState));
    671            assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OutputNState));
    672            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
    673            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
    674            assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCIdleState));
    675            assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCNIdleState));
    676          
    677            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State,
    678               the Output N State, the Output Polarity & the Output N Polarity*/
    679            TIM1->CCER1 &= (uint8_t)(~(TIM1_CCER1_CC2E | TIM1_CCER1_CC2NE | TIM1_CCER1_CC2P | TIM1_CCER1_CC2NP));
    680          
    681            /* Set the Output State & Set the Output N State & Set the Output Polarity & Set the Output N Polarity */
    682            TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC2E) | (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC2NE))
    683                                     | (uint8_t) ((uint8_t)(TIM1_OCPolarity & TIM1_CCER1_CC2P) | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC2NP)));
    684          
    685            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    686            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
    687          
    688            /* Reset the Output Idle state & the Output N Idle state bits */
    689            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS2 | TIM1_OISR_OIS2N));
    690            /* Set the Output Idle state & the Output N Idle state configuration */
    691            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS2 & TIM1_OCIdleState) | (uint8_t)(TIM1_OISR_OIS2N & TIM1_OCNIdleState));
    692          
    693            /* Set the Pulse value */
    694            TIM1->CCR2H = (uint8_t)(TIM1_Pulse >> 8);
    695            TIM1->CCR2L = (uint8_t)(TIM1_Pulse);
    696          }
    697          
    698          /**
    699            * @brief  Initializes the TIM1 Channel3 according to the specified parameters.
    700            * @param  TIM1_OCMode specifies the Output Compare mode
    701            *          This parameter can be one of the following values:
    702            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    703            *            @arg TIM1_OCMode_Active: OC Mode Active
    704            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    705            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    706            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    707            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2     
    708            * @param  TIM1_OutputState specifies the Output State
    709            *          This parameter can be one of the following values:
    710            *            @arg TIM1_OutputState_Disable: Output state disable
    711            *            @arg TIM1_OutputState_Enable: Output state enable
    712            * @param  TIM1_OutputNState specifies the Complementary Output State
    713            *          This parameter can be one of the following values:
    714            *            @arg TIM1_OutputNState_Disable: Output N state disable
    715            *            @arg TIM1_OutputNState_Enable: Output N state enable
    716            * @param  TIM1_Pulse specifies the Pulse width value.
    717            * @param  TIM1_OCPolarity specifies the Output Compare Polarity
    718            *          This parameter can be one of the following values:
    719            *            @arg TIM1_OCPolarity_High: Output Compare active low
    720            *            @arg TIM1_OCPolarity_Low: Output Compare active high
    721            * @param  TIM1_OCNPolarity specifies the Complementary Output Compare Polarity
    722            *          This parameter can be one of the following values:
    723            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
    724            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
    725            * @param  TIM1_OCIdleState specifies the Output Compare Idle State
    726            *          This parameter can be one of the following values:
    727            *            @arg TIM1_OCIdleState_Set: Output Compare Idle state set
    728            *            @arg TIM1_OCIdleState_Reset: Output Compare Idle state reset
    729            * @param  TIM1_OCNIdleState specifies the Complementary Output Compare Idle State
    730            *          This parameter can be one of the following values:
    731            *            @arg TIM1_OCNIdleState_Set: Complementary Output Compare Idle state set
    732            *            @arg TIM1_OCNIdleState_Reset: Complementary Output Compare Idle state reset
    733            * @retval None
    734            */
    735          void TIM1_OC3Init(TIM1_OCMode_T TIM1_OCMode,
    736                            TIM1_OutputState_T TIM1_OutputState,
    737                            TIM1_OutputNState_T TIM1_OutputNState,
    738                            uint16_t TIM1_Pulse,
    739                            TIM1_OCPolarity_T TIM1_OCPolarity,
    740                            TIM1_OCNPolarity_T TIM1_OCNPolarity,
    741                            TIM1_OCIdleState_T TIM1_OCIdleState,
    742                            TIM1_OCNIdleState_T TIM1_OCNIdleState)
    743          {
    744          
    745            /* Check the parameters */
    746            assert_param(IS_TIM1_OC_MODE(TIM1_OCMode));
    747            assert_param(IS_TIM1_OUTPUT_STATE(TIM1_OutputState));
    748            assert_param(IS_TIM1_OUTPUTN_STATE(TIM1_OutputNState));
    749            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
    750            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
    751            assert_param(IS_TIM1_OCIDLE_STATE(TIM1_OCIdleState));
    752            assert_param(IS_TIM1_OCNIDLE_STATE(TIM1_OCNIdleState));
    753          
    754            /* Disable the Channel 1: Reset the CCE Bit, Set the Output State,
    755               the Output N State, the Output Polarity & the Output N Polarity */
    756            TIM1->CCER2 &= (uint8_t)(~( TIM1_CCER2_CC3E | TIM1_CCER2_CC3NE | TIM1_CCER2_CC3P | TIM1_CCER2_CC3NP));
    757          
    758            /* Set the Output State & Set the Output N State & Set the Output Polarity & Set the Output N Polarity */
    759            TIM1->CCER2 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER2_CC3E) | (uint8_t)(TIM1_OutputNState & TIM1_CCER2_CC3NE))
    760                                     | (uint8_t)((uint8_t)(TIM1_OCPolarity & TIM1_CCER2_CC3P) | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER2_CC3NP)));
    761          
    762            /* Reset the Output Compare Bits & Set the Output Compare Mode */
    763            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
    764          
    765            /* Reset the Output Idle state & the Output N Idle state bits */
    766            TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS3 | TIM1_OISR_OIS3N));
    767            /* Set the Output Idle state & the Output N Idle state configuration */
    768            TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS3 & TIM1_OCIdleState) | (uint8_t) (TIM1_OISR_OIS3N & TIM1_OCNIdleState));
    769          
    770            /* Set the Pulse value */
    771            TIM1->CCR3H = (uint8_t)(TIM1_Pulse >> 8);
    772            TIM1->CCR3L = (uint8_t)(TIM1_Pulse);
    773          }
    774          
    775          /**
    776            * @brief  Configures the Break feature, dead time, Lock level, the OSSI,
    777            *         and the AOE(automatic output enable).
    778            * @param  TIM1_OSSIState specifies the OSSIS State
    779            *          This parameter can be one of the following values:
    780            *            @arg TIM1_OSSIState_Enable: OSSIS State enabled
    781            *            @arg TIM1_OSSIState_Disable: OSSIS State disabled   
    782            * @param  TIM1_LockLevel specifies the lock level
    783            *          This parameter can be one of the following values:
    784            *            @arg TIM1_LockLevel_Off: No lock level
    785            *            @arg TIM1_LockLevel_1: Lock level 1  
    786            *            @arg TIM1_LockLevel_2: Lock level 2
    787            *            @arg TIM1_LockLevel_3: Lock level 3
    788            * @param  TIM1_DeadTime specifies the dead time value.
    789            * @param  TIM1_Break specifies the Break state
    790            *          This parameter can be one of the following values:
    791            *            @arg TIM1_BreakState_Enable: Break enabled
    792            *            @arg TIM1_BreakState_Disable: Break disabled  
    793            * @param  TIM1_BreakPolarity specifies the Break polarity
    794            *          This parameter can be one of the following values:
    795            *            @arg TIM1_BreakPolarity_Low: Break polarity high
    796            *            @arg TIM1_BreakPolarity_High: Break polarity low
    797            * @param  TIM1_AutomaticOutput specifies the Automatic Output configuration
    798            *          This parameter can be one of the following values:
    799            *            @arg TIM1_AutomaticOutput_Enable: Automatic Output enabled
    800            *            @arg TIM1_AutomaticOutput_Disable: Automatic Output disabled  
    801            * @retval None
    802            */
    803          void TIM1_BDTRConfig(TIM1_OSSIState_T TIM1_OSSIState,
    804                               TIM1_LockLevel_T TIM1_LockLevel,
    805                               uint8_t TIM1_DeadTime,
    806                               TIM1_BreakState_T TIM1_Break,
    807                               TIM1_BreakPolarity_T TIM1_BreakPolarity,
    808                               TIM1_AutomaticOutput_T TIM1_AutomaticOutput)
    809          {
    810          
    811            /* Check the parameters */
    812            assert_param(IS_TIM1_OSSI_STATE(TIM1_OSSIState));
    813            assert_param(IS_TIM1_LOCK_LEVEL(TIM1_LockLevel));
    814            assert_param(IS_TIM1_BREAK_STATE(TIM1_Break));
    815            assert_param(IS_TIM1_BREAK_POLARITY(TIM1_BreakPolarity));
    816            assert_param(IS_TIM1_AUTOMATIC_OUTPUT_STATE(TIM1_AutomaticOutput));
    817          
    818            TIM1->DTR = (uint8_t)(TIM1_DeadTime);
    819            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSI State,
    820               the dead time value  and the Automatic Output Enable Bit */
    821          
    822            TIM1->BKR  =  (uint8_t)((uint8_t)((uint8_t)TIM1_OSSIState | (uint8_t)TIM1_LockLevel)
    823                                    | (uint8_t)((uint8_t)((uint8_t)TIM1_Break | (uint8_t)TIM1_BreakPolarity)
    824                                                | (uint8_t)TIM1_AutomaticOutput));
    825          
    826          }
    827          
    828          /**
    829            * @brief  Enables or disables the TIM1 peripheral Main Outputs.
    830            * @param  NewState new state of the TIM1 peripheral. 
    831            *          This parameter can be ENABLE or DISABLE.
    832            * @retval None
    833            */
    834          void TIM1_CtrlPWMOutputs(FunctionalState NewState)
    835          {
    836            /* Check the parameters */
    837            assert_param(IS_FUNCTIONAL_STATE(NewState));
    838          
    839            /* Set or Reset the MOE Bit */
    840          
    841            if (NewState != DISABLE)
    842            {
    843              TIM1->BKR |= TIM1_BKR_MOE;
    844            }
    845            else
    846            {
    847              TIM1->BKR &= (uint8_t)(~TIM1_BKR_MOE);
    848            }
    849          }
    850          
    851          /**
    852            * @brief  Selects the TIM1 Output Compare Mode. This function disables the
    853            *         selected channel before changing the Output Compare Mode. 
    854            * @note   User has to enable this channel using TIM1_CCxCmd and TIM1_CCxNCmd functions.
    855            * @param  TIM1_Channel specifies the TIM1 Channel.
    856            *          This parameter can be one of the following values:
    857            *            @arg TIM1_Channel_1: TIM1 Channel1
    858            *            @arg TIM1_Channel_2: TIM1 Channel2
    859            *            @arg TIM1_Channel_3: TIM1 Channel3
    860            *            @arg TIM1_Channel_4: TIM1 Channel4
    861            * @param  TIM1_OCMode specifies the TIM1 Output Compare Mode.
    862            *          This parameter can be one of the following values:
    863            *            @arg TIM1_OCMode_Timing: OC Mode Timing
    864            *            @arg TIM1_OCMode_Active: OC Mode Active
    865            *            @arg TIM1_OCMode_Inactive: OC Mode Inactive
    866            *            @arg TIM1_OCMode_Toggle: OC Mode Toggle
    867            *            @arg TIM1_OCMode_PWM1: OC Mode PWM1
    868            *            @arg TIM1_OCMode_PWM2: OC Mode PWM2  
    869            * @retval None
    870            */
    871          void TIM1_SelectOCxM(TIM1_Channel_T TIM1_Channel, TIM1_OCMode_T TIM1_OCMode)
    872          {
    873            /* Check the parameters */
    874            assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
    875            assert_param(IS_TIM1_OCM(TIM1_OCMode));
    876          
    877            if (TIM1_Channel == TIM1_Channel_1)
    878            {
    879              /* Disable the Channel 1: Reset the CCE Bit */
    880              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
    881          
    882              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    883              TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
    884            }
    885            else if (TIM1_Channel == TIM1_Channel_2)
    886            {
    887              /* Disable the Channel 2: Reset the CCE Bit */
    888              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
    889          
    890              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    891              TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
    892            }
    893            else
    894            {
    895              /* Disable the Channel 3: Reset the CCE Bit */
    896              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
    897          
    898              /* Reset the Output Compare Bits & Set the Output Compare Mode */
    899              TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_OCMode);
    900          
    901            }
    902          }
    903          
    904          /**
    905            * @brief  Sets the TIM1 Capture Compare1 Register value.
    906            * @param  Compare1 specifies the Capture Compare1 register new value.
    907            *          This parameter is between 0x0000 and 0xFFFF.
    908            * @retval None
    909            */
    910          void TIM1_SetCompare1(uint16_t Compare1)
    911          {
    912            /* Set the Capture Compare1 Register value */
    913            TIM1->CCR1H = (uint8_t)(Compare1 >> 8);
    914            TIM1->CCR1L = (uint8_t)(Compare1);
    915          
    916          }
    917          
    918          /**
    919            * @brief  Sets the TIM1 Capture Compare2 Register value.
    920            * @param  Compare2 specifies the Capture Compare2 register new value.
    921            *          This parameter is between 0x0000 and 0xFFFF.
    922            * @retval None
    923            */
    924          void TIM1_SetCompare2(uint16_t Compare2)
    925          {
    926            /* Set the Capture Compare2 Register value */
    927            TIM1->CCR2H = (uint8_t)(Compare2 >> 8);
    928            TIM1->CCR2L = (uint8_t)(Compare2);
    929          }
    930          
    931          /**
    932            * @brief  Sets the TIM1 Capture Compare3 Register value.
    933            * @param  Compare3 specifies the Capture Compare3 register new value.
    934            *          This parameter is between 0x0000 and 0xFFFF.
    935            * @retval None
    936            */
    937          void TIM1_SetCompare3(uint16_t Compare3)
    938          {
    939            /* Set the Capture Compare3 Register value */
    940            TIM1->CCR3H = (uint8_t)(Compare3 >> 8);
    941            TIM1->CCR3L = (uint8_t)(Compare3);
    942          }
    943          
    944          /**
    945            * @brief  Sets the TIM1 Capture Compare4 Register value.
    946            * @param  Compare4 specifies the Capture Compare4 register new value.
    947            *          This parameter is between 0x0000 and 0xFFFF.
    948            * @retval None
    949            */
    950          void TIM1_SetCompare4(uint16_t Compare4)
    951          {
    952            /* Set the Capture Compare4 Register value */
    953            TIM1->CCR4H = (uint8_t)(Compare4 >> 8);
    954            TIM1->CCR4L = (uint8_t)(Compare4);
    955          }
    956          
    957          /**
    958            * @brief  Sets or Resets the TIM1 peripheral Capture Compare Preload Control bit.
    959            * @param  NewState new state of the Capture Compare Preload Control bit.
    960            *          This parameter can be ENABLE or DISABLE.
    961            * @retval None
    962            */
    963          void TIM1_CCPreloadControl(FunctionalState NewState)
    964          {
    965            /* Check the parameters */
    966            assert_param(IS_FUNCTIONAL_STATE(NewState));
    967          
    968            /* Set or Reset the CCPC Bit */
    969            if (NewState != DISABLE)
    970            {
    971              TIM1->CR2 |= TIM1_CR2_CCPC;
    972            }
    973            else
    974            {
    975              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCPC);
    976            }
    977          }
    978          
    979          /**
    980            * @brief  Forces the TIM1 Channel1 output waveform to active or inactive level.
    981            * @param  TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
    982            *          This parameter can be one of the following values:
    983            *            @arg TIM1_ForcedAction_Active: Force active level on OC1REF
    984            *            @arg TIM1_ForcedAction_Inactive: Force inactive level on OC1REF.
    985            * @retval None
    986            */
    987          void TIM1_ForcedOC1Config(TIM1_ForcedAction_T TIM1_ForcedAction)
    988          {
    989            /* Check the parameters */
    990            assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
    991          
    992            /* Reset the OCM Bits & Configure the Forced output Mode */
    993            TIM1->CCMR1 =  (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_ForcedAction);
    994          }
    995          
    996          /**
    997            * @brief  Forces the TIM1 Channel2 output waveform to active or inactive level.
    998            * @param  TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
    999            *          This parameter can be one of the following values:
   1000            *            @arg TIM1_ForcedAction_Active: Force active level on OC2REF
   1001            *            @arg TIM1_ForcedAction_Inactive: Force inactive level on OC2REF.
   1002            * @retval None
   1003            */
   1004          void TIM1_ForcedOC2Config(TIM1_ForcedAction_T TIM1_ForcedAction)
   1005          {
   1006            /* Check the parameters */
   1007            assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
   1008          
   1009            /* Reset the OCM Bits & Configure the Forced output Mode */
   1010            TIM1->CCMR2  =  (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_ForcedAction);
   1011          }
   1012          
   1013          /**
   1014            * @brief  Forces the TIM1 Channel3 output waveform to active or inactive level.
   1015            * @param  TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
   1016            *          This parameter can be one of the following values:
   1017            *            @arg TIM1_ForcedAction_Active: Force active level on OC3REF
   1018            *            @arg TIM1_ForcedAction_Inactive: Force inactive level on OC3REF.
   1019            * @retval None
   1020            */
   1021          void TIM1_ForcedOC3Config(TIM1_ForcedAction_T TIM1_ForcedAction)
   1022          {
   1023            /* Check the parameters */
   1024            assert_param(IS_TIM1_FORCED_ACTION(TIM1_ForcedAction));
   1025          
   1026            /* Reset the OCM Bits */ /* Configure The Forced output Mode */
   1027            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_OCM)) | (uint8_t)TIM1_ForcedAction);
   1028          }
   1029          
   1030          /**
   1031            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR1.
   1032            * @param  NewState new state of the Capture Compare Preload register.
   1033            *          This parameter can be ENABLE or DISABLE.
   1034            * @retval None
   1035            */
   1036          void TIM1_OC1PreloadConfig(FunctionalState NewState)
   1037          {
   1038            /* Check the parameters */
   1039            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1040          
   1041            /* Set or Reset the OC1PE Bit */
   1042            if (NewState != DISABLE)
   1043            {
   1044              TIM1->CCMR1 |= TIM1_CCMR_OCxPE;
   1045            }
   1046            else
   1047            {
   1048              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   1049            }
   1050          }
   1051          
   1052          /**
   1053            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR2.
   1054            * @param  NewState new state of the Capture Compare Preload register.
   1055            *          This parameter can be ENABLE or DISABLE.
   1056            * @retval None
   1057            */
   1058          void TIM1_OC2PreloadConfig(FunctionalState NewState)
   1059          {
   1060            /* Check the parameters */
   1061            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1062          
   1063            /* Set or Reset the OC2PE Bit */
   1064            if (NewState != DISABLE)
   1065            {
   1066              TIM1->CCMR2 |= TIM1_CCMR_OCxPE;
   1067            }
   1068            else
   1069            {
   1070              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   1071            }
   1072          }
   1073          
   1074          /**
   1075            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR3.
   1076            * @param  NewState new state of the Capture Compare Preload register.
   1077            *          This parameter can be ENABLE or DISABLE.
   1078            * @retval None
   1079            */
   1080          void TIM1_OC3PreloadConfig(FunctionalState NewState)
   1081          {
   1082            /* Check the parameters */
   1083            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1084          
   1085            /* Set or Reset the OC3PE Bit */
   1086            if (NewState != DISABLE)
   1087            {
   1088              TIM1->CCMR3 |= TIM1_CCMR_OCxPE;
   1089            }
   1090            else
   1091            {
   1092              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   1093            }
   1094          }
   1095          
   1096          /**
   1097            * @brief  Enables or disables the TIM1 peripheral Preload Register on CCR4.
   1098            * @param  NewState new state of the Capture Compare Preload register.
   1099            *          This parameter can be ENABLE or DISABLE.
   1100            * @retval None
   1101            */
   1102          void TIM1_OC4PreloadConfig(FunctionalState NewState)
   1103          {
   1104            /* Check the parameters */
   1105            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1106          
   1107            /* Set or Reset the OC4PE Bit */
   1108            if (NewState != DISABLE)
   1109            {
   1110              TIM1->CCMR4 |= TIM1_CCMR_OCxPE;
   1111            }
   1112            else
   1113            {
   1114              TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxPE);
   1115            }
   1116          }
   1117          
   1118          /**
   1119            * @brief  Configures the TIM1 Capture Compare 1 Fast feature.
   1120            * @param  NewState new state of the Output Compare Fast Enable bit.
   1121            *          This parameter can be ENABLE or DISABLE.
   1122            * @retval None
   1123            */
   1124          void TIM1_OC1FastConfig(FunctionalState NewState)
   1125          {
   1126            /* Check the parameters */
   1127            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1128          
   1129            /* Set or Reset the OC1FE Bit */
   1130            if (NewState != DISABLE)
   1131            {
   1132              TIM1->CCMR1 |= TIM1_CCMR_OCxFE;
   1133            }
   1134            else
   1135            {
   1136              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   1137            }
   1138          }
   1139          
   1140          /**
   1141            * @brief  Configures the TIM1 Capture Compare 2 Fast feature.
   1142            * @param  NewState new state of the Output Compare Fast Enable bit.
   1143            *          This parameter can be ENABLE or DISABLE.
   1144            * @retval None
   1145            */
   1146          void TIM1_OC2FastConfig(FunctionalState NewState)
   1147          {
   1148            /* Check the parameters */
   1149            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1150          
   1151            /* Set or Reset the OC2FE Bit */
   1152            if (NewState != DISABLE)
   1153            {
   1154              TIM1->CCMR2 |= TIM1_CCMR_OCxFE;
   1155            }
   1156            else
   1157            {
   1158              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   1159            }
   1160          }
   1161          
   1162          /**
   1163            * @brief  Configures the TIM1 Capture Compare 3 Fast feature.
   1164            * @param  NewState new state of the Output Compare Fast Enable bit.
   1165            *          This parameter can be ENABLE or DISABLE.
   1166            * @retval None
   1167            */
   1168          void TIM1_OC3FastConfig(FunctionalState NewState)
   1169          {
   1170            /* Check the parameters */
   1171            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1172          
   1173            /* Set or Reset the OC3FE Bit */
   1174            if (NewState != DISABLE)
   1175            {
   1176              TIM1->CCMR3 |= TIM1_CCMR_OCxFE;
   1177            }
   1178            else
   1179            {
   1180              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxFE);
   1181            }
   1182          }
   1183          
   1184          /**
   1185            * @brief   Clears or safeguards the OC1REF signal.
   1186            * @param  NewState new state of the Output Compare 1 Clear Enable bit.
   1187            *          This parameter can be ENABLE or DISABLE.
   1188            * @retval None
   1189            */
   1190          void TIM1_ClearOC1Ref(FunctionalState NewState)
   1191          {
   1192            /* Check the parameters */
   1193            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1194          
   1195            /* Set or Reset the OC1CE Bit */
   1196            if (NewState != DISABLE)
   1197            {
   1198              TIM1->CCMR1 |= TIM1_CCMR_OCxCE;
   1199            }
   1200            else
   1201            {
   1202              TIM1->CCMR1 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   1203            }
   1204          }
   1205          
   1206          /**
   1207            * @brief  Clears or safeguards the OC2REF signal.
   1208            * @param  NewState new state of the Output Compare 2 Clear Enable bit.
   1209            *          This parameter can be ENABLE or DISABLE.
   1210            * @retval None
   1211            */
   1212          void TIM1_ClearOC2Ref(FunctionalState NewState)
   1213          {
   1214            /* Check the parameters */
   1215            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1216          
   1217            /* Set or Reset the OC2CE Bit */
   1218            if (NewState != DISABLE)
   1219            {
   1220              TIM1->CCMR2 |= TIM1_CCMR_OCxCE;
   1221            }
   1222            else
   1223            {
   1224              TIM1->CCMR2 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   1225            }
   1226          }
   1227          
   1228          /**
   1229            * @brief  Clears or safeguards the OC3REF signal.
   1230            * @param  NewState new state of the Output Compare 3 Clear Enable bit.
   1231            *          This parameter can be ENABLE or DISABLE.
   1232            * @retval None
   1233            */
   1234          void TIM1_ClearOC3Ref(FunctionalState NewState)
   1235          {
   1236            /* Check the parameters */
   1237            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1238          
   1239            /* Set or Reset the OC3CE Bit */
   1240            if (NewState != DISABLE)
   1241            {
   1242              TIM1->CCMR3 |= TIM1_CCMR_OCxCE;
   1243            }
   1244            else
   1245            {
   1246              TIM1->CCMR3 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   1247            }
   1248          }
   1249          
   1250          /**
   1251            * @brief  Clears or safeguards the OC4REF signal.
   1252            * @param  NewState new state of the Output Compare 4 Clear Enable bit.
   1253            *          This parameter can be ENABLE or DISABLE.
   1254            * @retval None
   1255            */
   1256          void TIM1_ClearOC4Ref(FunctionalState NewState)
   1257          {
   1258            /* Check the parameters */
   1259            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1260          
   1261            /* Set or Reset the OC4CE Bit */
   1262            if (NewState != DISABLE)
   1263            {
   1264              TIM1->CCMR4 |= TIM1_CCMR_OCxCE;
   1265            }
   1266            else
   1267            {
   1268              TIM1->CCMR4 &= (uint8_t)(~TIM1_CCMR_OCxCE);
   1269            }
   1270          }
   1271          
   1272          /**
   1273            * @brief  Configures the TIM1 Channel 1 polarity.
   1274            * @param  TIM1_OCPolarity specifies the OC1 Polarity.
   1275            *          This parameter can be one of the following values:
   1276            *            @arg TIM1_OCPolarity_High: Output Compare active low
   1277            *            @arg TIM1_OCPolarity_Low: Output Compare active high
   1278            * @retval None
   1279            */
   1280          void TIM1_OC1PolarityConfig(TIM1_OCPolarity_T TIM1_OCPolarity)
   1281          {
   1282            /* Check the parameters */
   1283            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
   1284          
   1285            /* Set or Reset the CC1P Bit */
   1286            if (TIM1_OCPolarity != TIM1_OCPolarity_High)
   1287            {
   1288              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   1289            }
   1290            else
   1291            {
   1292              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   1293            }
   1294          }
   1295          
   1296          /**
   1297            * @brief  Configures the TIM1 Channel 1N polarity.
   1298            * @param  TIM1_OCNPolarity specifies the OC1N Polarity.
   1299            *          This parameter can be one of the following values:
   1300            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
   1301            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
   1302            * @retval None
   1303            */
   1304          void TIM1_OC1NPolarityConfig(TIM1_OCNPolarity_T TIM1_OCNPolarity)
   1305          {
   1306            /* Check the parameters */
   1307            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
   1308          
   1309            /* Set or Reset the CC3P Bit */
   1310            if (TIM1_OCNPolarity != TIM1_OCNPolarity_High)
   1311            {
   1312              TIM1->CCER1 |= TIM1_CCER1_CC1NP;
   1313            }
   1314            else
   1315            {
   1316              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NP);
   1317            }
   1318          }
   1319          
   1320          /**
   1321            * @brief  Configures the TIM1 Channel 2 polarity.
   1322            * @param  TIM1_OCPolarity specifies the OC2 Polarity.
   1323            *          This parameter can be one of the following values:
   1324            *            @arg TIM1_OCPolarity_High: Output Compare active low
   1325            *            @arg TIM1_OCPolarity_Low: Output Compare active high
   1326            * @retval None
   1327            */
   1328          void TIM1_OC2PolarityConfig(TIM1_OCPolarity_T TIM1_OCPolarity)
   1329          {
   1330            /* Check the parameters */
   1331            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
   1332          
   1333            /* Set or Reset the CC2P Bit */
   1334            if (TIM1_OCPolarity != TIM1_OCPolarity_High)
   1335            {
   1336              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   1337            }
   1338            else
   1339            {
   1340              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   1341            }
   1342          }
   1343          
   1344          /**
   1345            * @brief  Configures the TIM1 Channel 2N polarity.
   1346            * @param  TIM1_OCNPolarity specifies the OC2N Polarity.
   1347            *          This parameter can be one of the following values:
   1348            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
   1349            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
   1350            * @retval None
   1351            */
   1352          void TIM1_OC2NPolarityConfig(TIM1_OCNPolarity_T TIM1_OCNPolarity)
   1353          {
   1354            /* Check the parameters */
   1355            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
   1356          
   1357            /* Set or Reset the CC3P Bit */
   1358            if (TIM1_OCNPolarity != TIM1_OCNPolarity_High)
   1359            {
   1360              TIM1->CCER1 |= TIM1_CCER1_CC2NP;
   1361            }
   1362            else
   1363            {
   1364              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NP);
   1365            }
   1366          }
   1367          
   1368          /**
   1369            * @brief  Configures the TIM1 Channel 3 polarity.
   1370            * @param  TIM1_OCPolarity specifies the OC3 Polarity.
   1371            *          This parameter can be one of the following values:
   1372            *            @arg TIM1_OCPolarity_High: Output Compare active low
   1373            *            @arg TIM1_OCPolarity_Low: Output Compare active high
   1374            * @retval None
   1375            */
   1376          void TIM1_OC3PolarityConfig(TIM1_OCPolarity_T TIM1_OCPolarity)
   1377          {
   1378            /* Check the parameters */
   1379            assert_param(IS_TIM1_OC_POLARITY(TIM1_OCPolarity));
   1380          
   1381            /* Set or Reset the CC3P Bit */
   1382            if (TIM1_OCPolarity != TIM1_OCPolarity_High)
   1383            {
   1384              TIM1->CCER2 |= TIM1_CCER2_CC3P;
   1385            }
   1386            else
   1387            {
   1388              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   1389            }
   1390          }
   1391          
   1392          /**
   1393            * @brief  Configures the TIM1 Channel 3N polarity.
   1394            * @param  TIM1_OCNPolarity specifies the OC3N Polarity.
   1395            *          This parameter can be one of the following values:
   1396            *            @arg TIM1_OCNPolarity_High: Complementary Output Compare active low
   1397            *            @arg TIM1_OCNPolarity_Low: Complementary Output Compare active high
   1398            * @retval None
   1399            */
   1400          void TIM1_OC3NPolarityConfig(TIM1_OCNPolarity_T TIM1_OCNPolarity)
   1401          {
   1402            /* Check the parameters */
   1403            assert_param(IS_TIM1_OCN_POLARITY(TIM1_OCNPolarity));
   1404          
   1405            /* Set or Reset the CC3P Bit */
   1406            if (TIM1_OCNPolarity != TIM1_OCNPolarity_High)
   1407            {
   1408              TIM1->CCER2 |= TIM1_CCER2_CC3NP;
   1409            }
   1410            else
   1411            {
   1412              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NP);
   1413            }
   1414          }
   1415          
   1416          /**
   1417            * @brief  Selects the OCReference Clear source.
   1418            * @param  TIM1_OCReferenceClear: specifies the OCReference Clear source.
   1419            *          This parameter can be one of the following values:
   1420            *            @arg TIM1_OCReferenceClear_ETRF: OCReference Clear source ETR
   1421            *            @arg TIM1_OCReferenceClear_OCREFCLR: OCReference Clear source OCREF 
   1422            * @retval None
   1423            */
   1424          void TIM1_SelectOCREFClear(TIM1_OCReferenceClear_T TIM1_OCReferenceClear)
   1425          {
   1426            /* Check the parameters */
   1427            assert_param(IS_TIM1_OCREFERENCECECLEAR_SOURCE(TIM1_OCReferenceClear));
   1428          
   1429            /* Set the TIM1_OCReferenceClear source */
   1430            TIM1->SMCR &=  (uint8_t) (~TIM1_SMCR_OCCS);
   1431            TIM1->SMCR |=  (uint8_t) TIM1_OCReferenceClear;
   1432          }
   1433          
   1434          /**
   1435            * @brief  Selects the TIM1 peripheral Commutation event.
   1436            * @param  NewState new state of the Commutation event.
   1437            *          This parameter can be ENABLE or DISABLE.
   1438            * @retval None
   1439            */
   1440          void TIM1_SelectCOM(FunctionalState NewState)
   1441          {
   1442            /* Check the parameters */
   1443            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1444          
   1445            /* Set or Reset the CCUS Bit */
   1446            if (NewState != DISABLE)
   1447            {
   1448              TIM1->CR2 |= TIM1_CR2_CCUS;
   1449            }
   1450            else
   1451            {
   1452              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCUS);
   1453            }
   1454          }
   1455          
   1456          /**
   1457            * @brief  Enables or disables the TIM1 Capture Compare Channel x (x=1,..,4).
   1458            * @param  TIM1_Channel specifies the TIM1 Channel.
   1459            *          This parameter can be one of the following values:
   1460            *            @arg TIM1_Channel_1: TIM1 Channel1
   1461            *            @arg TIM1_Channel_2: TIM1 Channel2
   1462            *            @arg TIM1_Channel_3: TIM1 Channel3
   1463            *            @arg TIM1_CHANNEL_4: TIM1 Channel4
   1464            * @param  NewState specifies the TIM1 Channel CCxE bit new state.
   1465            *          This parameter can be: ENABLE or DISABLE.
   1466            * @retval None
   1467            */
   1468          void TIM1_CCxCmd(TIM1_Channel_T TIM1_Channel, FunctionalState NewState)
   1469          {
   1470            /* Check the parameters */
   1471            assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
   1472            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1473          
   1474            if (TIM1_Channel == TIM1_Channel_1)
   1475            {
   1476              /* Set or Reset the CC1E Bit */
   1477              if (NewState != DISABLE)
   1478              {
   1479                TIM1->CCER1 |= TIM1_CCER1_CC1E;
   1480              }
   1481              else
   1482              {
   1483                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   1484              }
   1485            }
   1486            else if (TIM1_Channel == TIM1_Channel_2)
   1487            {
   1488              /* Set or Reset the CC2E Bit */
   1489              if (NewState != DISABLE)
   1490              {
   1491                TIM1->CCER1 |= TIM1_CCER1_CC2E;
   1492              }
   1493              else
   1494              {
   1495                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2E);
   1496              }
   1497            }
   1498            else if (TIM1_Channel == TIM1_Channel_3)
   1499            {
   1500              /* Set or Reset the CC3E Bit */
   1501              if (NewState != DISABLE)
   1502              {
   1503                TIM1->CCER2 |= TIM1_CCER2_CC3E;
   1504              }
   1505              else
   1506              {
   1507                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3E);
   1508              }
   1509            }
   1510            else
   1511            {
   1512              /* Set or Reset the CC4E Bit */
   1513              if (NewState != DISABLE)
   1514              {
   1515                TIM1->CCER2 |= TIM1_CCER2_CC4E;
   1516              }
   1517              else
   1518              {
   1519                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4E);
   1520              }
   1521            }
   1522          }
   1523          
   1524          /**
   1525            * @brief  Enables or disables the TIM1 Capture Compare Channel xN (xN=1,..,3).
   1526            * @param  TIM1_Channel specifies the TIM1 Channel.
   1527            *          This parameter can be one of the following values:
   1528            *            @arg TIM1_Channel_1: TIM1 Channel1
   1529            *            @arg TIM1_Channel_2: TIM1 Channel2
   1530            *            @arg TIM1_Channel_3: TIM1 Channel3
   1531            * @param  NewState specifies the TIM1 Channel CCxNE bit new state.
   1532            *          This parameter can be: ENABLE or DISABLE.
   1533            * @retval None
   1534            */
   1535          void TIM1_CCxNCmd(TIM1_Channel_T TIM1_Channel, FunctionalState NewState)
   1536          {
   1537            /* Check the parameters */
   1538            assert_param(IS_TIM1_COMPLEMENTARY_CHANNEL(TIM1_Channel));
   1539            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1540          
   1541            if (TIM1_Channel == TIM1_Channel_1)
   1542            {
   1543              /* Set or Reset the CC1NE Bit */
   1544              if (NewState != DISABLE)
   1545              {
   1546                TIM1->CCER1 |= TIM1_CCER1_CC1NE;
   1547              }
   1548              else
   1549              {
   1550                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1NE);
   1551              }
   1552            }
   1553            else if (TIM1_Channel == TIM1_Channel_2)
   1554            {
   1555              /* Set or Reset the CC2NE Bit */
   1556              if (NewState != DISABLE)
   1557              {
   1558                TIM1->CCER1 |= TIM1_CCER1_CC2NE;
   1559              }
   1560              else
   1561              {
   1562                TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2NE);
   1563              }
   1564            }
   1565            else
   1566            {
   1567              /* Set or Reset the CC3NE Bit */
   1568              if (NewState != DISABLE)
   1569              {
   1570                TIM1->CCER2 |= TIM1_CCER2_CC3NE;
   1571              }
   1572              else
   1573              {
   1574                TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3NE);
   1575              }
   1576            }
   1577          }
   1578          
   1579          /**
   1580            * @}
   1581            */
   1582          
   1583          /** @defgroup TIM1_Group3 Input Capture management functions
   1584           *  @brief    Input Capture management functions 
   1585           *
   1586          @verbatim   
   1587           ===============================================================================
   1588                                Input Capture management functions
   1589           ===============================================================================  
   1590             
   1591                 ===================================================================      
   1592                        TIM1 Driver: how to use it in Input Capture Mode
   1593                 =================================================================== 
   1594                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1595                 
   1596                 1. Enable TIM1 clock using CLK_PeripheralClockConfig(CLK_Peripheral_TIM1, ENABLE) function.
   1597                 
   1598                 2. Configure the TIM1 pins in input mode by configuring the corresponding GPIO pins
   1599                 
   1600                 3. Configure the Time base unit as described in the first part of this driver, if needed,
   1601                    otherwise the Timer will run with the default configuration:
   1602                    - Autoreload value = 0xFFFF
   1603                    - Prescaler value = 0x0000
   1604                    - Counter mode = Up counting
   1605                 
   1606                 4. Call TIM1_ICInit() to configure the desired channel to measure only 
   1607                    frequency or duty cycle of the input signal using the corresponding configuration: 
   1608                    - TIM1 Channel: TIM1_Channel
   1609                    - TIM1 Input Capture polarity: TIM1_ICPolarity
   1610                    - TIM1 Input Capture selection: TIM1_ICSelection
   1611                    - TIM1 Input Capture Prescaler: TIM1_ICPSC
   1612                    - TIM1 Input Capture filter value
   1613                    or,
   1614                    Call TIM1_PWMIConfig() to configure the desired channels with the 
   1615                    corresponding configuration and to measure the frequency and the duty
   1616                    cycle of the input signal.
   1617                    
   1618                 5. Enable global interrupts or the DMA to read the measured frequency. 
   1619                    
   1620                 6. Enable the corresponding interrupt (or DMA request) to read the captured value,
   1621                    using the function TIM1_ITConfig(TIM1_IT_CCx) (or TIM1_DMACmd(TIM1_DMASource_CCx))
   1622                 
   1623                 7. Call the TIM1_Cmd(ENABLE) function to enable the TIM1 counter.
   1624                 
   1625                 8. Use TIM1_GetCapturex() to read the captured value corresponding to
   1626                    channel x.
   1627                 
   1628                 Note1: All other functions can be used separately to modify, if needed,
   1629                    a specific feature of the Timer. 
   1630          
   1631          @endverbatim
   1632            * @{
   1633            */
   1634          
   1635          /**
   1636            * @brief  Initializes the TIM1 peripheral according to the specified parameters.
   1637            * @param  TIM1_Channel specifies the input capture channel
   1638            *          This parameter can be one of the following values:
   1639            *            @arg TIM1_Channel_1: TIM1 Channel1
   1640            *            @arg TIM1_Channel_2: TIM1 Channel2
   1641            *            @arg TIM1_Channel_3: TIM1 Channel3
   1642            *            @arg TIM1_Channel_4: TIM1 Channel4
   1643            * @param  TIM1_ICPolarity specifies the Input capture polarity
   1644            *          This parameter can be one of the following values:
   1645            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   1646            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   1647            * @param  TIM1_ICSelection specifies the Input capture source selection
   1648            *          This parameter can be one of the following values:
   1649            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input x is selected to be connected to ICx.
   1650            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input x is selected to be connected to ICy.
   1651            *            @arg TIM1_ICSelection_TRGI: TIM1 Input x is selected to be connected to the TRGI   
   1652            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler
   1653            *          This parameter can be one of the following values:
   1654            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1655            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1656            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1657            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1658            * @param  TIM1_ICFilter specifies the Input capture filter value.
   1659            * @note   If the channel 3 is selected the TIM1_ICSelection_IndirectTI parameter is forbidden.
   1660            * @note   If the channel 4 is selected the TIM1_ICSelection_DirectTI parameter is forbidden.
   1661            * @retval None
   1662            */
   1663          
   1664          void TIM1_ICInit(TIM1_Channel_T TIM1_Channel,
   1665                           TIM1_ICPolarity_T TIM1_ICPolarity,
   1666                           TIM1_ICSelection_T TIM1_ICSelection,
   1667                           TIM1_ICPSC_T TIM1_ICPrescaler,
   1668                           uint8_t TIM1_ICFilter)
   1669          {
   1670          
   1671            /* Check the parameters */
   1672            assert_param(IS_TIM1_CHANNEL(TIM1_Channel));
   1673            assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
   1674            assert_param(IS_TIM1_IC_SELECTION(TIM1_ICSelection));
   1675            assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICPrescaler));
   1676            assert_param(IS_TIM1_IC_FILTER(TIM1_ICFilter));
   1677          
   1678            if (TIM1_Channel == TIM1_Channel_1)
   1679            {
   1680              /* TI1 Configuration */
   1681              TI1_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   1682              /* Set the Input Capture Prescaler value */
   1683              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   1684            }
   1685            else if (TIM1_Channel == TIM1_Channel_2)
   1686            {
   1687              /* TI2 Configuration */
   1688              TI2_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   1689              /* Set the Input Capture Prescaler value */
   1690              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   1691            }
   1692            else if (TIM1_Channel == TIM1_Channel_3)
   1693            {
   1694              /* TI3 Configuration */
   1695              TI3_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   1696              /* Set the Input Capture Prescaler value */
   1697              TIM1_SetIC3Prescaler(TIM1_ICPrescaler);
   1698            }
   1699            else
   1700            {
   1701              /* TI4 Configuration */
   1702              TI4_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   1703              /* Set the Input Capture Prescaler value */
   1704              TIM1_SetIC4Prescaler(TIM1_ICPrescaler);
   1705            }
   1706          }
   1707          
   1708          /**
   1709            * @brief  Configures the TIM1 peripheral in PWM Input Mode according to the
   1710            *         specified parameters.
   1711            * @param  TIM1_Channel specifies the input capture channel
   1712            *          This parameter can be one of the following values:
   1713            *            @arg TIM1_Channel_1: TIM1 Channel1
   1714            *            @arg TIM1_Channel_2: TIM1 Channel2
   1715            * @param  TIM1_ICPolarity specifies the Input capture polarity
   1716            *          This parameter can be one of the following values:
   1717            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   1718            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   1719            * @param  TIM1_ICSelection specifies the Input capture source selection 
   1720            *          This parameter can be one of the following values:
   1721            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input x is selected to be connected to ICx.
   1722            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input x is selected to be connected to ICy.
   1723            *            @arg TIM1_ICSelection_TRGI: TIM1 Input x is selected to be connected to the TRGI     
   1724            * @param  TIM1_ICPrescaler specifies the Input capture Prescaler
   1725            *          This parameter can be one of the following values:
   1726            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1727            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1728            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1729            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1730            * @param  TIM1_ICFilter specifies the Input capture filter value.
   1731            * @retval None
   1732            */
   1733          void TIM1_PWMIConfig(TIM1_Channel_T TIM1_Channel,
   1734                               TIM1_ICPolarity_T TIM1_ICPolarity,
   1735                               TIM1_ICSelection_T TIM1_ICSelection,
   1736                               TIM1_ICPSC_T TIM1_ICPrescaler,
   1737                               uint8_t TIM1_ICFilter)
   1738          {
   1739            TIM1_ICPolarity_T icpolarity = TIM1_ICPolarity_Rising;
   1740            TIM1_ICSelection_T icselection = TIM1_ICSelection_DirectTI;
   1741          
   1742            /* Check the parameters */
   1743            assert_param(IS_TIM1_PWMI_CHANNEL(TIM1_Channel));
   1744            assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
   1745            assert_param(IS_TIM1_IC_SELECTION(TIM1_ICSelection));
   1746            assert_param(IS_TIM1_IC_PRESCALER(TIM1_ICPrescaler));
   1747          
   1748            /* Select the Opposite Input Polarity */
   1749            if (TIM1_ICPolarity != TIM1_ICPolarity_Falling)
   1750            {
   1751              icpolarity = TIM1_ICPolarity_Falling;
   1752            }
   1753            else
   1754            {
   1755              icpolarity = TIM1_ICPolarity_Rising;
   1756            }
   1757          
   1758            /* Select the Opposite Input */
   1759            if (TIM1_ICSelection == TIM1_ICSelection_DirectTI)
   1760            {
   1761              icselection = TIM1_ICSelection_IndirectTI;
   1762            }
   1763            else
   1764            {
   1765              icselection = TIM1_ICSelection_DirectTI;
   1766            }
   1767          
   1768            if (TIM1_Channel == TIM1_Channel_1)
   1769            {
   1770              /* TI1 Configuration */
   1771              TI1_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   1772          
   1773              /* Set the Input Capture Prescaler value */
   1774              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   1775          
   1776              /* TI2 Configuration */
   1777              TI2_Config(icpolarity, icselection, TIM1_ICFilter);
   1778          
   1779              /* Set the Input Capture Prescaler value */
   1780              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   1781            }
   1782            else
   1783            {
   1784              /* TI2 Configuration */
   1785              TI2_Config(TIM1_ICPolarity, TIM1_ICSelection, TIM1_ICFilter);
   1786          
   1787              /* Set the Input Capture Prescaler value */
   1788              TIM1_SetIC2Prescaler(TIM1_ICPrescaler);
   1789          
   1790              /* TI1 Configuration */
   1791              TI1_Config(icpolarity, icselection, TIM1_ICFilter);
   1792          
   1793              /* Set the Input Capture Prescaler value */
   1794              TIM1_SetIC1Prescaler(TIM1_ICPrescaler);
   1795            }
   1796          }
   1797          
   1798          /**
   1799            * @brief  Gets the TIM1 Input Capture 1 value.
   1800            * @param  None
   1801            * @retval Capture Compare 1 Register value.
   1802            */
   1803          uint16_t TIM1_GetCapture1(void)
   1804          {
   1805            /* Get the Capture 1 Register value */
   1806          
   1807            uint16_t tmpccr1 = 0;
   1808            uint8_t tmpccr1l = 0, tmpccr1h = 0;
   1809          
   1810            tmpccr1h = TIM1->CCR1H;
   1811            tmpccr1l = TIM1->CCR1L;
   1812          
   1813            tmpccr1 = (uint16_t)(tmpccr1l);
   1814            tmpccr1 |= (uint16_t)((uint16_t)tmpccr1h << 8);
   1815            /* Get the Capture 1 Register value */
   1816            return (uint16_t)tmpccr1;
   1817          }
   1818          
   1819          /**
   1820            * @brief  Gets the TIM1 Input Capture 2 value.
   1821            * @param  None
   1822            * @retval Capture Compare 2 Register value.
   1823            */
   1824          uint16_t TIM1_GetCapture2(void)
   1825          {
   1826            /* Get the Capture 2 Register value */
   1827          
   1828            uint16_t tmpccr2 = 0;
   1829            uint8_t tmpccr2l = 0, tmpccr2h = 0;
   1830          
   1831            tmpccr2h = TIM1->CCR2H;
   1832            tmpccr2l = TIM1->CCR2L;
   1833          
   1834            tmpccr2 = (uint16_t)(tmpccr2l);
   1835            tmpccr2 |= (uint16_t)((uint16_t)tmpccr2h << 8);
   1836            /* Get the Capture 2 Register value */
   1837            return (uint16_t)tmpccr2;
   1838          }
   1839          
   1840          /**
   1841            * @brief  Gets the TIM1 Input Capture 3 value.
   1842            * @param  None
   1843            * @retval Capture Compare 3 Register value.
   1844            */
   1845          uint16_t TIM1_GetCapture3(void)
   1846          {
   1847            /* Get the Capture 3 Register value */
   1848            uint16_t tmpccr3 = 0;
   1849            uint8_t tmpccr3l = 0, tmpccr3h = 0;
   1850          
   1851            tmpccr3h = TIM1->CCR3H;
   1852            tmpccr3l = TIM1->CCR3L;
   1853          
   1854            tmpccr3 = (uint16_t)(tmpccr3l);
   1855            tmpccr3 |= (uint16_t)((uint16_t)tmpccr3h << 8);
   1856            /* Get the Capture 3 Register value */
   1857            return (uint16_t)tmpccr3;
   1858          }
   1859          
   1860          /**
   1861            * @brief  Gets the TIM1 Input Capture 4 value.
   1862            * @param  None
   1863            * @retval Capture Compare 4 Register value.
   1864            */
   1865          uint16_t TIM1_GetCapture4(void)
   1866          {
   1867            /* Get the Capture 4 Register value */
   1868            uint16_t tmpccr4 = 0;
   1869            uint8_t tmpccr4l = 0, tmpccr4h = 0;
   1870          
   1871            tmpccr4h = TIM1->CCR4H;
   1872            tmpccr4l = TIM1->CCR4L;
   1873          
   1874            tmpccr4 = (uint16_t)(tmpccr4l);
   1875            tmpccr4 |= (uint16_t)((uint16_t)tmpccr4h << 8);
   1876            /* Get the Capture 4 Register value */
   1877            return (uint16_t)tmpccr4;
   1878          }
   1879          
   1880          /**
   1881            * @brief  Sets the TIM1 Input Capture 1 prescaler.
   1882            * @param  TIM1_IC1Prescaler specifies the Input Capture prescaler new value
   1883            *          This parameter can be one of the following values:
   1884            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1885            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1886            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1887            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1888            * @retval None
   1889            */
   1890          void TIM1_SetIC1Prescaler(TIM1_ICPSC_T TIM1_IC1Prescaler)
   1891          {
   1892            /* Check the parameters */
   1893            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC1Prescaler));
   1894          
   1895            /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1896            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC1Prescaler);
   1897          }
   1898          
   1899          /**
   1900            * @brief  Sets the TIM1 Input Capture 2 prescaler.
   1901            * @param  TIM1_IC2Prescaler specifies the Input Capture prescaler new value
   1902            *          This parameter can be one of the following values:
   1903            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1904            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1905            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1906            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1907            * @retval None
   1908            */
   1909          void TIM1_SetIC2Prescaler(TIM1_ICPSC_T TIM1_IC2Prescaler)
   1910          {
   1911            /* Check the parameters */
   1912            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC2Prescaler));
   1913          
   1914            /* Reset the IC1PSC Bits */ /* Set the IC1PSC value */
   1915            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC2Prescaler);
   1916          }
   1917          
   1918          /**
   1919            * @brief  Sets the TIM1 Input Capture 3 prescaler.
   1920            * @param  TIM1_IC3Prescaler specifies the Input Capture prescaler new value
   1921            *          This parameter can be one of the following values:
   1922            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1923            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1924            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1925            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1926            * @retval None
   1927            */
   1928          void TIM1_SetIC3Prescaler(TIM1_ICPSC_T TIM1_IC3Prescaler)
   1929          {
   1930          
   1931            /* Check the parameters */
   1932            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC3Prescaler));
   1933          
   1934            /* Reset the IC1PSC Bits & Set the IC1PSC value */
   1935            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC3Prescaler);
   1936          }
   1937          
   1938          /**
   1939            * @brief  Sets the TIM1 Input Capture 4 prescaler.
   1940            * @param  TIM1_IC4Prescaler specifies the Input Capture prescaler new value
   1941            *          This parameter can be one of the following values:
   1942            *            @arg TIM1_ICPSC_DIV1: Input Capture Prescaler = 1 (one capture every 1 event)
   1943            *            @arg TIM1_ICPSC_DIV2: Input Capture Prescaler = 2 (one capture every 2 events)
   1944            *            @arg TIM1_ICPSC_DIV4: Input Capture Prescaler = 4 (one capture every 4 events)
   1945            *            @arg TIM1_ICPSC_DIV8: Input Capture Prescaler = 8 (one capture every 8 events)   
   1946            * @retval None
   1947            */
   1948          void TIM1_SetIC4Prescaler(TIM1_ICPSC_T TIM1_IC4Prescaler)
   1949          {
   1950          
   1951            /* Check the parameters */
   1952            assert_param(IS_TIM1_IC_PRESCALER(TIM1_IC4Prescaler));
   1953          
   1954            /* Reset the IC1PSC Bits &  Set the IC1PSC value */
   1955            TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_ICxPSC)) | (uint8_t)TIM1_IC4Prescaler);
   1956          }
   1957          
   1958          /**
   1959            * @}
   1960            */
   1961          
   1962          /** @defgroup TIM1_Group4 Interrupts DMA and flags management functions
   1963           *  @brief    Interrupts, DMA and flags management functions 
   1964           *
   1965          @verbatim   
   1966           ===============================================================================
   1967                           Interrupts, DMA and flags management functions
   1968           ===============================================================================  
   1969          
   1970          @endverbatim
   1971            * @{
   1972            */
   1973          
   1974          /**
   1975            * @brief  Enables or disables the specified TIM1 interrupts.
   1976            * @param  NewState new state of the TIM1 peripheral.
   1977            *          This parameter can be: ENABLE or DISABLE.
   1978            * @param  TIM1_IT specifies the TIM1 interrupts sources to be enabled or disabled.
   1979            *          This parameter can be any combination of the following values:
   1980            *            @arg TIM1_IT_Update: Update
   1981            *            @arg TIM1_IT_CC1: Capture Compare Channel1
   1982            *            @arg TIM1_IT_CC2: Capture Compare Channel2 
   1983            *            @arg TIM1_IT_CC3: Capture Compare Channel3
   1984            *            @arg TIM1_IT_CC4: Capture Compare Channel4 
   1985            *            @arg TIM1_IT_COM: Commutation
   1986            *            @arg TIM1_IT_Trigger: Trigger 
   1987            *            @arg TIM1_IT_Break: Break  
   1988            * @param  NewState new state of the TIM1 peripheral.
   1989            * @retval None
   1990            */
   1991          void TIM1_ITConfig(TIM1_IT_T  TIM1_IT, FunctionalState NewState)
   1992          {
   1993            /* Check the parameters */
   1994            assert_param(IS_TIM1_IT(TIM1_IT));
   1995            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1996          
   1997            if (NewState != DISABLE)
   1998            {
   1999              /* Enable the Interrupt sources */
   2000              TIM1->IER |= (uint8_t)TIM1_IT;
   2001            }
   2002            else
   2003            {
   2004              /* Disable the Interrupt sources */
   2005              TIM1->IER &= (uint8_t)(~(uint8_t)TIM1_IT);
   2006            }
   2007          }
   2008          
   2009          /**
   2010            * @brief  Configures the TIM1 event to be generated by software.
   2011            * @param  TIM1_EventSource specifies the event source.
   2012            *          This parameter can be any combination of the following values:
   2013            *            @arg TIM1_EventSource_Update: Update
   2014            *            @arg TIM1_EventSource_CC1: Capture Compare Channel1
   2015            *            @arg TIM1_EventSource_CC2: Capture Compare Channel2 
   2016            *            @arg TIM1_EventSource_CC3: Capture Compare Channel3
   2017            *            @arg TIM1_EventSource_CC4: Capture Compare Channel4 
   2018            *            @arg TIM1_EventSource_COM: Commutation
   2019            *            @arg TIM1_EventSource_Trigger: Trigger 
   2020            *            @arg TIM1_EventSource_Break: Break  
   2021            * @retval None
   2022            */
   2023          void TIM1_GenerateEvent(TIM1_EventSource_T TIM1_EventSource)
   2024          {
   2025            /* Check the parameters */
   2026            assert_param(IS_TIM1_EVENT_SOURCE(TIM1_EventSource));
   2027          
   2028            /* Set the event sources */
   2029            TIM1->EGR = (uint8_t)TIM1_EventSource;
   2030          }
   2031          /**
   2032            * @brief  Checks whether the specified TIM1 flag is set or not.
   2033            * @param  TIM1_FLAG specifies the flag to check.
   2034            *          This parameter can be one of the following values:
   2035            *            @arg TIM1_FLAG_Update: TIM1 update Flag
   2036            *            @arg TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2037            *            @arg TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2038            *            @arg TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2039            *            @arg TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2040            *            @arg TIM1_FLAG_COM: TIM1 Commutation Flag
   2041            *            @arg TIM1_FLAG_Trigger: TIM1 Trigger Flag
   2042            *            @arg TIM1_FLAG_Break: TIM1 Break Flag
   2043            *            @arg TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2044            *            @arg TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2045            *            @arg TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2046            *            @arg TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2047            * @retval FlagStatus The new state of TIM1_FLAG (SET or RESET).
   2048            */
   2049          FlagStatus TIM1_GetFlagStatus(TIM1_FLAG_T TIM1_FLAG)
   2050          {
   2051            FlagStatus bitstatus = RESET;
   2052            uint8_t tim1_flag_l = 0, tim1_flag_h = 0;
   2053          
   2054            /* Check the parameters */
   2055            assert_param(IS_TIM1_GET_FLAG(TIM1_FLAG));
   2056          
   2057            tim1_flag_l = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_FLAG);
   2058            tim1_flag_h = (uint8_t)(TIM1->SR2 & (uint8_t)((uint16_t)TIM1_FLAG >> 8));
   2059          
   2060            if ((uint8_t)((uint8_t)tim1_flag_l | (uint8_t)tim1_flag_h) != 0)
   2061            {
   2062              bitstatus = SET;
   2063            }
   2064            else
   2065            {
   2066              bitstatus = RESET;
   2067            }
   2068            return (FlagStatus)(bitstatus);
   2069          }
   2070          
   2071          /**
   2072            * @brief  Clears the TIM1�s pending flags.
   2073            * @param  TIM1_FLAG specifies the flag to clear.
   2074            *          This parameter can be one of the following values:
   2075            *            @arg TIM1_FLAG_Update: TIM1 update Flag
   2076            *            @arg TIM1_FLAG_CC1: TIM1 Capture Compare 1 Flag
   2077            *            @arg TIM1_FLAG_CC2: TIM1 Capture Compare 2 Flag
   2078            *            @arg TIM1_FLAG_CC3: TIM1 Capture Compare 3 Flag
   2079            *            @arg TIM1_FLAG_CC4: TIM1 Capture Compare 4 Flag
   2080            *            @arg TIM1_FLAG_COM: TIM1 Commutation Flag
   2081            *            @arg TIM1_FLAG_Trigger: TIM1 Trigger Flag
   2082            *            @arg TIM1_FLAG_Break: TIM1 Break Flag
   2083            *            @arg TIM1_FLAG_CC1OF: TIM1 Capture Compare 1 overcapture Flag
   2084            *            @arg TIM1_FLAG_CC2OF: TIM1 Capture Compare 2 overcapture Flag
   2085            *            @arg TIM1_FLAG_CC3OF: TIM1 Capture Compare 3 overcapture Flag
   2086            *            @arg TIM1_FLAG_CC4OF: TIM1 Capture Compare 4 overcapture Flag
   2087            * @retval None.
   2088            */
   2089          void TIM1_ClearFlag(TIM1_FLAG_T TIM1_FLAG)
   2090          {
   2091            /* Check the parameters */
   2092            assert_param(IS_TIM1_CLEAR_FLAG(TIM1_FLAG));
   2093          
   2094            /* Clear the flags (rc_w0) clear this bit by writing 0. Writing �1� has no effect*/
   2095            TIM1->SR1 = (uint8_t)(~(uint8_t)(TIM1_FLAG));
   2096            TIM1->SR2 = (uint8_t)((uint8_t)(~((uint8_t)((uint16_t)TIM1_FLAG >> 8))) & (uint8_t)0x1E);
   2097          }
   2098          
   2099          /**
   2100            * @brief  Checks whether the TIM1 interrupt has occurred or not.
   2101            * @param  TIM1_IT specifies the TIM1 interrupt source to check.
   2102            *          This parameter can be any combination of the following values:
   2103            *            @arg TIM1_IT_Update: Update
   2104            *            @arg TIM1_IT_CC1: Capture Compare Channel1
   2105            *            @arg TIM1_IT_CC2: Capture Compare Channel2 
   2106            *            @arg TIM1_IT_CC3: Capture Compare Channel3
   2107            *            @arg TIM1_IT_CC4: Capture Compare Channel4 
   2108            *            @arg TIM1_IT_COM: Commutation
   2109            *            @arg TIM1_IT_Trigger: Trigger 
   2110            *            @arg TIM1_IT_Break: Break  
   2111            * @retval ITStatus The new state of the TIM1_IT(SET or RESET).
   2112            */
   2113          
   2114          ITStatus TIM1_GetITStatus(TIM1_IT_T TIM1_IT)
   2115          {
   2116            ITStatus bitstatus = RESET;
   2117          
   2118            uint8_t TIM1_itStatus = 0x0, TIM1_itEnable = 0x0;
   2119          
   2120            /* Check the parameters */
   2121            assert_param(IS_TIM1_GET_IT(TIM1_IT));
   2122          
   2123            TIM1_itStatus = (uint8_t)(TIM1->SR1 & (uint8_t)TIM1_IT);
   2124          
   2125            TIM1_itEnable = (uint8_t)(TIM1->IER & (uint8_t)TIM1_IT);
   2126          
   2127            if ((TIM1_itStatus != (uint8_t)RESET ) && (TIM1_itEnable != (uint8_t)RESET ))
   2128            {
   2129              bitstatus = SET;
   2130            }
   2131            else
   2132            {
   2133              bitstatus = RESET;
   2134            }
   2135            return (ITStatus)(bitstatus);
   2136          }
   2137          
   2138          /**
   2139            * @brief  Clears the TIM1's interrupt pending bits.
   2140            * @param  TIM1_IT specifies the pending bit to clear.
   2141            *          This parameter can be any combination of the following values:
   2142            *            @arg TIM1_IT_Update: Update
   2143            *            @arg TIM1_IT_CC1: Capture Compare Channel1
   2144            *            @arg TIM1_IT_CC2: Capture Compare Channel2 
   2145            *            @arg TIM1_IT_CC3: Capture Compare Channel3
   2146            *            @arg TIM1_IT_CC4: Capture Compare Channel4 
   2147            *            @arg TIM1_IT_COM: Commutation
   2148            *            @arg TIM1_IT_Trigger: Trigger 
   2149            *            @arg TIM1_IT_Break: Break  
   2150            * @retval None.
   2151            */
   2152          void TIM1_ClearITPendingBit(TIM1_IT_T TIM1_IT)
   2153          {
   2154            /* Check the parameters */
   2155            assert_param(IS_TIM1_IT(TIM1_IT));
   2156          
   2157            /* Clear the IT pending Bit */
   2158            TIM1->SR1 = (uint8_t)(~(uint8_t)TIM1_IT);
   2159          }
   2160          
   2161          /**
   2162            * @brief  Configures the TIM1�s DMA interface.
   2163            * @param  TIM1_DMABase: DMA Base address.
   2164            * @param  TIM1_DMABurstLength: DMA Burst length.
   2165            * @retval None.
   2166            */
   2167          void TIM1_DMAConfig(TIM1_DMABase_T TIM1_DMABase,
   2168                              TIM1_DMABurstLength_T TIM1_DMABurstLength)
   2169          {
   2170            /* Check the parameters */
   2171            assert_param(IS_TIM1_DMABase(TIM1_DMABase));
   2172            assert_param(IS_TIM1_DMABurstLength(TIM1_DMABurstLength));
   2173          
   2174            /* Set the DMA Base and the DMA Burst Length */
   2175            TIM1->DCR1 = (uint8_t)TIM1_DMABase;
   2176            TIM1->DCR2 = (uint8_t)TIM1_DMABurstLength;
   2177          }
   2178          
   2179          /**
   2180            * @brief  Enables or disables the TIM�s DMA Requests.
   2181            * @param  TIM1_DMASources: specifies the DMA Request sources.
   2182            *          This parameter can be any combination of the following values:
   2183            *            @arg TIM1_DMA_Update: TIM1 update Interrupt source
   2184            *            @arg DMA_Trigger: TIM1 Trigger DMA source
   2185            * @param  NewState  new state of the DMA Request sources.
   2186            *          This parameter can be: ENABLE or DISABLE.
   2187            * @retval None.
   2188            */
   2189          void TIM1_DMACmd(TIM1_DMASource_T TIM1_DMASource, FunctionalState NewState)
   2190          {
   2191            /* Check the parameters */
   2192            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2193            assert_param(IS_TIM1_DMA_SOURCE(TIM1_DMASource));
   2194          
   2195            if (NewState != DISABLE)
   2196            {
   2197              /* Enable the DMA sources */
   2198              TIM1->DER |= (uint8_t)TIM1_DMASource;
   2199            }
   2200            else
   2201            {
   2202              /* Disable the DMA sources */
   2203              TIM1->DER &= (uint8_t)(~TIM1_DMASource);
   2204            }
   2205          }
   2206          
   2207          /**
   2208            * @brief  Selects the TIM1 peripheral Capture Compare DMA source.
   2209            * @param   NewState: new state of the Capture Compare DMA source.
   2210            *          This parameter can be: ENABLE or DISABLE.
   2211            * @retval None
   2212            */
   2213          void TIM1_SelectCCDMA(FunctionalState NewState)
   2214          {
   2215            /* Check the parameters */
   2216            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2217          
   2218            if (NewState != DISABLE)
   2219            {
   2220              /* Set the CCDS Bit */
   2221              TIM1->CR2 |= TIM1_CR2_CCDS;
   2222            }
   2223            else
   2224            {
   2225              /* Reset the CCDS Bit */
   2226              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_CCDS);
   2227            }
   2228          }
   2229          
   2230          /**
   2231            * @}
   2232            */
   2233          
   2234          /** @defgroup TIM1_Group5 Clocks management functions
   2235           *  @brief    Clocks management functions
   2236           *
   2237          @verbatim   
   2238           ===============================================================================
   2239                                   Clocks management functions
   2240           ===============================================================================  
   2241          
   2242          @endverbatim
   2243            * @{
   2244            */
   2245          
   2246          /**
   2247            * @brief  Configures the TIM1 internal Clock.
   2248            * @param  None
   2249            * @retval None
   2250            */
   2251          void TIM1_InternalClockConfig(void)
   2252          {
   2253            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2254            TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_SMS);
   2255          }
   2256          
   2257          /**
   2258            * @brief  Configures the TIM1 Trigger as External Clock.
   2259            * @param  TIM1_TIxExternalCLKSource specifies Trigger source.
   2260            *          This parameter can be one of the following values:
   2261            *            @arg TIM1_TIxExternalCLK1Source_TI1: TI1 Edge Detector
   2262            *            @arg TIM1_TIxExternalCLK1Source_TI2: Filtered TIM1 Input 1
   2263            *            @arg TIM1_TIxExternalCLK1Source_TI1ED: Filtered TIM1 Input 2
   2264            * @param  TIM1_ICPolarity specifies the TIx Polarity.
   2265            *          This parameter can be one of the following values:
   2266            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2267            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2268            * @param  ICFilter specifies the filter value.
   2269            *          This parameter must be a value between 0x00 and 0x0F
   2270            * @retval None
   2271            */
   2272          void TIM1_TIxExternalClockConfig(TIM1_TIxExternalCLK1Source_T TIM1_TIxExternalCLKSource,
   2273                                           TIM1_ICPolarity_T TIM1_ICPolarity,
   2274                                           uint8_t ICFilter)
   2275          {
   2276            /* Check the parameters */
   2277            assert_param(IS_TIM1_TIXCLK_SOURCE(TIM1_TIxExternalCLKSource));
   2278            assert_param(IS_TIM1_IC_POLARITY(TIM1_ICPolarity));
   2279            assert_param(IS_TIM1_IC_FILTER(ICFilter));
   2280          
   2281            /* Configure the TIM1 Input Clock Source */
   2282            if (TIM1_TIxExternalCLKSource == TIM1_TIxExternalCLK1Source_TI2)
   2283            {
   2284              TI2_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
   2285            }
   2286            else
   2287            {
   2288              TI1_Config(TIM1_ICPolarity, TIM1_ICSelection_DirectTI, ICFilter);
   2289            }
   2290          
   2291            /* Select the Trigger source */
   2292            TIM1_SelectInputTrigger((TIM1_TRGSelection_T)TIM1_TIxExternalCLKSource);
   2293          
   2294            /* Select the External clock mode1 */
   2295            TIM1->SMCR |= (uint8_t)(TIM1_SlaveMode_External1);
   2296          }
   2297          
   2298          /**
   2299            * @brief  Configures the TIM1 External clock Mode1.
   2300            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
   2301            *          This parameter can be one of the following values:
   2302            *            @arg TIM1_ExtTRGPSC_OFF
   2303            *            @arg TIM1_ExtTRGPSC_DIV2
   2304            *            @arg TIM1_ExtTRGPSC_DIV4
   2305            *            @arg TIM1_ExtTRGPSC_DIV8.
   2306            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
   2307            *          This parameter can be one of the following values:
   2308            *            @arg TIM1_ExtTRGPolarity_Inverted
   2309            *            @arg TIM1_ExtTRGPolarity_NonInverted
   2310            * @param  ExtTRGFilter specifies the External Trigger Filter.
   2311            *          This parameter must be a value between 0x00 and 0x0F
   2312            * @retval None
   2313            */
   2314          void TIM1_ETRClockMode1Config(TIM1_ExtTRGPSC_T TIM1_ExtTRGPrescaler,
   2315                                        TIM1_ExtTRGPolarity_T TIM1_ExtTRGPolarity,
   2316                                        uint8_t ExtTRGFilter)
   2317          {
   2318            /* Check the parameters */
   2319            assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
   2320            assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
   2321            assert_param(IS_TIM1_EXT_TRG_FILTER(ExtTRGFilter));
   2322          
   2323            /* Configure the ETR Clock source */
   2324            TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   2325          
   2326            /* Select the External clock mode1 & Select the Trigger selection : ETRF */
   2327            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~(TIM1_SMCR_SMS | TIM1_SMCR_TS)))
   2328                                   | (uint8_t)((uint8_t)TIM1_SlaveMode_External1 | (uint8_t) TIM1_TRGSelection_ETRF));
   2329          }
   2330          
   2331          /**
   2332            * @brief  Configures the TIM1 External clock Mode2.
   2333            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
   2334            *          This parameter can be one of the following values:
   2335            *            @arg TIM1_ExtTRGPSC_OFF
   2336            *            @arg TIM1_ExtTRGPSC_DIV2
   2337            *            @arg TIM1_ExtTRGPSC_DIV4
   2338            *            @arg TIM1_ExtTRGPSC_DIV8.
   2339            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
   2340            *          This parameter can be one of the following values:
   2341            *            @arg TIM1_ExtTRGPolarity_Inverted
   2342            *            @arg TIM1_ExtTRGPolarity_NonInverted
   2343            * @param  ExtTRGFilter specifies the External Trigger Filter.
   2344            *          This parameter must be a value between 0x00 and 0x0F
   2345            * @retval None
   2346            */
   2347          void TIM1_ETRClockMode2Config(TIM1_ExtTRGPSC_T TIM1_ExtTRGPrescaler,
   2348                                        TIM1_ExtTRGPolarity_T TIM1_ExtTRGPolarity,
   2349                                        uint8_t ExtTRGFilter)
   2350          {
   2351            /* Check the parameters */
   2352            assert_param(IS_TIM1_EXT_PRESCALER(TIM1_ExtTRGPrescaler));
   2353            assert_param(IS_TIM1_EXT_POLARITY(TIM1_ExtTRGPolarity));
   2354          
   2355            /* Configure the ETR Clock source */
   2356            TIM1_ETRConfig(TIM1_ExtTRGPrescaler, TIM1_ExtTRGPolarity, ExtTRGFilter);
   2357          
   2358            /* Enable the External clock mode2 */
   2359            TIM1->ETR |= TIM1_ETR_ECE;
   2360          }
   2361          
   2362          /**
   2363            * @}
   2364            */
   2365          
   2366          /** @defgroup TIM1_Group6 Synchronization management functions
   2367           *  @brief    Synchronization management functions 
   2368           *
   2369          @verbatim   
   2370           ===============================================================================
   2371                                 Synchronization management functions
   2372           ===============================================================================  
   2373                             
   2374                 ===================================================================      
   2375                        TIM1 Driver: how to use it in synchronization Mode
   2376                 =================================================================== 
   2377                 Case of two/several Timers
   2378                 **************************
   2379                 1. If TIM1 is used as master to other timers use the following functions:
   2380                    - TIM1_SelectOutputTrigger()
   2381                    - TIM1_SelectMasterSlaveMode()
   2382                 2. If TIM1 is used as slave to other timers use the following functions:
   2383                    - TIM1_SelectInputTrigger()
   2384                    - TIM1_SelectSlaveMode()
   2385                    
   2386                 Case of Timers and external trigger (TRIG pin)
   2387                 ********************************************       
   2388                 1. Configure the External trigger using TIM1_ETRConfig()
   2389                 2. Configure the Slave Timer using the following functions:
   2390                    - TIM1_SelectInputTrigger()
   2391                    - TIM1_SelectSlaveMode()
   2392          
   2393          @endverbatim
   2394            * @{
   2395            */
   2396          
   2397          /**
   2398            * @brief  Selects the TIM1 Input Trigger source.
   2399            * @param  TIM1_InputTriggerSource specifies Input Trigger source.
   2400            *          This parameter can be one of the following values:
   2401            *            @arg TIM1_TRGSelection_TIM4
   2402            *            @arg TIM1_TRGSelection_TIM3
   2403            *            @arg TIM1_TRGSelection_TIM2
   2404            *            @arg TIM1_TRGSelection_TI1F_ED: TI1 Edge Detector
   2405            *            @arg TIM1_TRGSelection_TI1FP1: Filtered Timer Input 1
   2406            *            @arg TIM1_TRGSelection_TI2FP2: Filtered Timer Input 2
   2407            *            @arg TIM1_TRGSelection_ETRF: External Trigger input
   2408            * @retval None
   2409            */
   2410          void TIM1_SelectInputTrigger(TIM1_TRGSelection_T TIM1_InputTriggerSource)
   2411          {
   2412            /* Check the parameters */
   2413            assert_param(IS_TIM1_TRIGGER_SELECTION(TIM1_InputTriggerSource));
   2414          
   2415            /* Select the Tgigger Source */
   2416            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_TS)) | (uint8_t)TIM1_InputTriggerSource);
   2417          }
   2418          
   2419          /**
   2420            * @brief  Selects the TIM1 Trigger Output Mode.
   2421            * @param  TIM1_TRGOSource specifies the Trigger Output source.
   2422            *          This parameter can be one of the following values
   2423            *            @arg TIM1_TRGOSource_Reset
   2424            *            @arg TIM1_TRGOSource_Enable
   2425            *            @arg TIM1_TRGOSource_Update
   2426            *            @arg TIM1_TRGOSource_OC1
   2427            *            @arg TIM1_TRGOSource_OC1REF
   2428            *            @arg TIM1_TRGOSource_OC2REF
   2429            *            @arg TIM1_TRGOSource_OC3REF
   2430            *            @arg TIM1_TRGOSource_OC4REF
   2431            * @retval None
   2432            */
   2433          void TIM1_SelectOutputTrigger(TIM1_TRGOSource_T TIM1_TRGOSource)
   2434          {
   2435            /* Check the parameters */
   2436            assert_param(IS_TIM1_TRGO_SOURCE(TIM1_TRGOSource));
   2437            /* Reset the MMS Bits & Select the TRGO source */
   2438            TIM1->CR2 = (uint8_t)((uint8_t)(TIM1->CR2 & (uint8_t)(~TIM1_CR2_MMS)) | (uint8_t) TIM1_TRGOSource);
   2439          }
   2440          
   2441          /**
   2442            * @brief  Selects the TIM1 Slave Mode.
   2443            * @param  TIM1_SlaveMode specifies the TIM1 Slave Mode.
   2444            *          This parameter can be one of the following values
   2445            *            @arg TIM1_SlaveMode_Reset
   2446            *            @arg TIM1_SlaveMode_Gated
   2447            *            @arg TIM1_SlaveMode_Trigger
   2448            *            @arg TIM1_SlaveMode_External1
   2449            * @retval None
   2450            */
   2451          void TIM1_SelectSlaveMode(TIM1_SlaveMode_T TIM1_SlaveMode)
   2452          {
   2453            /* Check the parameters */
   2454            assert_param(IS_TIM1_SLAVE_MODE(TIM1_SlaveMode));
   2455          
   2456            /* Reset the SMS Bits and Select the Slave Mode */
   2457            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(~TIM1_SMCR_SMS)) | (uint8_t)TIM1_SlaveMode);
   2458          
   2459          }
   2460          
   2461          /**
   2462            * @brief  Sets or Resets the TIM1 Master/Slave Mode.
   2463            * @param  NewState new state of the synchronization between TIM1 and its slaves
   2464            *         (through TRGO). This parameter can be ENABLE or DISABLE.
   2465            * @retval None
   2466            */
   2467          void TIM1_SelectMasterSlaveMode(FunctionalState NewState)
   2468          {
   2469            /* Check the parameters */
   2470            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2471          
   2472            /* Set or Reset the MSM Bit */
   2473            if (NewState != DISABLE)
   2474            {
   2475              TIM1->SMCR |= TIM1_SMCR_MSM;
   2476            }
   2477            else
   2478            {
   2479              TIM1->SMCR &= (uint8_t)(~TIM1_SMCR_MSM);
   2480            }
   2481          }
   2482          
   2483          /**
   2484            * @brief  Configures the TIM1 External Trigger.
   2485            * @param  TIM1_ExtTRGPrescaler specifies the external Trigger Prescaler.
   2486            *          This parameter can be one of the following values:
   2487            *            @arg TIM1_ExtTRGPSC_OFF
   2488            *            @arg TIM1_ExtTRGPSC_DIV2
   2489            *            @arg TIM1_ExtTRGPSC_DIV4
   2490            *            @arg TIM1_ExtTRGPSC_DIV8.
   2491            * @param  TIM1_ExtTRGPolarity specifies the external Trigger Polarity.
   2492            *          This parameter can be one of the following values:
   2493            *            @arg TIM1_ExtTRGPolarity_Inverted
   2494            *            @arg TIM1_ExtTRGPolarity_NonInverted
   2495            * @param  ExtTRGFilter specifies the External Trigger Filter.
   2496            *          This parameter must be a value between 0x00 and 0x0F
   2497            * @retval None
   2498            */
   2499          void TIM1_ETRConfig(TIM1_ExtTRGPSC_T TIM1_ExtTRGPrescaler,
   2500                              TIM1_ExtTRGPolarity_T TIM1_ExtTRGPolarity,
   2501                              uint8_t ExtTRGFilter)
   2502          {
   2503            assert_param(IS_TIM1_EXT_TRG_FILTER(ExtTRGFilter));
   2504          
   2505            /* Set the Prescaler, the Filter value and the Polarity */
   2506            TIM1->ETR |= (uint8_t)((uint8_t)((uint8_t) TIM1_ExtTRGPrescaler
   2507                                             | (uint8_t) TIM1_ExtTRGPolarity)
   2508                                   | (uint8_t) ExtTRGFilter);
   2509          }
   2510          
   2511          /**
   2512            * @}
   2513            */
   2514          
   2515          /** @defgroup TIM1_Group7 Specific interface management functions
   2516           *  @brief    Specific interface management functions 
   2517           *
   2518          @verbatim   
   2519           ===============================================================================
   2520                              Specific interface management functions
   2521           ===============================================================================  
   2522          
   2523          @endverbatim
   2524            * @{
   2525            */
   2526          
   2527          /**
   2528            * @brief  Configures the TIM1 Encoder Interface.
   2529            * @param  TIM1_EncoderMode specifies the TIM1 Encoder Mode.
   2530            *          This parameter can be one of the following values
   2531            *            @arg TIM1_EncoderMode_TI1: Counter counts on TI1FP1 edge
   2532            *          depending on TI2FP2 level.
   2533            *            @arg TIM1_EncoderMode_TI2: Counter counts on TI2FP2 edge
   2534            *         depending on TI1FP1 level.
   2535            *            @arg TIM1_EncoderMode_TI12: Counter counts on both TI1FP1 and
   2536            *         TI2FP2 edges depending on the level of the other input.
   2537            * @param  TIM1_IC1Polarity specifies the IC1 Polarity.
   2538            *          This parameter can be one of the following values:
   2539            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2540            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2541            * @param  TIM1_IC2Polarity specifies the IC2 Polarity.
   2542            *          This parameter can be one of the following values:
   2543            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2544            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2545            * @retval None
   2546            */
   2547          void TIM1_EncoderInterfaceConfig(TIM1_EncoderMode_T TIM1_EncoderMode,
   2548                                           TIM1_ICPolarity_T TIM1_IC1Polarity,
   2549                                           TIM1_ICPolarity_T TIM1_IC2Polarity)
   2550          {
   2551            /* Check the parameters */
   2552            assert_param(IS_TIM1_ENCODER_MODE(TIM1_EncoderMode));
   2553            assert_param(IS_TIM1_IC_POLARITY(TIM1_IC1Polarity));
   2554            assert_param(IS_TIM1_IC_POLARITY(TIM1_IC2Polarity));
   2555          
   2556            /* Set the TI1 and the TI2 Polarities */
   2557            if (TIM1_IC1Polarity != TIM1_ICPolarity_Rising)
   2558            {
   2559              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   2560            }
   2561            else
   2562            {
   2563              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   2564            }
   2565          
   2566            if (TIM1_IC2Polarity != TIM1_ICPolarity_Rising)
   2567            {
   2568              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   2569            }
   2570            else
   2571            {
   2572              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   2573            }
   2574            /* Set the encoder Mode */
   2575            TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(TIM1_SMCR_MSM | TIM1_SMCR_TS)) | (uint8_t) TIM1_EncoderMode);
   2576          
   2577            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2578            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_CCxS))  | (uint8_t) CCMR_TIxDirect_Set);
   2579            TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_CCxS)) | (uint8_t) CCMR_TIxDirect_Set);
   2580          
   2581          }
   2582          
   2583          /**
   2584            * @brief  Enables or Disables the TIM�s Hall sensor interface.
   2585            * @param  NewState : The new state of the TIM1 Hall sensor interface.
   2586            *          This parameter can be ENABLE or DISABLE
   2587            * @retval None
   2588            */
   2589          void TIM1_SelectHallSensor(FunctionalState NewState)
   2590          {
   2591            /* Check the parameters */
   2592            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2593          
   2594            /* Set or Reset the TI1S Bit */
   2595            if (NewState != DISABLE)
   2596            {
   2597              TIM1->CR2 |= TIM1_CR2_TI1S;
   2598            }
   2599            else
   2600            {
   2601              TIM1->CR2 &= (uint8_t)(~TIM1_CR2_TI1S);
   2602            }
   2603          }
   2604          
   2605          /**
   2606            * @}
   2607            */
   2608          
   2609          /**
   2610            * @brief  Configure the TI1 as Input.
   2611            * @param  TIM1_ICPolarity  The Input Polarity.
   2612            *          This parameter can be one of the following values:
   2613            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2614            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2615            * @param  TIM1_ICSelection specifies the input to be used.
   2616            *          This parameter can be one of the following values:
   2617            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input 1 is selected to be connected to IC1.
   2618            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input 1 is selected to be connected to IC2.
   2619            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2620            *          This parameter must be a value between 0x00 and 0x0F.
   2621            * @retval None
   2622            */
   2623          static void TI1_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2624          {
   2625          
   2626            /* Disable the Channel 1: Reset the CCE Bit */
   2627            TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1E);
   2628          
   2629            /* Select the Input and set the filter */
   2630            TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2631                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   2632          
   2633          
   2634          
   2635            /* Select the Polarity */
   2636            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   2637            {
   2638              TIM1->CCER1 |= TIM1_CCER1_CC1P;
   2639            }
   2640            else
   2641            {
   2642              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
   2643            }
   2644          
   2645            /* Set the CCE Bit */
   2646            TIM1->CCER1 |=  TIM1_CCER1_CC1E;
   2647          }
   2648          
   2649          /**
   2650            * @brief  Configure the TI2 as Input.
   2651            * @param  TIM1_ICPolarity  The Input Polarity.
   2652            *          This parameter can be one of the following values:
   2653            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2654            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2655            * @param  TIM1_ICSelection specifies the input to be used.
   2656            *          This parameter can be one of the following values:
   2657            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input 2 is selected to be connected to IC2.
   2658            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input 2 is selected to be connected to IC1.
   2659            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2660            *          This parameter must be a value between 0x00 and 0x0F.
   2661            * @retval None
   2662            */
   2663          static void TI2_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2664          {
   2665            /* Disable the Channel 2: Reset the CCE Bit */
   2666            TIM1->CCER1 &=  (uint8_t)(~TIM1_CCER1_CC2E);
   2667          
   2668            /* Select the Input and set the filter */
   2669            TIM1->CCMR2  = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2670                                     | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   2671            /* Select the Polarity */
   2672            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   2673            {
   2674              TIM1->CCER1 |= TIM1_CCER1_CC2P;
   2675            }
   2676            else
   2677            {
   2678              TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
   2679            }
   2680            /* Set the CCE Bit */
   2681            TIM1->CCER1 |=  TIM1_CCER1_CC2E;
   2682          }
   2683          
   2684          /**
   2685            * @brief  Configure the TI3 as Input.
   2686            * @param  TIM1_ICPolarity  The Input Polarity.
   2687            *          This parameter can be one of the following values:
   2688            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2689            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2690            * @param  TIM1_ICSelection specifies the input to be used.
   2691            *          This parameter can be one of the following values:
   2692            *            @arg TIM1_ICSelection_DirectTI: TIM1 Input 3 is selected to
   2693            *                         be connected to IC3.
   2694            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2695            *          This parameter must be a value between 0x00 and 0x0F.
   2696            * @retval None
   2697            */
   2698          static void TI3_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2699          {
   2700            /* Disable the Channel 3: Reset the CCE Bit */
   2701            TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC3E);
   2702          
   2703            /* Select the Input and set the filter */
   2704            TIM1->CCMR3 = (uint8_t)((uint8_t)(TIM1->CCMR3 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2705                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   2706          
   2707            /* Select the Polarity */
   2708            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   2709            {
   2710              TIM1->CCER2 |= TIM1_CCER2_CC3P;
   2711            }
   2712            else
   2713            {
   2714              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC3P);
   2715            }
   2716            /* Set the CCE Bit */
   2717            TIM1->CCER2 |=  TIM1_CCER2_CC3E;
   2718          }
   2719          
   2720          /**
   2721            * @brief  Configure the TI4 as Input.
   2722            * @param  TIM1_ICPolarity  The Input Polarity.
   2723            *          This parameter can be one of the following values:
   2724            *            @arg TIM1_ICPolarity_Rising: Input capture polarity rising
   2725            *            @arg TIM1_ICPolarity_Falling: Input capture polarity falling
   2726            * @param  TIM1_ICSelection specifies the input to be used.
   2727            *          This parameter can be one of the following values:
   2728            *            @arg TIM1_ICSelection_IndirectTI: TIM1 Input 4 is selected to be connected to IC3.
   2729            * @param  TIM1_ICFilter Specifies the Input Capture Filter.
   2730            *          This parameter must be a value between 0x00 and 0x0F.
   2731            * @retval None
   2732            */
   2733          static void TI4_Config(uint8_t TIM1_ICPolarity, uint8_t TIM1_ICSelection, uint8_t TIM1_ICFilter)
   2734          {
   2735          
   2736            /* Disable the Channel 4: Reset the CCE Bit */
   2737            TIM1->CCER2 &=  (uint8_t)(~TIM1_CCER2_CC4E);
   2738          
   2739            /* Select the Input and set the filter */
   2740            TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~( TIM1_CCMR_CCxS | TIM1_CCMR_ICxF)))
   2741                                    | (uint8_t)(( (TIM1_ICSelection)) | ((uint8_t)( TIM1_ICFilter << 4))));
   2742          
   2743            /* Select the Polarity */
   2744            if (TIM1_ICPolarity != TIM1_ICPolarity_Rising)
   2745            {
   2746              TIM1->CCER2 |= TIM1_CCER2_CC4P;
   2747            }
   2748            else
   2749            {
   2750              TIM1->CCER2 &= (uint8_t)(~TIM1_CCER2_CC4P);
   2751            }
   2752          
   2753            /* Set the CCE Bit */
   2754            TIM1->CCER2 |=  TIM1_CCER2_CC4E;
   2755          }
   2756          
   2757          
   2758          /**
   2759            * @}
   2760            */ 
   2761          
   2762          /**
   2763            * @}
   2764            */ 
   2765            
   2766          /**
   2767            * @}
   2768            */
   2769          
   2770          /**
   2771            * @}
   2772            */
   2773          
   2774          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      15  ?Subroutine0
      22  ?Subroutine1
      12  ?Subroutine10
      11  ?Subroutine11
      15  ?Subroutine2
      15  ?Subroutine3
      12  ?Subroutine4
      11  ?Subroutine5
      12  ?Subroutine6
      11  ?Subroutine7
      12  ?Subroutine8
      31  ?Subroutine9
      13  TIM1_ARRPreloadConfig
      21  TIM1_BDTRConfig
      13  TIM1_CCPreloadControl
      67  TIM1_CCxCmd
      49  TIM1_CCxNCmd
      15  TIM1_ClearFlag
       5  TIM1_ClearITPendingBit
      13  TIM1_ClearOC1Ref
      13  TIM1_ClearOC2Ref
      13  TIM1_ClearOC3Ref
      13  TIM1_ClearOC4Ref
      13  TIM1_Cmd
      13  TIM1_CounterModeConfig
      13  TIM1_CtrlPWMOutputs
      17  TIM1_DMACmd
       9  TIM1_DMAConfig
     153  TIM1_DeInit
      13  TIM1_ETRClockMode1Config
       9  TIM1_ETRClockMode2Config
       5  TIM1_ETRConfig
      61  TIM1_EncoderInterfaceConfig
       7  TIM1_ForcedOC1Config
       7  TIM1_ForcedOC2Config
       7  TIM1_ForcedOC3Config
       4  TIM1_GenerateEvent
      13  TIM1_GetCapture1
      13  TIM1_GetCapture2
      13  TIM1_GetCapture3
      13  TIM1_GetCapture4
      13  TIM1_GetCounter
      38  TIM1_GetFlagStatus
      33  TIM1_GetITStatus
      22  TIM1_GetPrescaler
     169  TIM1_ICInit
      17  TIM1_ITConfig
       9  TIM1_InternalClockConfig
      13  TIM1_OC1FastConfig
      65  TIM1_OC1Init
      13  TIM1_OC1NPolarityConfig
      13  TIM1_OC1PolarityConfig
      13  TIM1_OC1PreloadConfig
      13  TIM1_OC2FastConfig
      91  TIM1_OC2Init
      13  TIM1_OC2NPolarityConfig
      13  TIM1_OC2PolarityConfig
      13  TIM1_OC2PreloadConfig
      13  TIM1_OC3FastConfig
      65  TIM1_OC3Init
      13  TIM1_OC3NPolarityConfig
      13  TIM1_OC3PolarityConfig
      13  TIM1_OC3PreloadConfig
      13  TIM1_OC4PreloadConfig
     166  TIM1_PWMIConfig
      21  TIM1_PrescalerConfig
      13  TIM1_SelectCCDMA
      13  TIM1_SelectCOM
      13  TIM1_SelectHallSensor
      13  TIM1_SelectInputTrigger
      13  TIM1_SelectMasterSlaveMode
      11  TIM1_SelectOCREFClear
      34  TIM1_SelectOCxM
      13  TIM1_SelectOnePulseMode
      13  TIM1_SelectOutputTrigger
      13  TIM1_SelectSlaveMode
       7  TIM1_SetAutoreload
      14  TIM1_SetCompare1
      14  TIM1_SetCompare2
      14  TIM1_SetCompare3
      14  TIM1_SetCompare4
      14  TIM1_SetCounter
      13  TIM1_SetIC1Prescaler
      13  TIM1_SetIC2Prescaler
      13  TIM1_SetIC3Prescaler
      13  TIM1_SetIC4Prescaler
      90  TIM1_TIxExternalClockConfig
      38  TIM1_TimeBaseInit
      13  TIM1_UpdateDisableConfig
      13  TIM1_UpdateRequestConfig

 
 2 107 bytes in section .far_func.text
 
 2 107 bytes of CODE memory

Errors: none
Warnings: none
