###############################################################################
#
# IAR C/C++ Compiler V2.10.4.157 for STM8                 16/May/2017  16:55:09
# Copyright 2010-2015 IAR Systems AB.
#
#    Source file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_flash.c
#    Command line =  
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_flash.c
#        -e -Oh --debug --code_model medium --data_model medium -o
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\ --dlib_config
#        "F:\Embedded Workbench 7.0\stm8\LIB\dlstm8mmn.h" -lcN
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\BSP\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\USER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Memory\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\AK4637\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\CC8530\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\Serial\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\OLED\ -I
#        H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\inc\ -I
#        H:\ProjectFile\AirTone\AirToneMLL|DRIVER\STM8L152C6\src\ --vregs 16
#    List file    =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\List\stm8l15x_flash.lst
#    Object file  =  
#        H:\ProjectFile\AirTone\AirToneMLL\Debug\Obj\stm8l15x_flash.o
#
###############################################################################

H:\ProjectFile\AirTone\AirToneMLL\DRIVER\STM8L152C6\src\stm8l15x_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm8l15x_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.6.1
      6            * @date    30-September-2014
      7            * @brief   This file provides all the Flash firmware functions. These functions 
      8            *          can be executed from Internal FLASH or Internal RAM memories.
      9            *            - FLASH program and Data EEPROM memories interface configuration
     10            *            - FLASH program and Data EEPROM memories Programming
     11            *            - Option Bytes Programming
     12            *            - Interrupts and flags management
     13            *            - Functions to be executed from RAM
     14            *               
     15            *  @verbatim
     16            *  
     17            *          ===================================================================
     18            *                                 How to use this driver
     19            *          ===================================================================
     20            *                           
     21            *          This driver provides functions to configure and program the Flash 
     22            *          memory of all STM8L15x devices
     23            *          These functions are split in 4 groups
     24            * 
     25            *           1. FLASH program and Data EEPROM memories interface configuration 
     26            *              functions: this group includes the management of the following 
     27            *              features:
     28            *                    - Set the fixed programming time
     29            *                    - Configure the power state during WFI mode
     30            *                    - Configure the power state during run, low power run and
     31            *                      WFE modes (should be executed from internal RAM) 
     32            *  
     33            *           2. FLASH program and Data EEPROM memories Programming functions: 
     34            *              this group includes all needed functions to erase and program 
     35            *              the FLASH program or the Data EEPROM memory.
     36            *                    - Lock and Unlock the Flash program interface.
     37            *                    - Lock and Unlock the Data EEPROM interface.  
     38            *                    - Erase function: Erase Byte, Erase Word and Erase Block 
     39            *                      (should be executed from internal RAM). 
     40            *                    - Program functions: Program Byte, Program Word, 
     41            *                      Program Block (should be executed from internal RAM) 
     42            *                      and Fast Program Block (should be executed from internal
     43            *                      RAM).
     44            *    
     45            *           3. FLASH Option Bytes Programming functions: this group includes 
     46            *              all needed functions to:
     47            *                    - Program/erase the user option Bytes 
     48            *                    - Get the Read Out Protection status (ROP option byte)
     49            *                    - Get the User Boot Code size (UBC option byte)
     50            *                    - Get the Protected Code size (PCODE option byte) 
     51            *                    
     52            *            Note: Option byte programming is very similar to data EEPROM byte
     53            *                  programming.          
     54            *  
     55            *           4. FLASH Interrupts and flag management functions: this group 
     56            *              includes all needed functions to:
     57            *                    - Enable/Disable the flash interrupt sources
     58            *                    - Get flags status
     59            *                    - Wait for last flash operation(can be executed from 
     60            *                      internal RAM)
     61            *                        
     62            *           5. Functions to be executed from RAM: this group includes the functions
     63            *              that should be executed from RAM and provides description on how 
     64            *              to handle this with the different supported toolchains
     65            *   
     66            *  The table below lists the functions that can be executed from RAM.
     67            *  
     68            *   +--------------------------------------------------------------------------------|
     69            *   |   Functions prototypes      |    RAM execution            |     Comments       |
     70            *   ---------------------------------------------------------------------------------|
     71            *   |                             | Mandatory in case of block  | Can be executed    |
     72            *   | FLASH_WaitForLastOperation  | Operation:                  | from Flash in case |
     73            *   |                             | - Block programming         | of byte and word   |
     74            *   |                             | - Block erase               | Operations         |
     75            *   |--------------------------------------------------------------------------------|
     76            *   | FLASH_PowerRunModeConfig    |       Exclusively           | useless from Flash |
     77            *   |--------------------------------------------------------------------------------|
     78            *   | FLASH_GetPowerStatus        |       Exclusively           | useless from Flash |
     79            *   |--------------------------------------------------------------------------------|
     80            *   | FLASH_ProgramBlock          |       Exclusively           | useless from Flash |
     81            *   |--------------------------------------------------------------------------------|
     82            *   | FLASH_EraseBlock            |       Exclusively           | useless from Flash |
     83            *   |--------------------------------------------------------------------------------|
     84            *  
     85            *  To be able to execute functions from RAM several steps have to be followed.
     86            *   These steps may differ from one toolchain to another.
     87            *   A detailed description is available below within this driver.
     88            *   You can also refer to the Flash_DataProgram example provided within the
     89            *   STM8L15x_StdPeriph_Lib package.
     90            * 
     91            *  @endverbatim
     92            *                      
     93            ******************************************************************************
     94            * @attention
     95            *
     96            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     97            *
     98            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     99            * You may not use this file except in compliance with the License.
    100            * You may obtain a copy of the License at:
    101            *
    102            *        http://www.st.com/software_license_agreement_liberty_v2
    103            *
    104            * Unless required by applicable law or agreed to in writing, software 
    105            * distributed under the License is distributed on an "AS IS" BASIS, 
    106            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    107            * See the License for the specific language governing permissions and
    108            * limitations under the License.
    109            *
    110            ******************************************************************************
    111            */
    112          /* Includes ------------------------------------------------------------------*/
    113          #include "stm8l15x_flash.h"
    114          
    115          /** @addtogroup STM8L15x_StdPeriph_Driver
    116            * @{
    117            */
    118          
    119          /** @defgroup FLASH 
    120            * @brief FLASH driver modules
    121            * @{
    122            */
    123            
    124          /* Private typedef -----------------------------------------------------------*/
    125          /* Private define ------------------------------------------------------------*/
    126          /** @defgroup FLASH_Private_Define
    127            * @{
    128            */ 
    129          #define FLASH_CLEAR_BYTE   ((uint8_t)0x00)
    130          #define FLASH_SET_BYTE     ((uint8_t)0xFF)
    131          #define OPERATION_TIMEOUT  ((uint16_t)0xFFFF)
    132          /**
    133            * @}
    134            */
    135          /* Private macro -------------------------------------------------------------*/
    136          /* Private variables ---------------------------------------------------------*/
    137          /* Private function prototypes -----------------------------------------------*/
    138          /* Private functions ---------------------------------------------------------*/
    139           
    140          /** @defgroup FLASH_Private_Functions
    141            * @{
    142            */ 
    143          
    144          /** @defgroup FLASH_Group1 FLASH program and Data EEPROM memories Interface 
    145            *                        configuration functions
    146            *  @brief   FLASH Interface configuration functions 
    147           *
    148          @verbatim   
    149           ===============================================================================
    150                FLASH program and Data EEPROM memories interface configuration functions
    151           ===============================================================================  
    152          
    153             The FLASH program and Data EEPROM memories interface configuration functions,
    154              includes the following functions:
    155          		
    156             - FLASH_ProgramTime_T FLASH_GetProgrammingTime(void);
    157             - void FLASH_SetProgrammingTime(FLASH_ProgramTime_T FLASH_ProgTime);
    158          	 - void FLASH_PowerWaitModeConfig(FLASH_Power_T FLASH_Power);
    159          
    160             These functions don't need the unlock sequence.
    161          
    162          @endverbatim
    163            * @{
    164            */
    165          	
    166          /**
    167            * @brief  Sets the fixed programming time
    168            * @param  FLASH_ProgTime : Indicates the programming time to be fixed
    169            *          This parameter can be one of the following values:
    170            *            @arg FLASH_ProgramTime_Standard: Standard programming time fixed at 1/2 tprog
    171            *            @arg FLASH_ProgramTime_TProg: Programming time fixed at tprog 
    172            * @retval None
    173            */
    174          void FLASH_SetProgrammingTime(FLASH_ProgramTime_T FLASH_ProgTime)
    175          {
    176            /* Check parameter */
    177            assert_param(IS_FLASH_PROGRAM_TIME(FLASH_ProgTime));
    178            
    179            FLASH->CR1 &= (uint8_t)(~FLASH_CR1_FIX);
    180            FLASH->CR1 |= (uint8_t)FLASH_ProgTime;
    181          }
    182          
    183          /**
    184            * @brief  Returns the fixed programming time
    185            * @param  None
    186            * @retval Fixed programming time value
    187            */
    188          FLASH_ProgramTime_T FLASH_GetProgrammingTime(void)
    189          {
    190            return((FLASH_ProgramTime_T)(FLASH->CR1 & FLASH_CR1_FIX));
    191          }
    192          
    193          /**
    194            * @brief  Configures the power state for Flash program and data EEPROM during
    195            *          wait for interrupt mode
    196            * @param  FLASH_Power: The power state for Flash program and data EEPROM during
    197            *         wait for interrupt mode
    198            *          This parameter can be one of the following values:
    199            *            @arg FLASH_Power_IDDQ: Flash program and data EEPROM in IDDQ
    200            *            @arg FLASH_Power_On: Flash program and data EEPROM not in IDDQ 
    201            * @retval None
    202            */
    203          void FLASH_PowerWaitModeConfig(FLASH_Power_T FLASH_Power)
    204          {
    205            /* Check parameter */
    206            assert_param(IS_FLASH_POWER(FLASH_Power));
    207          
    208            /* Flash program and data EEPROM in IDDQ during wait for interrupt mode*/
    209            if(FLASH_Power != FLASH_Power_On)
    210            {
    211              FLASH->CR1 |= (uint8_t)FLASH_CR1_WAITM;
    212            }
    213            /* Flash program and data EEPROM not in IDDQ during wait for interrupt mode*/
    214            else
    215            {
    216              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_WAITM);
    217            }
    218          }
    219          
    220          /**
    221            * @}
    222            */
    223          
    224          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    225           *  @brief   FLASH Memory Programming functions
    226           *
    227          @verbatim   
    228           ===============================================================================
    229                                FLASH Memory Programming functions
    230           ===============================================================================  
    231          
    232             The FLASH Memory Programming functions, includes the following functions:
    233              - void FLASH_DeInit(void);
    234              - void FLASH_Unlock(FLASH_MemType_T FLASH_MemType);
    235              - void FLASH_Lock(FLASH_MemType_T FLASH_MemType);
    236              - void FLASH_ProgramByte(uint32_t Address, uint8_t Data);
    237              - void FLASH_EraseByte(uint32_t Address);
    238              - void FLASH_ProgramWord(uint32_t Address, uint32_t Data);
    239              - uint8_t FLASH_ReadByte(uint32_t Address);
    240             
    241             Any operation of erase or program should follow these steps:
    242          
    243             1. Call the FLASH_Unlock(FLASH_MemType) function to enable the memory access
    244          
    245             2. Call the desired function to erase or program data
    246          
    247             3. Call the FLASH_Lock() function to disable the memory access 
    248               (it is recommended to protect the FLASH memory against possible unwanted operation)
    249          
    250          @endverbatim
    251            * @{
    252            */
    253            
    254          /**
    255            * @brief  Deinitializes the FLASH registers to their default reset values.
    256            * @param  None
    257            * @retval None
    258            */
    259          void FLASH_DeInit(void)
    260          {
    261            FLASH->CR1 = FLASH_CR1_RESET_VALUE;
    262            FLASH->CR2 = FLASH_CR2_RESET_VALUE;
    263            FLASH->IAPSR = FLASH_IAPSR_RESET_VALUE;
    264            (void) FLASH->IAPSR; /* Reading of this register causes the clearing of status flags */
    265          }
    266            
    267          /**
    268            * @brief  Unlocks the program or data EEPROM memory
    269            * @param  FLASH_MemType : Memory type to unlock
    270            *          This parameter can be one of the following values:
    271            *            @arg FLASH_MemType_Program: Program memory
    272            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    273            * @retval None
    274            */
    275          void FLASH_Unlock(FLASH_MemType_T FLASH_MemType)
    276          {
    277            /* Check parameter */
    278            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    279            
    280            /* Unlock program memory */
    281            if(FLASH_MemType == FLASH_MemType_Program)
    282            {
    283              FLASH->PUKR = FLASH_RASS_KEY1;
    284              FLASH->PUKR = FLASH_RASS_KEY2;
    285            }
    286            
    287            /* Unlock data memory */
    288            if(FLASH_MemType == FLASH_MemType_Data)
    289            {
    290              FLASH->DUKR = FLASH_RASS_KEY2; /* Warning: keys are reversed on data memory !!! */
    291              FLASH->DUKR = FLASH_RASS_KEY1;
    292            }
    293          }
    294          
    295          /**
    296            * @brief  Locks the program or data EEPROM memory
    297            * @param  FLASH_MemType : Memory type
    298            *          This parameter can be one of the following values:
    299            *            @arg FLASH_MemType_Program: Program memory
    300            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    301            * @retval None
    302            */
    303          void FLASH_Lock(FLASH_MemType_T FLASH_MemType)
    304          {
    305            /* Check parameter */
    306            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    307            
    308            /* Lock memory */
    309            FLASH->IAPSR &= (uint8_t)FLASH_MemType;
    310          }
    311          
    312          /**
    313            * @brief  Programs one byte in program or data EEPROM memory
    314            * @param  Address : Address where the byte will be programmed
    315            * @param  Data : Value to be programmed
    316            * @retval None
    317            */
    318          void FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    319          {
    320            /* Check parameters */
    321            assert_param(IS_FLASH_ADDRESS(Address));
    322            
    323            *(PointerAttr uint8_t*) (MemoryAddressCast)Address = Data;
    324          }
    325          
    326          /**
    327            * @brief  Erases one byte in the program or data EEPROM memory
    328            * @param  Address : Address of the byte to erase
    329            * @retval None
    330            */
    331          void FLASH_EraseByte(uint32_t Address)
    332          {
    333            /* Check parameter */
    334            assert_param(IS_FLASH_ADDRESS(Address));
    335            
    336            *(PointerAttr uint8_t*) (MemoryAddressCast)Address = FLASH_CLEAR_BYTE; /* Erase byte */
    337          }
    338          
    339          /**
    340            * @brief  Programs one word (4 bytes) in program or data EEPROM memory
    341            * @param  Address : The address where the data will be programmed
    342            * @param  Data : Value to be programmed
    343            * @retval None
    344            */
    345          void FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    346          {
    347            /* Check parameters */
    348            assert_param(IS_FLASH_ADDRESS(Address));
    349            /* Enable Word Write Once */
    350            FLASH->CR2 |= FLASH_CR2_WPRG;
    351            
    352            /* Write one byte - from lowest address*/
    353            *((PointerAttr uint8_t*)(MemoryAddressCast)Address)       = *((uint8_t*)(&Data));   
    354            /* Write one byte*/
    355            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 1) = *((uint8_t*)(&Data) + 1);
    356            /* Write one byte*/
    357            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 2) = *((uint8_t*)(&Data) + 2); 
    358            /* Write one byte - from higher address*/
    359            *(((PointerAttr uint8_t*)(MemoryAddressCast)Address) + 3) = *((uint8_t*)(&Data) + 3); 
    360          }
    361          
    362          /**
    363            * @brief  Reads one byte from flash memory
    364            * @param  Address : Address to read
    365            * @retval Value of the byte
    366            */
    367          uint8_t FLASH_ReadByte(uint32_t Address)
    368          {
    369            /* Read byte */
    370            return(*(PointerAttr uint8_t *) (MemoryAddressCast)Address);
    371          }
    372          /**
    373            * @}
    374            */
    375          
    376          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    377           *  @brief   Option Bytes Programming functions 
    378           *
    379          @verbatim   
    380           ===============================================================================
    381                                  Option Bytes Programming functions
    382           ===============================================================================  
    383          
    384             The FLASH_Option Bytes Programming_functions, includes the following functions:
    385          
    386             - void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data);
    387             - void FLASH_EraseOptionByte(uint16_t Address);
    388             - FunctionalState FLASH_GetReadOutProtectionStatus(void);
    389             - uint16_t FLASH_GetBootSize(void);
    390             - uint16_t FLASH_GetCodeSize(void);
    391             
    392             Any operation of erase or program should follow these steps:
    393             
    394             1. Call the FLASH_Unlock(FLASH_MemType_Data); function to enable the Flash 
    395                option control register access
    396             
    397             2. Call the desired function to erase or program data
    398                - void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data); => to program
    399                  the option byte Address with the desired Data value.  
    400                - void FLASH_EraseOptionByte(uint16_t Address); => to erase the option byte
    401                  Address. 			 
    402             
    403             3. Once all needed option bytes to be programmed are correctly written, call the
    404                FLASH_Lock(FLASH_MemType_Data) to disable the memory access ( It is recommended to
    405                protect the FLASH memory against possible unwanted operation)
    406          
    407          @endverbatim
    408            * @{
    409            */
    410            
    411          /**
    412            * @brief  Programs option byte
    413            * @param  Address : option byte address to program
    414            * @param  Data : Value to write
    415            * @retval None
    416            */
    417          void FLASH_ProgramOptionByte(uint16_t Address, uint8_t Data)
    418          {
    419            /* Check parameter */
    420            assert_param(IS_OPTION_BYTE_ADDRESS(Address));
    421          
    422            /* Enable write access to option bytes */
    423            FLASH->CR2 |= FLASH_CR2_OPT;
    424          
    425            /* Program option byte and his complement */
    426            *((PointerAttr uint8_t*)Address) = Data;
    427          
    428            FLASH_WaitForLastOperation(FLASH_MemType_Program);
    429          
    430            /* Disable write access to option bytes */
    431            FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
    432          }
    433          
    434          /**
    435            * @brief  Erases option byte
    436            * @param  Address : Option byte address to erase
    437            * @retval None
    438            */
    439          void FLASH_EraseOptionByte(uint16_t Address)
    440          {
    441            /* Check parameter */
    442            assert_param(IS_OPTION_BYTE_ADDRESS(Address));
    443          
    444            /* Enable write access to option bytes */
    445            FLASH->CR2 |= FLASH_CR2_OPT;
    446          
    447            /* Erase option byte and his complement */
    448            *((PointerAttr uint8_t*)Address) = FLASH_CLEAR_BYTE;
    449          
    450            FLASH_WaitForLastOperation(FLASH_MemType_Program);
    451          
    452            /* Disable write access to option bytes */
    453            FLASH->CR2 &= (uint8_t)(~FLASH_CR2_OPT);
    454          }
    455          
    456          /**
    457            * @brief  Returns the FLASH Read Out Protection Status.
    458            * @param  None
    459            * @retval FLASH Read Out Protection Status.
    460            *         This parameter can be a ENABLE or DISABLE
    461            */
    462          FunctionalState FLASH_GetReadOutProtectionStatus(void)
    463          {
    464            FunctionalState state = DISABLE;
    465            
    466            if(OPT->ROP == FLASH_READOUTPROTECTION_KEY)
    467            {
    468              /* The status of the Flash read out protection is enabled*/
    469              state =  ENABLE;
    470            }
    471            else
    472            {
    473              /* The status of the Flash read out protection is disabled*/
    474              state =  DISABLE;
    475            }
    476            
    477            return state;
    478          }
    479          
    480          /**
    481            * @brief  Returns the Boot memory size in bytes
    482            * @param  None
    483            * @retval Boot memory size in bytes
    484            */
    485          uint16_t FLASH_GetBootSize(void)
    486          {
    487            uint16_t temp = 0;
    488            
    489            /* Calculates the number of bytes */
    490            temp = (uint16_t)((uint16_t)OPT->UBC * (uint16_t)128);
    491            
    492            /* Correction because size upper 8kb doesn't exist */
    493            if(OPT->UBC > 0x7F)
    494            {
    495              temp = 8192;
    496            }
    497            
    498            /* Return value */
    499            return(temp);
    500          }
    501          
    502          /**
    503           *
    504            * @brief  Returns the Code Area size in bytes
    505            * @param  None
    506            * @retval Code Area size in bytes
    507            */
    508          uint16_t FLASH_GetCodeSize(void)
    509          {
    510            uint16_t temp = 0;
    511            
    512            /* Calculates the number of bytes */
    513            temp = (uint16_t)((uint16_t)OPT->PCODESIZE * (uint16_t)128);
    514            
    515            /* Correction because size upper of 8kb doesn't exist */
    516            if(OPT->PCODESIZE > 0x7F)
    517            {
    518              temp = 8192;
    519            }
    520            
    521            /* Return value */
    522            return(temp);
    523          }
    524          
    525          /**
    526            * @}
    527            */
    528          
    529          /** @defgroup FLASH_Group4 Interrupts and flags management functions
    530           *  @brief   Interrupts and flags management functions
    531           *
    532          @verbatim   
    533           ===============================================================================
    534                            Interrupts and flags management functions
    535           ===============================================================================  
    536          
    537          @endverbatim
    538            * @{
    539            */
    540            
    541          /**
    542            * @brief  Enables or Disables the Flash interrupt mode
    543            * @param  NewState : The new state of the flash interrupt mode
    544              *         This parameter can be: ENABLE or DISABLE.
    545            * @retval None
    546            */
    547          void FLASH_ITConfig(FunctionalState NewState)
    548          {
    549            /* Check parameter */
    550            assert_param(IS_FUNCTIONAL_STATE(NewState));
    551            
    552            if(NewState != DISABLE)
    553            {
    554              /* Enables the interrupt sources */
    555              FLASH->CR1 |= FLASH_CR1_IE;
    556            }
    557            else
    558            {
    559              /* Disables the interrupt sources */
    560              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_IE);
    561            }
    562          }
    563          
    564          /**
    565            * @brief  Checks whether the specified FLASH flag is set or not.
    566            * @param  FLASH_FLAG : specifies the Flash Flag to check.
    567            *          This parameter can be one of the following values:
    568            *            @arg FLASH_FLAG_HVOFF: End of high voltage
    569            *            @arg FLASH_FLAG_DUL: Data EEPROM unlocked
    570            *            @arg FLASH_FLAG_EOP: End of programming (write or erase operation)
    571            *            @arg FLASH_FLAG_PUL: Flash Program memory unlocked
    572            *            @arg FLASH_FLAG_WR_PG_DIS: Write attempted to protected page       
    573            * @retval Indicates the state of the Flash_FLAG.
    574            *         This parameter can be SET or RESET
    575            */
    576          FlagStatus FLASH_GetFlagStatus(FLASH_FLAG_T FLASH_FLAG)
    577          {
    578            FlagStatus status = RESET;
    579            assert_param(IS_FLASH_FLAGS(FLASH_FLAG));
    580            
    581            /* Check the status of the specified flash flag*/
    582            if((FLASH->IAPSR  & (uint8_t)FLASH_FLAG) != (uint8_t)RESET)
    583            {
    584              status = SET; /* Flash_FLAG is set*/
    585            }
    586            else
    587            {
    588              status = RESET; /* Flash_FLAG is reset*/
    589            }
    590            
    591            /* Return the Flash_FLAG status*/
    592            return status;
    593          }
    594          
    595          /**
    596            * @}
    597            */ 
    598            
    599          /** @defgroup FLASH_Group5 Functions to be executed from RAM
    600           *  @brief  Functions to be executed from RAM
    601           *
    602          @verbatim   
    603           ===============================================================================
    604                                   Functions to be executed from RAM
    605           ===============================================================================  
    606           
    607           All the functions defined below must be executed from RAM exclusively, except
    608           for the FLASH_WaitForLastOperation function which can be executed from Flash.
    609          
    610           Steps of the execution from RAM differs from one toolchain to another:
    611           - For Cosmic Compiler:
    612              1- Define a segment FLASH_CODE by the mean of " #pragma section (FLASH_CODE)".
    613              This segment is defined in the stm8l15x_flash.c file.
    614            2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l15x.h file,
    615              or define it in Cosmic compiler preprocessor to enable the FLASH_CODE segment
    616             definition.
    617            3- In STVD Select Project\Settings\Linker\Category "input" and in the RAM section
    618              add the FLASH_CODE segment with "-ic" options.
    619            4- In main.c file call the _fctcpy() function with first segment character as 
    620              parameter "_fctcpy('F');" to load the declared moveable code segment
    621              (FLASH_CODE) in RAM before execution.
    622            5- By default the _fctcpy function is packaged in the Cosmic machine library,
    623              so the function prototype "int _fctcopy(char name);" must be added in main.c
    624              file.
    625          
    626            - For Raisonance Compiler
    627             1- Use the inram keyword in the function declaration to specify that it can be
    628              executed from RAM.
    629              This is done within the stm8l15x_flash.c file, and it's conditioned by 
    630              RAM_EXECUTION definition.
    631             2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l15x.h file, or 
    632             define it in Raisonance compiler preprocessor to enable the access for the 
    633             inram functions.
    634             3- An inram function code is copied from Flash to RAM by the C startup code. 
    635             In some applications, the RAM area where the code was initially stored may be
    636             erased or corrupted, so it may be desirable to perform the copy again. 
    637             Depending on the application memory model, the memcpy() or fmemcpy() functions
    638             should be used to perform the copy.
    639                � In case your project uses the SMALL memory model (code smaller than 64K),
    640                 memcpy()function is recommended to perform the copy
    641                � In case your project uses the LARGE memory model, functions can be 
    642                everywhere in the 24-bits address space (not limited to the first 64KB of
    643                code), In this case, the use of memcpy() function will not be appropriate,
    644                you need to use the specific fmemcpy() function (which copies objects with
    645                24-bit addresses).
    646                - The linker automatically defines 2 symbols for each inram function:
    647                     � __address__functionname is a symbol that holds the Flash address 
    648                     where the given function code is stored.
    649                     � __size__functionname is a symbol that holds the function size in bytes.
    650               And we already have the function address (which is itself a pointer)
    651            4- In main.c file these two steps should be performed for each inram function:
    652               � Import the "__address__functionname" and "__size__functionname" symbols
    653                 as global variables:
    654                   extern int __address__functionname; // Symbol holding the flash address
    655                   extern int __size__functionname;    // Symbol holding the function size
    656               � In case of SMALL memory model use, Call the memcpy() function to copy the
    657                inram function to the RAM destination address:
    658                          memcpy(functionname, // RAM destination address
    659                                (void*)&__address__functionname, // Flash source address
    660                                (int)&__size__functionname); // Code size of the function
    661               � In case of LARGE memory model use, call the fmemcpy() function to copy 
    662               the inram function to the RAM destination address:
    663                           memcpy(functionname, // RAM destination address
    664                                (void @far*)&__address__functionname, // Flash source address
    665                                (int)&__size__functionname); // Code size of the function
    666          
    667           - For IAR Compiler:
    668              1- Use the __ramfunc keyword in the function declaration to specify that it 
    669              can be executed from RAM.
    670              This is done within the stm8l15x_flash.c file, and it's conditioned by 
    671              RAM_EXECUTION definition.
    672              2- Uncomment the "#define RAM_EXECUTION  (1)" line in the stm8l15x.h file, or 
    673             define it in IAR compiler preprocessor to enable the access for the 
    674             __ramfunc functions.
    675           
    676           - Note: 
    677              1- Ignore the IAR compiler warnings, these warnings don't impact the FLASH Program/Erase
    678              operations.
    679              The code performing the Flash Program/erase must be executed from RAM; the variables
    680              initializations don't necessary require the execution from RAM, only CR2 registers 
    681              configuration and data programing must be executed from RAM.
    682              2- These warnings depends on IAR compiler: as the code generation is made using many
    683              runtime library functions to keep code size to a minimum.
    684              3- It is recommended to use High Speed Optimization with IAR (-Ohs), in order 
    685              to reduce the runtime library calls in the generated code.
    686          
    687           The Flash_DataProgram example provided within the STM8L15x_StdPeriph_Lib package
    688           details all the steps described above.
    689          
    690          @endverbatim
    691            * @{
    692            */
    693             
    694          /**
    695            * @brief
    696            *******************************************************************************
    697            *                         Execution from RAM enable
    698            *******************************************************************************
    699            *
    700            * To enable execution from RAM you can either uncomment the following define 
    701            * in the stm8l15x.h file or define it in your toolchain compiler preprocessor
    702            * - #define RAM_EXECUTION  (1) 
    703            */
    704          
    705          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    706           #pragma section (FLASH_CODE)
    707          #endif  /* _COSMIC_ && RAM_EXECUTION */
    708          
    709          /**
    710            * @brief  Configures the power state for Flash program and data EEPROM during
    711            *         run, low power run and low power wait modes
    712            * @note   This function must be called and executed from RAM.
    713            * @param  FLASH_Power: power state of the Flash program and data EEPROM
    714            *          This parameter can be one of the following values:
    715            *            @arg FLASH_Power_IDDQ: Flash program and data EEPROM in IDDQ
    716            *            @arg FLASH_Power_On: Flash program and data EEPROM not in IDDQ 
    717            * @retval None
    718            */
    719          IN_RAM(void FLASH_PowerRunModeConfig(FLASH_Power_T FLASH_Power))
    720          {
    721            /* Check parameter */
    722            assert_param(IS_FLASH_POWER(FLASH_Power));
    723            
    724            if(FLASH_Power != FLASH_Power_On)
    725            {
    726              FLASH->CR1 |= (uint8_t)FLASH_CR1_EEPM;
    727            }
    728            else
    729            {
    730              FLASH->CR1 &= (uint8_t)(~FLASH_CR1_EEPM);
    731            }
    732          }
    733          
    734          /**
    735            * @brief  Checks the power status for Flash program and data EEPROM
    736            * @note   This function should be called and executed from RAM.
    737            * @param  None
    738            * @retval Flash program and data EEPROM power status
    739            *         The returned value can be one of the following:
    740            *         - FLASH_PowerStatus_IDDQDuringWaitMode: IDDQ during Wait mode
    741            *         - FLASH_PowerStatus_IDDQDuringRunMode: IDDQ during Run mode
    742            *         - FLASH_PowerStatus_IDDQDuringWaitAndRunModes: IDDQ during Wait/Run mode
    743            *         - FLASH_PowerStatus_On: Powered on during Wait and Run modes
    744            */
    745          IN_RAM(FLASH_PowerStatus_T FLASH_GetPowerStatus(void))
    746          {
    747            return((FLASH_PowerStatus_T)(FLASH->CR1 & (uint8_t)0x0C));
    748          }
    749          
    750          /**
    751            * @brief  Programs a memory block
    752            * @note   This function should be called and executed from RAM.
    753            * @param  FLASH_MemType : The type of memory to program
    754            *          This parameter can be one of the following values:
    755            *            @arg FLASH_MemType_Program: Program memory
    756            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    757            * @param  BlockNum : The block number
    758            * @param  FLASH_ProgMode : The programming mode.
    759            *          This parameter can be one of the following values:
    760            *            @arg FLASH_ProgramMode_Standard: Standard programming mode
    761            *            @arg FLASH_ProgramMode_Fast: Fast programming mode
    762            * @param  Buffer : Pointer to buffer containing source data.
    763            * @retval None.
    764            */
    765          IN_RAM(void FLASH_ProgramBlock(uint16_t BlockNum, FLASH_MemType_T FLASH_MemType,
    766                                  FLASH_ProgramMode_T FLASH_ProgMode, uint8_t *Buffer))
    767          {
    768            uint16_t Count = 0;
    769            uint32_t startaddress = 0;
    770            
    771            /* Check parameters */
    772            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    773            assert_param(IS_FLASH_PROGRAM_MODE(FLASH_ProgMode));
    774            if(FLASH_MemType == FLASH_MemType_Program)
    775            {
    776              assert_param(IS_FLASH_PROGRAM_BLOCK_NUMBER(BlockNum));
    777              startaddress = FLASH_PROGRAM_START_PHYSICAL_ADDRESS;
    778            }
    779            else
    780            {
    781              assert_param(IS_FLASH_DATA_EEPROM_BLOCK_NUMBER(BlockNum));
    782              startaddress = FLASH_DATA_EEPROM_START_PHYSICAL_ADDRESS;
    783            }
    784            
    785            /* Point to the first block address */
    786            startaddress = startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE);
    787            
    788            /* Selection of Standard or Fast programming mode */
    789            if(FLASH_ProgMode == FLASH_ProgramMode_Standard)
    790            {
    791              /* Standard programming mode */
    792              FLASH->CR2 |= FLASH_CR2_PRG;
    793            }
    794            else
    795            {
    796              /* Fast programming mode */
    797              FLASH->CR2 |= FLASH_CR2_FPRG;
    798            }
    799            
    800            /* Copy data bytes from RAM to FLASH memory */
    801            for(Count = 0; Count < FLASH_BLOCK_SIZE; Count++)
    802            {
    803              *((PointerAttr uint8_t*) (MemoryAddressCast)startaddress + Count) = ((uint8_t)(Buffer[Count]));
    804            }
    805          }
    806          
    807          /**
    808            * @brief  Erases a block in the program or data memory.
    809            * @note   This function should be called and executed from RAM.
    810            * @param  BlockNum : Indicates the block number to erase
    811            * @param  FLASH_MemType :  The type of memory to erase
    812            *          This parameter can be one of the following values:
    813            *            @arg FLASH_MemType_Program: Program memory
    814            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    815            * @retval None.
    816            */
    817          IN_RAM(void FLASH_EraseBlock(uint16_t BlockNum, FLASH_MemType_T FLASH_MemType))
    818          {
    819            uint32_t startaddress = 0;
    820          #if defined (STM8L15X_MD) || defined (STM8L15X_MDP) || defined (STM8L15X_LD) || \
    821            defined (STM8L05X_LD_VL) || defined (STM8L05X_MD_VL) || defined (STM8AL31_L_MD)
    822              uint32_t PointerAttr  *pwFlash;
    823            
    824          #elif defined (STM8L15X_HD) || defined (STM8L05X_HD_VL)
    825            uint8_t PointerAttr  *pwFlash;
    826          #endif
    827            
    828            /* Check parameters */
    829            assert_param(IS_FLASH_MEMORY_TYPE(FLASH_MemType));
    830            if(FLASH_MemType == FLASH_MemType_Program)
    831            {
    832              assert_param(IS_FLASH_PROGRAM_BLOCK_NUMBER(BlockNum));
    833              startaddress = FLASH_PROGRAM_START_PHYSICAL_ADDRESS;
    834            }
    835            else
    836            {
    837              assert_param(IS_FLASH_DATA_EEPROM_BLOCK_NUMBER(BlockNum));
    838              startaddress = FLASH_DATA_EEPROM_START_PHYSICAL_ADDRESS;
    839            }
    840            
    841            /* Point to the first block address */
    842          #if defined (STM8L15X_MD) || defined (STM8L15X_MDP)|| defined (STM8L15X_LD) || \
    843            defined (STM8L05X_LD_VL) || defined (STM8L05X_MD_VL) || defined (STM8AL31_L_MD)
    844              pwFlash = (PointerAttr uint32_t *)(uint16_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
    845            
    846          #elif defined (STM8L15X_HD) || defined (STM8L05X_HD_VL)
    847            pwFlash = (PointerAttr uint8_t *)(uint32_t)(startaddress + ((uint32_t)BlockNum * FLASH_BLOCK_SIZE));
    848          #endif
    849            
    850            /* Enable erase block mode */
    851            FLASH->CR2 |= FLASH_CR2_ERASE;
    852            
    853          #if defined (STM8L15X_MD) || defined (STM8L15X_MDP) || defined (STM8L15X_LD) || \
    854            defined (STM8L05X_LD_VL) || defined (STM8L05X_MD_VL) || defined (STM8AL31_L_MD)
    855              *pwFlash = (uint32_t)0;  
    856            
    857          #elif defined (STM8L15X_HD) || defined (STM8L05X_HD_VL)
    858            *pwFlash = (uint8_t)0;
    859            *(pwFlash + 1) = (uint8_t)0;
    860            *(pwFlash + 2) = (uint8_t)0;
    861            *(pwFlash + 3) = (uint8_t)0;
    862          #endif
    863          }
    864          
    865          /**
    866            * @brief  Waits for a Flash operation to complete.
    867            * @note   The call and execution of this function must be done from RAM in case
    868            *         of Block operation, otherwise it can be executed from Flash
    869            * @param  FLASH_MemType : Memory type
    870            *          This parameter can be one of the following values:
    871            *            @arg FLASH_MemType_Program: Program memory
    872            *            @arg FLASH_MemType_Data: Data EEPROM memory 
    873            * @retval FLASH status
    874            */
    875          IN_RAM(FLASH_Status_T FLASH_WaitForLastOperation(FLASH_MemType_T FLASH_MemType))
    876          {
    877            uint16_t timeout = OPERATION_TIMEOUT;
    878            uint8_t flagstatus = 0x00;
    879            
    880            /* Wait until operation completion or write protected page occurred */
    881            if(FLASH_MemType == FLASH_MemType_Program)
    882            {
    883              while((flagstatus == 0x00) && (timeout != 0x00))
    884              {
    885                flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_EOP |
    886                                                                FLASH_IAPSR_WR_PG_DIS));
    887                timeout--;
    888              }
    889            }
    890            else
    891            {
    892              while((flagstatus == 0x00) && (timeout != 0x00))
    893              {
    894                flagstatus = (uint8_t)(FLASH->IAPSR & (uint8_t)(FLASH_IAPSR_HVOFF |
    895                                                                FLASH_IAPSR_WR_PG_DIS));
    896                timeout--;
    897              }
    898            }
    899            
    900            if(timeout == 0x00)
    901            {
    902              flagstatus = FLASH_Status_TimeOut;
    903            }
    904            
    905            return((FLASH_Status_T)flagstatus);
    906          }
    907          
    908          #if defined (_COSMIC_) && defined (RAM_EXECUTION)
    909           /* End of FLASH_CODE section */
    910           #pragma section ()
    911          #endif /* _COSMIC_ && RAM_EXECUTION */
    912          
    913          /**
    914            * @}
    915            */
    916          
    917          /**
    918            * @}
    919            */
    920             
    921            /**
    922            * @}
    923            */ 
    924            
    925            /**
    926            * @}
    927            */ 
    928            
    929          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      11  ??Subroutine3_0
       4  ?Subroutine0
      11  ?Subroutine1
      10  ?Subroutine2
      16  FLASH_DeInit
      58  FLASH_EraseBlock
       6  FLASH_EraseByte
      31  FLASH_EraseOptionByte
      20  FLASH_GetBootSize
      20  FLASH_GetCodeSize
      14  FLASH_GetFlagStatus
       6  FLASH_GetPowerStatus
       6  FLASH_GetProgrammingTime
      16  FLASH_GetReadOutProtectionStatus
      13  FLASH_ITConfig
       7  FLASH_Lock
      14  FLASH_PowerRunModeConfig
      14  FLASH_PowerWaitModeConfig
     113  FLASH_ProgramBlock
       5  FLASH_ProgramByte
      30  FLASH_ProgramOptionByte
      54  FLASH_ProgramWord
       5  FLASH_ReadByte
      11  FLASH_SetProgrammingTime
      26  FLASH_Unlock
      38  FLASH_WaitForLastOperation

 
 559 bytes in section .far_func.text
 
 559 bytes of CODE memory

Errors: none
Warnings: none
